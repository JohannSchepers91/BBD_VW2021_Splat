type double = number;
type float = number;
type byte = 0xff;
type short = number;
type int = number;
type long = number;
type char = string;
declare var server : cn.nukkit.Server;
declare var plugin : cn.nukkit.plugin.Plugin;
declare var logger : com.blocklynukkit.loader.other.BNLogger;
type FunV = string | Function;
type Fun<T> = string | ((a: T) => void);
type Fun2<A, B> = string | ((a: A, b: B) => void);
type Fun3<A, B, C> = string | ((a: A, b: B, c: C) => void);
type Fun4<A, B, C, D> = string | ((a: A, b: B, c: C, d: D) => void);
type Fun5<A, B, C, D, E> = string | ((a: A, b: B, c: C, d: D, e: E) => void);
function F<A, B, C, D, E>(input: Fun5<A, B, C, D, E>) : Fun5<A, B, C, D, E>;
function F<A, B, C, D>(input: Fun4<A, B, C, D>) : Fun3<A, B, C, D>;
function F<A, B, C>(input: Fun3<A, B, C>) : Fun3<A, B, C>;
function F<A, B>(input: Fun2<A, B>) : Fun2<A, B>;
function F<A>(input: Fun<A>) : Fun<A>;
function F(input: FunV) : FunV;
declare namespace java.lang{
    class Object{}
    type String = string;
    type Integer = number;
    type Long = number;
    type Float = number;
    type Double = number;
    type Short = number;
    type Byte = 0xff;
    type Character = string;
}
declare namespace java.math{
    type BigDecimal = number;
    type BigInteger = number;
}
/** 一个来自Java的类 */
/**
 * @version 1.2.9.4
 */
interface Class{}
/**
 * @version 1.2.9.4
 * @param {java.lang.String} 要导入的模块或者java类的名称
 */
declare function require(className:java.lang.String): Class;
/**
 * @version 1.2.9.4
 */
declare namespace Java{
    /** 
     * 将一个java类导入到js中
     * @param {string} className java类的全类名
     */
    function type(className: java.lang.String): Class;
    /**
     * 用js继承并拓展一个java类
     * @param {Class} clazz 被继承拓展的java类对象
     * @param {any} methods 包含拓展函数的js对象
     */
    function extend(clazz: Class, methods: any): Class;
    /**
     * 将java对象转为合适的js数组或对象
     * @param {Class} input 要被转换的java对象
     * @example Java.from(java数组) = 对应的js数组
     * @example Java.from(javaMap) = 对应js对象
     */
    function from(input: any): any;
    /**
     * 将java对象转为合适的js数组或对象
     * @param {Class} input 要被转换的java对象
     * @example Java.from(java数组) = 对应的js数组
     * @example Java.from(javaMap) = 对应js对象
     */
    function from(input: java.util.List): Array<any>;
    /**
     * 将java对象转为合适的js数组或对象
     * @param {Class} input 要被转换的java对象
     * @example Java.from(java数组) = 对应的js数组
     * @example Java.from(javaMap) = 对应js对象
     */
    function from(input: java.util.Map): JSON;
    /**
     * 将js数组或对象转为合适的java对象
     * @param {any} input 要被转换的js对象
     * @param {(Class|string)} 要转换到的java类
     * @example Java.to(new Array()) = 对应的java数组
     * @example Java.to(new Object()) = 对应的javaMap
     */
    function to(input: any,toClass: Class|string): any;
    /**
     * 将js数组或对象转为合适的java对象
     * @param {any} input 要被转换的js对象
     * @param {(Class|string)} 要转换到的java类
     * @example Java.to(new Array()) = 对应的java数组
     * @example Java.to(new Object()) = 对应的javaMap
     */
    function to(input: Array<any>,toClass: Class|string): java.util.List;
}declare namespace cn.nukkit.event.player{
     class PlayerBedEnterEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        bed: cn.nukkit.block.Block;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getBed(): cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.block{
     class BlockTallGrass extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        TALL_GRASS_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AdventureSettingsPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NO_CLIP: int;
        /**  */
        OPEN_CONTAINERS: int;
        /**  */
        FLYING: int;
        /**  */
        DOORS_AND_SWITCHES: int;
        /**  */
        ATTACK_PLAYERS: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        flags: long;
        /**  */
        entityUniqueId: long;
        /**  */
        PERMISSION_OPERATOR: int;
        /**  */
        NO_PVP: int;
        /**  */
        WORLD_IMMUTABLE: int;
        /**  */
        WORLD_BUILDER: int;
        /**  */
        PERMISSION_AUTOMATION: int;
        /**  */
        ALLOW_FLIGHT: int;
        /**  */
        AUTO_JUMP: int;
        /**  */
        PERMISSION_NORMAL: int;
        /**  */
        flags2: long;
        /**  */
        commandPermission: long;
        /**  */
        ATTACK_MOBS: int;
        /**  */
        playerPermission: long;
        /**  */
        MUTED: int;
        /**  */
        BUILD_AND_MINE: int;
        /**  */
        BITFLAG_SECOND_SET: int;
        /**  */
        OPERATOR: int;
        /**  */
        PERMISSION_HOST: int;
        /**  */
        TELEPORT: int;
        /**  */
        PERMISSION_ADMIN: int;
        /**  */
        customFlags: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         * @param {int} flag 
         * @param {boolean} value 
         */
        public setFlag(flag: int,value: boolean): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         * @param {int} flag 
         */
        public getFlag(flag: int): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemSweetBerries extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedWhite extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ShowCreditsPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        STATUS_END_CREDITS: int;
        /**  */
        eid: long;
        /**  */
        STATUS_START_CREDITS: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        status: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityArmorChangeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        newItem: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        oldItem: cn.nukkit.item.Item;
        /**  */
        slot: int;
        /**
         * 
         */
        public getSlot(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} newItem 
         */
        public setNewItem(newItem: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getOldItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentWaterBreath extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockLiquid extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        adjacentSources: int;
        /**  */
        LIQUID_DEPTH: cn.nukkit.blockproperty.IntBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        CAN_FLOW: byte;
        /**  */
        CAN_FLOW_DOWN: byte;
        /**  */
        BLOCKED: byte;
        /**  */
        flowVector: cn.nukkit.math.Vector3;
        /**  */
        flowCostVisited: it.unimi.dsi.fastutil.longs.Long2ByteMap;
        /**
         * 
         */
        public clearCaches(): void;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getLightFilter(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public addVelocityToEntity(entity: cn.nukkit.entity.Entity,vector: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getFlowVector(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected getEffectiveFlowDecay(block: cn.nukkit.block.Block): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         * @param {int} liquidDepth 
         */
        public setLiquidDepth(liquidDepth: int): void;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        protected checkForHarden(): void;
        /**
         * 
         */
        public isSource(): boolean;
        /**
         * 
         */
        public isSourceOrFlowingDown(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} cause 
         * @param {cn.nukkit.block.Block} result 
         */
        protected liquidCollide(cause: cn.nukkit.block.Block,result: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getLiquidDepth(): int;
        /**
         * 
         * @param {int} meta 
         */
        public abstract getBlock(meta: int): cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public getDepthOnTop(): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected canFlowInto(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        protected triggerLavaMixEffects(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} decay 
         */
        private getSmallestFlowDecay(block: cn.nukkit.block.Block,decay: int): int;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected getFlowDecay(block: cn.nukkit.block.Block): int;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} newFlowDecay 
         */
        protected flowIntoBlock(block: cn.nukkit.block.Block,newFlowDecay: int): void;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getFluidHeightPercent(): float;
        /**
         * 
         * @param {int} blockX 
         * @param {int} blockY 
         * @param {int} blockZ 
         * @param {int} accumulatedCost 
         * @param {int} maxCost 
         * @param {int} originOpposite 
         * @param {int} lastOpposite 
         */
        private calculateFlowCost(blockX: int,blockY: int,blockZ: int,accumulatedCost: int,maxCost: int,originOpposite: int,lastOpposite: int): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public isFlowingDown(): boolean;
        /**
         * 
         */
        public getFlowDecayPerBlock(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        private getOptimalFlowDirections(): boolean[];
        /**
         * 
         */
        public usesWaterLogging(): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.forest{
     class ForestBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**  */
        TYPE_BIRCH: int;
        /**  */
        TYPE_NORMAL: int;
        /**  */
        type: int;
        /**  */
        TYPE_BIRCH_TALL: int;
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorBirch extends cn.nukkit.block.BlockDoorWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MoveEntityDeltaPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        yawDelta: double;
        /**  */
        FLAG_HAS_PITCH: int;
        /**  */
        zDelta: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        FLAG_HAS_YAW: int;
        /**  */
        FLAG_HAS_HEAD_YAW: int;
        /**  */
        flags: int;
        /**  */
        xDecoded: int;
        /**  */
        yDecoded: int;
        /**  */
        zDecoded: int;
        /**  */
        headYawDelta: double;
        /**  */
        pitchDelta: double;
        /**  */
        xDelta: int;
        /**  */
        yDelta: int;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        FLAG_HAS_Z: int;
        /**  */
        FLAG_HAS_X: int;
        /**  */
        FLAG_HAS_Y: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         * @param {int} flag 
         */
        private getCoordinate(flag: int): float;
        /**
         * 
         * @param {int} flag 
         * @param {float} value 
         */
        private putCoordinate(flag: int,value: float): void;
        /**
         * 
         * @param {int} flag 
         */
        private getRotation(flag: int): double;
        /**
         * 
         * @param {int} flag 
         * @param {double} value 
         */
        private putRotation(flag: int,value: double): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ModalFormRequestPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        formId: int;
        /**  */
        data: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockCobblestone extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace java.util{
     class Vector extends java.util.AbstractList{
        /**  */
        serialVersionUID: long;
        /**  */
        capacityIncrement: int;
        /**  */
        MAX_ARRAY_SIZE: int;
        /**  */
        elementData: java.lang.Object[];
        /**  */
        elementCount: int;
        /**
         * 
         */
        public  firstElement(): java.lang.Object;
        /**
         * 
         * @param {int} arg0 
         */
        private static hugeCapacity(arg0: int): int;
        /**
         * 
         * @param {java.util.function.UnaryOperator} arg0 
         */
        public  replaceAll(arg0: java.util.function.UnaryOperator): void;
        /**
         * 
         * @param {int} arg0 
         */
        public  remove(arg0: int): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public remove(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public  capacity(): int;
        /**
         * 
         */
        public  iterator(): java.util.Iterator;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public  removeAll(arg0: java.util.Collection): boolean;
        /**
         * 
         * @param {int} arg0 
         */
        public  setSize(arg0: int): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {int} arg1 
         */
        public  setElementAt(arg0: java.lang.Object,arg1: int): void;
        /**
         * 
         */
        public  hashCode(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public  get(arg0: int): java.lang.Object;
        /**
         * 
         */
        public  toArray(): java.lang.Object[];
        /**
         * 
         * @param {java.lang.Object[]} arg0 
         */
        public  toArray(arg0: java.lang.Object[]): java.lang.Object[];
        /**
         * 
         * @param {int} arg0 
         */
        public  elementAt(arg0: int): java.lang.Object;
        /**
         * 
         * @param {int} arg0 
         */
        public  removeElementAt(arg0: int): void;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        protected  removeRange(arg0: int,arg1: int): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {int} arg1 
         */
        public  indexOf(arg0: java.lang.Object,arg1: int): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public indexOf(arg0: java.lang.Object): int;
        /**
         * 
         */
        public  removeAllElements(): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  add(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.Object} arg1 
         */
        public add(arg0: int,arg1: java.lang.Object): void;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public  subList(arg0: int,arg1: int): java.util.List;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.Object} arg1 
         */
        public  set(arg0: int,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         */
        public  trimToSize(): void;
        /**
         * 
         * @param {int} arg0 
         */
        private grow(arg0: int): void;
        /**
         * 
         */
        public spliterator(): java.util.Spliterator;
        /**
         * 
         * @param {int} arg0 
         */
         elementData(arg0: int): java.lang.Object;
        /**
         * 
         * @param {int} arg0 
         */
        private ensureCapacityHelper(arg0: int): void;
        /**
         * 
         * @param {java.io.ObjectOutputStream} arg0 
         */
        private writeObject(arg0: java.io.ObjectOutputStream): void;
        /**
         * 
         * @param {java.util.function.Consumer} arg0 
         */
        public  forEach(arg0: java.util.function.Consumer): void;
        /**
         * 
         * @param {java.lang.Object[]} arg0 
         */
        public  copyInto(arg0: java.lang.Object[]): void;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public  containsAll(arg0: java.util.Collection): boolean;
        /**
         * 
         */
        public clear(): void;
        /**
         * 
         */
        public  isEmpty(): boolean;
        /**
         * 
         * @param {java.util.Comparator} arg0 
         */
        public  sort(arg0: java.util.Comparator): void;
        /**
         * 
         * @param {java.util.function.Predicate} arg0 
         */
        public  removeIf(arg0: java.util.function.Predicate): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {int} arg1 
         */
        public  lastIndexOf(arg0: java.lang.Object,arg1: int): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  lastIndexOf(arg0: java.lang.Object): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public contains(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {int} arg1 
         */
        public  insertElementAt(arg0: java.lang.Object,arg1: int): void;
        /**
         * 
         */
        public  size(): int;
        /**
         * 
         * @param {int} arg0 
         * @param {java.util.Collection} arg1 
         */
        public  addAll(arg0: int,arg1: java.util.Collection): boolean;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public  addAll(arg0: java.util.Collection): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public elements(): java.util.Enumeration;
        /**
         * 
         */
        public  lastElement(): java.lang.Object;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public  listIterator(): java.util.ListIterator;
        /**
         * 
         * @param {int} arg0 
         */
        public  listIterator(arg0: int): java.util.ListIterator;
        /**
         * 
         */
        public  toString(): java.lang.String;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  addElement(arg0: java.lang.Object): void;
        /**
         * 
         * @param {int} arg0 
         */
        public  ensureCapacity(arg0: int): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  removeElement(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public  retainAll(arg0: java.util.Collection): boolean;
    }
}
declare namespace cn.nukkit.event.weather{
     class LightningStrikeEvent extends cn.nukkit.event.level.WeatherEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        bolt: cn.nukkit.entity.weather.EntityLightningStrike;
        /**
         * 
         */
        public getLightning(): cn.nukkit.entity.weather.EntityLightningStrike;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.plugin{
     class PluginLoadOrder extends java.lang.Enum{
        /**  */
        POSTWORLD: cn.nukkit.plugin.PluginLoadOrder;
        /**  */
        STARTUP: cn.nukkit.plugin.PluginLoadOrder;
        /**  */
        $VALUES: cn.nukkit.plugin.PluginLoadOrder[];
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.plugin.PluginLoadOrder;
        /**
         * 
         */
        public static values(): cn.nukkit.plugin.PluginLoadOrder[];
    }
}
declare namespace cn.nukkit.item{
     class ItemBook extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getEnchantAbility(): int;
    }
}
declare namespace cn.nukkit.level.format.anvil{
     class RegionLoader extends cn.nukkit.level.format.generic.BaseRegionLoader{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public doSlowCleanUp(): int;
        /**
         * 
         */
        protected createBlank(): void;
        /**
         * 
         */
        private cleanGarbage(): int;
        /**
         * 
         */
        private writeLocationTable(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public  readChunk(x: int,z: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public readChunk(x: int,z: int): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         */
        protected loadLocationTable(): void;
        /**
         * 
         * @param {byte[]} data 
         */
        protected  unserializeChunk(data: byte[]): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {byte[]} data 
         */
        protected unserializeChunk(data: byte[]): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public writeChunk(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         */
        public getX(): int;
        /**
         * 
         * @param {int} index 
         */
        protected isChunkGenerated(index: int): boolean;
        /**
         * 
         */
        public getZ(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        protected static getChunkOffset(x: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {byte[]} chunkData 
         */
        protected saveChunk(x: int,z: int,chunkData: byte[]): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public removeChunk(x: int,z: int): void;
        /**
         * 
         * @param {int} index 
         */
        protected writeLocationIndex(index: int): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public chunkExists(x: int,z: int): boolean;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityLiving extends cn.nukkit.entity.Entity{
        /**  */
        attackTimeByShieldKb: boolean;
        /**  */
        attackTime: int;
        /**  */
        turtleTicks: int;
        /**  */
        invisible: boolean;
        /**  */
        attackTimeBefore: int;
        /**  */
        movementSpeed: float;
        /**
         * 
         * @param {boolean} value 
         */
        public setBlocking(value: boolean): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public postAttack(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public preAttack(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} ent 
         */
        public collidingWith(ent: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getMovementSpeed(): float;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public hasLineOfSight(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public isPersistent(): boolean;
        /**
         * 
         * @param {float} speed 
         */
        public setMovementSpeed(speed: float): void;
        /**
         * 
         */
        protected getGravity(): float;
        /**
         * 
         * @param {float} health 
         */
        public setHealth(health: float): void;
        /**
         * 
         * @param {int} ticks 
         */
        public setAirTicks(ticks: int): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public isBlocking(): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        protected blockedByShield(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public entityBaseTick(): boolean;
        /**
         * 
         * @param {int} tickDiff 
         */
        public entityBaseTick(tickDiff: int): boolean;
        /**
         * 
         * @param {boolean} persistent 
         */
        public setPersistent(persistent: boolean): void;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public kill(): void;
        /**
         * 
         * @param {int} maxDistance 
         * @param {int} maxLength 
         * @param {java.lang.Integer[]} transparent 
         */
        public getLineOfSight(maxDistance: int,maxLength: int,transparent: java.lang.Integer[]): cn.nukkit.block.Block[];
        /**
         * 
         * @param {int} maxDistance 
         * @param {int} maxLength 
         * @param {java.util.Map} transparent 
         */
        public getLineOfSight(maxDistance: int,maxLength: int,transparent: java.util.Map): cn.nukkit.block.Block[];
        /**
         * 
         * @param {int} maxDistance 
         */
        public getLineOfSight(maxDistance: int): cn.nukkit.block.Block[];
        /**
         * 
         * @param {int} maxDistance 
         * @param {int} maxLength 
         */
        public getLineOfSight(maxDistance: int,maxLength: int): cn.nukkit.block.Block[];
        /**
         * 
         */
        public getAirTicks(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {boolean} animate 
         */
        protected onBlock(entity: cn.nukkit.entity.Entity,animate: boolean): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {double} damage 
         * @param {double} x 
         * @param {double} z 
         */
        public knockBack(attacker: cn.nukkit.entity.Entity,damage: double,x: double,z: double): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {double} damage 
         * @param {double} x 
         * @param {double} z 
         * @param {double} base 
         */
        public knockBack(attacker: cn.nukkit.entity.Entity,damage: double,x: double,z: double,base: double): void;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} maxDistance 
         * @param {java.lang.Integer[]} transparent 
         */
        public getTargetBlock(maxDistance: int,transparent: java.lang.Integer[]): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} maxDistance 
         */
        public getTargetBlock(maxDistance: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} maxDistance 
         * @param {java.util.Map} transparent 
         */
        public getTargetBlock(maxDistance: int,transparent: java.util.Map): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerEatFoodEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        food: cn.nukkit.item.food.Food;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.item.food.Food} food 
         */
        public setFood(food: cn.nukkit.item.food.Food): void;
        /**
         * 
         */
        public getFood(): cn.nukkit.item.food.Food;
    }
}
declare namespace cn.nukkit.block{
     class BlockFire extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        FIRE_AGE: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public tickRate(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canNeighborBurn(): boolean;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public isBlockTopFacingSurfaceSolid(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        private getChanceOfNeighborsEncouragingFire(block: cn.nukkit.block.Block): int;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} bound 
         * @param {int} damage 
         */
        private tryToCatchBlockOnFire(block: cn.nukkit.block.Block,bound: int,damage: int): void;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.command{
    abstract class PluginIdentifiableCommand extends java.lang.Object{
        /**
         * 
         */
        public abstract getPlugin(): cn.nukkit.plugin.Plugin;
    }
}
declare namespace cn.nukkit.utils{
     class MainLogger extends cn.nukkit.utils.ThreadedLogger{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        logger: cn.nukkit.utils.MainLogger;
        /**
         * 
         * @param {java.lang.Throwable} t 
         */
        public logException(t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public debug(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public debug(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public critical(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public critical(message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         * @param {java.lang.String} message 
         */
        public log(level: cn.nukkit.utils.LogLevel,message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public log(level: cn.nukkit.utils.LogLevel,message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.Boolean} logDebug 
         */
        public setLogDebug(logDebug: java.lang.Boolean): void;
        /**
         * 
         */
        public static getLogger(): cn.nukkit.utils.MainLogger;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public emergency(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public emergency(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public error(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public error(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public alert(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public alert(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public warning(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public warning(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         */
        public shutdown(): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public info(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public info(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public notice(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public notice(message: java.lang.String,t: java.lang.Throwable): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class SpellParticle extends cn.nukkit.level.particle.Particle{
        /**  */
        data: int;
        /**
         * 
         */
        public encode(): cn.nukkit.network.protocol.DataPacket[];
    }
}
declare namespace cn.nukkit.block{
     class BlockCarrot extends cn.nukkit.block.BlockCrops{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.plugin{
    abstract class Plugin extends java.lang.Object{
        /**  */
        EMPTY_ARRAY: cn.nukkit.plugin.Plugin[];
        /**
         * 
         */
        public abstract getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public abstract getResource(filename: java.lang.String): java.io.InputStream;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         */
        public abstract getLogger(): cn.nukkit.plugin.PluginLogger;
        /**
         * 
         */
        public abstract onEnable(): void;
        /**
         * 
         */
        public abstract getDataFolder(): java.io.File;
        /**
         * 
         */
        public abstract getDescription(): cn.nukkit.plugin.PluginDescription;
        /**
         * 
         */
        public abstract saveDefaultConfig(): void;
        /**
         * 
         */
        public abstract onDisable(): void;
        /**
         * 
         */
        public abstract getConfig(): cn.nukkit.utils.Config;
        /**
         * 
         */
        public abstract saveConfig(): void;
        /**
         * 
         */
        public abstract isEnabled(): boolean;
        /**
         * 
         */
        public abstract reloadConfig(): void;
        /**
         * 
         */
        public abstract onLoad(): void;
        /**
         * 
         */
        public abstract isDisabled(): boolean;
        /**
         * 
         */
        public abstract getPluginLoader(): cn.nukkit.plugin.PluginLoader;
        /**
         * 
         * @param {java.lang.String} filename 
         * @param {java.lang.String} outputName 
         * @param {boolean} replace 
         */
        public abstract saveResource(filename: java.lang.String,outputName: java.lang.String,replace: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} filename 
         * @param {boolean} replace 
         */
        public abstract saveResource(filename: java.lang.String,replace: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public abstract saveResource(filename: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityElderGuardian extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace com.nukkitx.fakeinventories.inventory{
     class ChestFakeInventory extends com.nukkitx.fakeinventories.inventory.FakeInventory{
        /**  */
        name: java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public setName(arg0: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} arg0 
         * @param {java.lang.String} arg1 
         */
        private static getNbt(arg0: cn.nukkit.math.BlockVector3,arg1: java.lang.String): byte[];
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        protected onOpenBlock(arg0: cn.nukkit.Player): java.util.List;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         * @param {cn.nukkit.math.BlockVector3} arg1 
         */
        protected placeChest(arg0: cn.nukkit.Player,arg1: cn.nukkit.math.BlockVector3): void;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntitySpawnEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        entityType: int;
        /**
         * 
         */
        public isCreature(): boolean;
        /**
         * 
         */
        public getPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isVehicle(): boolean;
        /**
         * 
         */
        public isItem(): boolean;
        /**
         * 
         */
        public isHuman(): boolean;
        /**
         * 
         */
        public isProjectile(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemDye extends cn.nukkit.item.Item{
        /**  */
        WHITE: int;
        /**  */
        GRAY: int;
        /**  */
        BLUE: int;
        /**  */
        PURPLE: int;
        /**  */
        GREEN: int;
        /**  */
        RED: int;
        /**  */
        PINK: int;
        /**  */
        LIGHT_GRAY: int;
        /**  */
        LIGHT_BLUE: int;
        /**  */
        LIME: int;
        /**  */
        MAGENTA: int;
        /**  */
        BLACK: int;
        /**  */
        YELLOW: int;
        /**  */
        CYAN: int;
        /**  */
        BROWN: int;
        /**  */
        ORANGE: int;
        /**
         * 
         */
        public isLapisLazuli(): boolean;
        /**
         * 
         * @param {int} meta 
         */
        public static getColorName(meta: int): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         * @param {int} meta 
         */
        public static getColor(meta: int): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public isCocoaBeans(): boolean;
        /**
         * 
         */
        public isFertilizer(): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.mesa{
     class MesaPlateauFMBiome extends cn.nukkit.level.biome.impl.mesa.MesaPlateauFBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.command.data{
     class CommandDataVersions extends java.lang.Object{
        /**  */
        versions: java.util.List;
    }
}
declare namespace cn.nukkit.entity.data{
     class FloatEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        data: float;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Float} data 
         */
        public setData(data: java.lang.Float): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): java.lang.Float;
    }
}
declare namespace cn.nukkit.item{
     class ItemCauldron extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockCraftingTable extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceGate extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        IN_WALL: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        offMaxX: double[];
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        offMinZ: double[];
        /**  */
        manualOverrides: java.util.List;
        /**  */
        offMinX: double[];
        /**  */
        offMaxZ: double[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} open 
         */
        public setOpen(player: cn.nukkit.Player,open: boolean): boolean;
        /**
         * 
         * @param {boolean} open 
         */
        public setOpen(open: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getManualOverride(): boolean;
        /**
         * 
         */
        public playOpenSound(): void;
        /**
         * 
         */
        public isInWall(): boolean;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        private onRedstoneUpdate(): void;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {boolean} val 
         */
        public setManualOverride(val: boolean): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {boolean} inWall 
         */
        public setInWall(inWall: boolean): void;
        /**
         * 
         */
        private getOffsetIndex(): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public toggle(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public playOpenCloseSound(): void;
        /**
         * 
         */
        public isOpen(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public playCloseSound(): void;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
    }
}
declare namespace cn.nukkit.lang{
     class TextContainer extends java.lang.Object{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        text: java.lang.String;
        /**
         * 
         */
        public getText(): java.lang.String;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} text 
         */
        public setText(text: java.lang.String): void;
    }
}
declare namespace cn.nukkit.level.biome.type{
    abstract class SandyBiome extends cn.nukkit.level.biome.type.CoveredBiome{
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundDepth(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceDepth(y: int): int;
    }
}
declare namespace cn.nukkit.network{
     class RakNetInterface extends java.lang.Object{
        /**  */
        raknet: com.nukkitx.network.raknet.RakNetServer;
        /**  */
        server: cn.nukkit.Server;
        /**  */
        sessions: java.util.Map;
        /**  */
        sessionCreationQueue: java.util.Queue;
        /**  */
        sessionsToTick: io.netty.util.concurrent.FastThreadLocal;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        advertisement: byte[];
        /**  */
        tickFutures: java.util.Set;
        /**  */
        network: cn.nukkit.network.Network;
        /**
         * 
         */
        static access$700(): org.apache.logging.log4j.Logger;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        private lambda$new$0(): void;
        /**
         * 
         * @param {java.net.InetSocketAddress} inetSocketAddress 
         */
        public onConnectionRequest(inetSocketAddress: java.net.InetSocketAddress): boolean;
        /**
         * 
         * @param {io.netty.util.concurrent.ScheduledFuture} future 
         */
        private static lambda$emergencyShutdown$2(future: io.netty.util.concurrent.ScheduledFuture): void;
        /**
         * 
         * @param {cn.nukkit.network.RakNetInterface} arg0 
         */
        static access$600(arg0: cn.nukkit.network.RakNetInterface): cn.nukkit.network.Network;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {boolean} needACK 
         */
        public putPacket(player: cn.nukkit.Player,packet: cn.nukkit.network.protocol.DataPacket,needACK: boolean): java.lang.Integer;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {boolean} needACK 
         * @param {boolean} immediate 
         */
        public putPacket(player: cn.nukkit.Player,packet: cn.nukkit.network.protocol.DataPacket,needACK: boolean,immediate: boolean): java.lang.Integer;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public putPacket(player: cn.nukkit.Player,packet: cn.nukkit.network.protocol.DataPacket): java.lang.Integer;
        /**
         * 
         */
        public process(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public getNetworkLatency(player: cn.nukkit.Player): int;
        /**
         * 
         * @param {java.net.InetAddress} address 
         */
        public unblockAddress(address: java.net.InetAddress): void;
        /**
         * 
         * @param {io.netty.util.concurrent.ScheduledFuture} future 
         */
        private static lambda$shutdown$1(future: io.netty.util.concurrent.ScheduledFuture): void;
        /**
         * 
         */
        public emergencyShutdown(): void;
        /**
         * 
         * @param {cn.nukkit.network.RakNetInterface} arg0 
         */
        static access$800(arg0: cn.nukkit.network.RakNetInterface): io.netty.util.concurrent.FastThreadLocal;
        /**
         * 
         * @param {io.netty.channel.ChannelHandlerContext} ctx 
         * @param {io.netty.channel.socket.DatagramPacket} datagramPacket 
         */
        public onUnhandledDatagram(ctx: io.netty.channel.ChannelHandlerContext,datagramPacket: io.netty.channel.socket.DatagramPacket): void;
        /**
         * 
         * @param {cn.nukkit.network.Network} network 
         */
        public setNetwork(network: cn.nukkit.network.Network): void;
        /**
         * 
         * @param {java.net.InetSocketAddress} socketAddress 
         * @param {io.netty.buffer.ByteBuf} payload 
         */
        public sendRawPacket(socketAddress: java.net.InetSocketAddress,payload: io.netty.buffer.ByteBuf): void;
        /**
         * 
         * @param {cn.nukkit.network.RakNetInterface.NukkitRakNetSession} nukkitSession 
         */
        private lambda$onSessionCreation$3(nukkitSession: cn.nukkit.network.RakNetInterface.NukkitRakNetSession): void;
        /**
         * 
         * @param {com.nukkitx.network.raknet.RakNetServerSession} session 
         */
        public onSessionCreation(session: com.nukkitx.network.raknet.RakNetServerSession): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public close(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {java.lang.String} reason 
         */
        public close(player: cn.nukkit.Player,reason: java.lang.String): void;
        /**
         * 
         * @param {java.net.InetSocketAddress} inetSocketAddress 
         */
        public onQuery(inetSocketAddress: java.net.InetSocketAddress): byte[];
        /**
         * 
         */
        public shutdown(): void;
        /**
         * 
         * @param {java.net.InetAddress} address 
         * @param {int} timeout 
         */
        public blockAddress(address: java.net.InetAddress,timeout: int): void;
        /**
         * 
         * @param {java.net.InetAddress} address 
         */
        public blockAddress(address: java.net.InetAddress): void;
    }
}
declare namespace com.blocklynukkit.loader.other.control{
     class JVM extends java.lang.Object{
        /**
         * 创建新的java类
         * @param {java.lang.String} className java类名
         * @param {java.lang.String} extendFromClass 继承自的父类类名
         * @param {java.lang.String[]} interfaceClasses 实现的接口类名
         */
        public  newJVMClass(className: java.lang.String,extendFromClass: java.lang.String,...interfaceClasses: java.lang.String[]): com.blocklynukkit.loader.other.control.JClass;
        /**
         * 创建新的java类
         * @param {java.lang.String} className java类名
         */
        public newJVMClass(className: java.lang.String): com.blocklynukkit.loader.other.control.JClass;
        /**
         * 以jvm形式获取java类对象
         * @param {java.lang.String} className java类名
         */
        public getJVMClass(className: java.lang.String): java.lang.Class;
        /**
         * 强制关闭JVM
         * @param {int} returnCode 退出返回值，默认为0
         */
        public close(returnCode: int): void;
        /**
         * 强制关闭JVM
         */
        public close(): void;
        /**
         * 获取JVM内存情况对象
         */
        public getMemory(): com.blocklynukkit.loader.other.control.JMemory;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerSkinPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        newSkinName: java.lang.String;
        /**  */
        oldSkinName: java.lang.String;
        /**  */
        skin: cn.nukkit.entity.data.Skin;
        /**  */
        uuid: java.util.UUID;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockSignPost extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        GROUND_SIGN_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getWallId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        public getSignDirection(): cn.nukkit.math.CompassRoseDirection;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.math.CompassRoseDirection} direction 
         */
        public setSignDirection(direction: cn.nukkit.math.CompassRoseDirection): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        protected getPostId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.permission{
    abstract class Permissible extends java.lang.Object{
        /**
         * 
         */
        public abstract getEffectivePermissions(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public abstract hasPermission(name: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public abstract hasPermission(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         */
        public abstract recalculatePermissions(): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         */
        public abstract addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public abstract addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         * @param {java.lang.Boolean} value 
         */
        public abstract addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String,value: java.lang.Boolean): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.permission.PermissionAttachment} attachment 
         */
        public abstract removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public abstract isPermissionSet(name: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public abstract isPermissionSet(permission: cn.nukkit.permission.Permission): boolean;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityBlaze extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemBone extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.nbt.tag{
     class EndTag extends cn.nukkit.nbt.tag.Tag{
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class HelpCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.entity.data{
     class ByteEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        data: int;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Integer} data 
         */
        public setData(data: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): java.lang.Integer;
    }
}
declare namespace cn.nukkit.level.biome.type{
    abstract class GrassyBiome extends cn.nukkit.level.biome.type.CoveredBiome{
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundBlock(y: int): int;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class LongTag extends cn.nukkit.nbt.tag.NumberTag{
        /**  */
        data: long;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         * @param {java.lang.Long} data 
         */
        public setData(data: java.lang.Long): void;
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public  setData(data: java.lang.Number): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): java.lang.Long;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public  getData(): java.lang.Number;
        /**
         * 
         */
        public getData(): java.lang.Long;
    }
}
declare namespace cn.nukkit.nbt.stream{
     class FastByteArrayOutputStream extends java.io.OutputStream{
        /**  */
        ONEOVERPHI: long;
        /**  */
        array: byte[];
        /**  */
        length: int;
        /**  */
        position: int;
        /**  */
        DEFAULT_INITIAL_CAPACITY: int;
        /**
         * 
         * @param {byte[]} array 
         * @param {int} length 
         * @param {int} preserve 
         */
        public static grow(array: byte[],length: int,preserve: int): byte[];
        /**
         * 
         * @param {byte[]} array 
         * @param {int} length 
         */
        public static grow(array: byte[],length: int): byte[];
        /**
         * 
         */
        public toByteArray(): byte[];
        /**
         * 
         */
        public length(): long;
        /**
         * 
         */
        public reset(): cn.nukkit.nbt.stream.FastByteArrayOutputStream;
        /**
         * 
         * @param {int} arrayLength 
         * @param {int} offset 
         * @param {int} length 
         */
        public static ensureOffsetLength(arrayLength: int,offset: int,length: int): void;
        /**
         * 
         * @param {long} newPosition 
         */
        public position(newPosition: long): void;
        /**
         * 
         */
        public position(): long;
        /**
         * 
         * @param {byte[]} b 
         * @param {int} off 
         * @param {int} len 
         */
        public write(b: byte[],off: int,len: int): void;
        /**
         * 
         * @param {int} b 
         */
        public write(b: int): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AvailableEntityIdentifiersPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        TAG: byte[];
        /**  */
        tag: byte[];
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockPurpur extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PURPUR_NORMAL: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        PURPUR_PILLAR: int;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.inventory{
     class ContainerRecipe extends cn.nukkit.inventory.MixRecipe{
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.RecipeType;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingManager} manager 
         */
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class EnchantCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {java.lang.String} value 
         */
        public getIdByName(value: java.lang.String): int;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class UpdateAttributesPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        entries: cn.nukkit.entity.Attribute[];
        /**  */
        NETWORK_ID: byte;
        /**  */
        entityId: long;
        /**  */
        frame: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityWitherSkeleton extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.ocean{
     class DeepOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerFormRespondedEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        formID: int;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        closed: boolean;
        /**  */
        window: cn.nukkit.form.window.FormWindow;
        /**
         * 
         */
        public getFormID(): int;
        /**
         * 
         */
        public getWindow(): cn.nukkit.form.window.FormWindow;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getResponse(): cn.nukkit.form.response.FormResponse;
        /**
         * 
         */
        public wasClosed(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceGateJungle extends cn.nukkit.block.BlockFenceGate{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace java.nio{
    abstract class Buffer extends java.lang.Object{
        /**  */
        address: long;
        /**  */
        limit: int;
        /**  */
        SPLITERATOR_CHARACTERISTICS: int;
        /**  */
        position: int;
        /**  */
        mark: int;
        /**  */
        capacity: int;
        /**
         * 
         */
        public abstract hasArray(): boolean;
        /**
         * 
         */
        public  hasRemaining(): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
         checkIndex(arg0: int,arg1: int): int;
        /**
         * 
         * @param {int} arg0 
         */
         checkIndex(arg0: int): int;
        /**
         * 
         */
        public  clear(): java.nio.Buffer;
        /**
         * 
         */
        public  remaining(): int;
        /**
         * 
         */
        public  capacity(): int;
        /**
         * 
         */
        public abstract isReadOnly(): boolean;
        /**
         * 
         */
        public  rewind(): java.nio.Buffer;
        /**
         * 
         */
         truncate(): void;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         * @param {int} arg2 
         */
        static checkBounds(arg0: int,arg1: int,arg2: int): void;
        /**
         * 
         */
        public abstract array(): java.lang.Object;
        /**
         * 
         * @param {int} arg0 
         */
         nextPutIndex(arg0: int): int;
        /**
         * 
         */
         nextPutIndex(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public  limit(arg0: int): java.nio.Buffer;
        /**
         * 
         */
        public  limit(): int;
        /**
         * 
         */
        public abstract arrayOffset(): int;
        /**
         * 
         */
        public  reset(): java.nio.Buffer;
        /**
         * 
         */
         discardMark(): void;
        /**
         * 
         * @param {int} arg0 
         */
        public  position(arg0: int): java.nio.Buffer;
        /**
         * 
         */
        public  position(): int;
        /**
         * 
         */
        public abstract isDirect(): boolean;
        /**
         * 
         */
        public  flip(): java.nio.Buffer;
        /**
         * 
         */
         nextGetIndex(): int;
        /**
         * 
         * @param {int} arg0 
         */
         nextGetIndex(arg0: int): int;
        /**
         * 
         */
        public  mark(): java.nio.Buffer;
        /**
         * 
         */
         markValue(): int;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace particle{
    /**
     * 绘制粒子点
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {int} pid 粒子id
     * @param {int} data 粒子数据值
     */
    function drawDot(pos: cn.nukkit.level.Position,pid: int,data: int): void;
    /**
     * 绘制粒子点
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {int} pid 粒子id
     * @param {int} r 粒子颜色
     * @param {int} g 粒子颜色
     * @param {int} b 粒子颜色
     */
    function drawDot(pos: cn.nukkit.level.Position,pid: int,r: int,g: int,b: int): void;
    /**
     * 绘制粒子点
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {int} pid 粒子id
     */
    function drawDot(pos: cn.nukkit.level.Position,pid: int): void;
    /**
     * 绘制粒子点
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {int} pid 粒子id
     * @param {cn.nukkit.Player} toPlayer 能看到的玩家
     */
    function drawDot(pos: cn.nukkit.level.Position,pid: int,toPlayer: cn.nukkit.Player): void;
    /**
     * 绘制粒子点
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {int} pid 粒子id
     * @param {int} data 粒子数据值
     * @param {cn.nukkit.Player} toPlayer 能看到的玩家
     */
    function drawDot(pos: cn.nukkit.level.Position,pid: int,data: int,toPlayer: cn.nukkit.Player): void;
    /**
     * 绘制粒子点
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {int} pid 粒子id
     * @param {int} r 粒子颜色
     * @param {int} g 粒子颜色
     * @param {int} b 粒子颜色
     * @param {cn.nukkit.Player} toPlayer 能看到的玩家
     */
    function drawDot(pos: cn.nukkit.level.Position,pid: int,r: int,g: int,b: int,toPlayer: cn.nukkit.Player): void;
    /**
     * 绘制用粒子组成的圆
     * @param {cn.nukkit.level.Position} pos 圆心坐标
     * @param {double} radius 半径
     * @param {int} pid 粒子id
     * @param {double} sep 每个粒子与其他粒子相隔的距离
     */
    function drawCircle(pos: cn.nukkit.level.Position,radius: double,pid: int,sep: double): void;
    /**
     * 绘制方块被破坏的粒子
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {cn.nukkit.block.Block} block 方块类型，该方块可以不是指定坐标上的方块，也可以根本不存在于世界上
     */
    function drawBlockBreak(pos: cn.nukkit.level.Position,block: cn.nukkit.block.Block): void;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 绘制粒子工厂导出粒子
     * @param {java.lang.String} fun 
     * @param {cn.nukkit.level.Position} pos 
     * @param {double} turn 
     */
    function drawParticleFactoryMcFunction(fun: java.lang.String,pos: cn.nukkit.level.Position,turn: double): void;
    /**
     * 绘制粒子发射器，详见[编程开发文档](https://wiki.blocklynukkit.com/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/#particle%E5%9F%BA%E5%AF%B9%E8%B1%A1)
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {java.lang.String} id 发射器id
     */
    function drawEmitter(pos: cn.nukkit.level.Position,id: java.lang.String): void;
    /**
     * 绘制粒子发射器，详见[编程开发文档](https://wiki.blocklynukkit.com/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/#particle%E5%9F%BA%E5%AF%B9%E8%B1%A1)
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {java.lang.String} id 发射器id
     * @param {cn.nukkit.Player} toPlayer 可以看见粒子发射器的玩家
     */
    function drawEmitter(pos: cn.nukkit.level.Position,id: java.lang.String,toPlayer: cn.nukkit.Player): void;
    /**
     * 绘制粒子发射器，详见[编程开发文档](https://wiki.blocklynukkit.com/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/#particle%E5%9F%BA%E5%AF%B9%E8%B1%A1)
     * @param {cn.nukkit.level.Position} pos 坐标
     */
    function drawEmitter(pos: cn.nukkit.level.Position): void;
    /**
     * 绘制烟花，详见[编程开发文档](https://wiki.blocklynukkit.com/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/#particle%E5%9F%BA%E5%AF%B9%E8%B1%A1)
     * @param {cn.nukkit.level.Position} pos 位置
     * @param {int} colornum 颜色码
     * @param {boolean} flick 是否闪烁
     * @param {boolean} trail 是否有曳尾
     * @param {int} shape 形状码
     * @param {int} second 飞行时间
     */
    function drawFireWork(pos: cn.nukkit.level.Position,colornum: int,flick: boolean,trail: boolean,shape: int,second: int): void;
    /**
     * 绘制粒子组成的直线
     * @param {cn.nukkit.level.Position} pos1 起点坐标
     * @param {cn.nukkit.level.Position} pos2 终点坐标
     * @param {double} sep 每个粒子与其他粒子相隔的距离
     * @param {int} pid 粒子id
     */
    function drawLine(pos1: cn.nukkit.level.Position,pos2: cn.nukkit.level.Position,sep: double,pid: int): void;
}
declare namespace cn.nukkit.command.defaults{
     class PardonIpCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.metadata{
    abstract class MetadataStore extends java.lang.Object{
        /**  */
        metadataMap: java.util.Map;
        /**
         * 
         * @param {java.lang.Object} subject 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public setMetadata(subject: java.lang.Object,metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         * @param {java.lang.Object} subject 
         * @param {java.lang.String} metadataKey 
         */
        public getMetadata(subject: java.lang.Object,metadataKey: java.lang.String): java.util.List;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public invalidateAll(owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.Object} subject 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public removeMetadata(subject: java.lang.Object,metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.String} k 
         */
        private static lambda$setMetadata$0(k: java.lang.String): java.util.Map;
        /**
         * 
         * @param {java.lang.Object} subject 
         * @param {java.lang.String} metadataKey 
         */
        public hasMetadata(subject: java.lang.Object,metadataKey: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.metadata.Metadatable} subject 
         * @param {java.lang.String} metadataKey 
         */
        protected abstract disambiguate(subject: cn.nukkit.metadata.Metadatable,metadataKey: java.lang.String): java.lang.String;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class StartFishingEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        parent: cn.nukkit.event.entity.ProjectileLaunchEvent;
        /**
         * 
         */
        public isCancelled(): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public setCancelled(value: boolean): void;
        /**
         * 
         */
        public getFishingHook(): cn.nukkit.entity.item.EntityFishingHook;
    }
}
declare namespace cn.nukkit.block{
     class BlockPistonSticky extends cn.nukkit.block.BlockPistonBase{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getPistonHeadBlockId(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemElytra extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isArmor(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace cn.nukkit.inventory.transaction{
     class CraftingTransaction extends cn.nukkit.inventory.transaction.InventoryTransaction{
        /**  */
        gridSize: int;
        /**  */
        secondaryOutputs: java.util.List;
        /**  */
        inputs: java.util.List;
        /**  */
        recipe: cn.nukkit.inventory.Recipe;
        /**  */
        craftingType: int;
        /**  */
        primaryOutput: cn.nukkit.item.Item;
        /**  */
        readyToExecute: boolean;
        /**
         * 
         */
        protected callExecuteEvent(): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.transaction.action.SlotChangeAction} a 
         */
        private static lambda$canExecute$4(a: cn.nukkit.inventory.transaction.action.SlotChangeAction): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.transaction.action.SlotChangeAction} a 
         */
        private lambda$canExecute$5(a: cn.nukkit.inventory.transaction.action.SlotChangeAction): void;
        /**
         * 
         */
        public canExecute(): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.transaction.action.InventoryAction} a 
         */
        private static lambda$canExecute$2(a: cn.nukkit.inventory.transaction.action.InventoryAction): cn.nukkit.inventory.transaction.action.SlotChangeAction;
        /**
         * 
         * @param {cn.nukkit.inventory.PlayerUIInventory} uiInventory 
         * @param {cn.nukkit.inventory.transaction.action.SlotChangeAction} a 
         */
        private static lambda$canExecute$3(uiInventory: cn.nukkit.inventory.PlayerUIInventory,a: cn.nukkit.inventory.transaction.action.SlotChangeAction): boolean;
        /**
         * 
         */
        public isReadyToExecute(): boolean;
        /**
         * 
         * @param {java.util.List} actions 
         */
        public checkForCraftingPart(actions: java.util.List): boolean;
        /**
         * 
         */
        protected sendInventories(): void;
        /**
         * 
         */
        public execute(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setInput(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getPrimaryOutput(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setExtraOutput(item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setPrimaryOutput(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getInputList(): java.util.List;
        /**
         * 
         */
        public getRecipe(): cn.nukkit.inventory.Recipe;
        /**
         * 
         * @param {cn.nukkit.inventory.transaction.action.InventoryAction} action 
         */
        private static lambda$canExecute$0(action: cn.nukkit.inventory.transaction.action.InventoryAction): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.transaction.action.InventoryAction} a 
         */
        private static lambda$canExecute$1(a: cn.nukkit.inventory.transaction.action.InventoryAction): boolean;
        /**
         * 
         * @param {boolean} readyToExecute 
         */
        public setReadyToExecute(readyToExecute: boolean): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemMuttonRaw extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.event.level{
     class LevelLoadEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.entity.item{
    abstract class EntityMinecartAbstract extends cn.nukkit.entity.item.EntityVehicle{
        /**  */
        flyingX: double;
        /**  */
        flyingZ: double;
        /**  */
        flyingY: double;
        /**  */
        maxSpeed: double;
        /**  */
        hasUpdated: boolean;
        /**  */
        matrix: int[][][];
        /**  */
        currentSpeed: double;
        /**  */
        blockInside: cn.nukkit.block.Block;
        /**  */
        derailedZ: double;
        /**  */
        devs: boolean;
        /**  */
        slowWhenEmpty: boolean;
        /**  */
        derailedX: double;
        /**  */
        derailedY: double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} flying 
         */
        public setFlyingVelocityMod(flying: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        private applyDrag(): void;
        /**
         * 
         */
        private saveEntityData(): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public applyEntityCollision(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isSlowWhenEmpty(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} update 
         */
        public setDisplayBlock(block: cn.nukkit.block.Block,update: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public setDisplayBlock(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {int} offset 
         */
        public setDisplayBlockOffset(offset: int): void;
        /**
         * 
         * @param {double} speed 
         */
        public setCurrentSpeed(speed: double): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} derailed 
         */
        public setDerailedVelocityMod(derailed: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        public dropItem(): void;
        /**
         * 
         */
        public abstract isRideable(): boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getDisplayBlockOffset(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public canDoInteraction(): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         * @param {int} dx 
         * @param {int} dy 
         * @param {int} dz 
         * @param {cn.nukkit.block.BlockRail} block 
         */
        private processMovement(dx: int,dy: int,dz: int,block: cn.nukkit.block.BlockRail): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public getBaseOffset(): float;
        /**
         * 
         */
        public getFlyingVelocityMod(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        private setFalling(): void;
        /**
         * 
         */
        private prepareDataProperty(): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {double} dx 
         * @param {double} dy 
         * @param {double} dz 
         */
        private getNextRail(dx: double,dy: double,dz: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getDerailedVelocityMod(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {boolean} slow 
         */
        public setSlowWhenEmpty(slow: boolean): void;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public kill(): void;
        /**
         * 
         * @param {cn.nukkit.Player} p 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(p: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {double} speed 
         */
        public setMaximumSpeed(speed: double): void;
        /**
         * 
         */
        public abstract getType(): cn.nukkit.utils.MinecartType;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {boolean} flag 
         */
        protected activate(x: int,y: int,z: int,flag: boolean): void;
        /**
         * 
         */
        public getMaxSpeed(): double;
        /**
         * 
         */
        public getDisplayBlock(): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class MegaTaigaHillsBiome extends cn.nukkit.level.biome.impl.taiga.MegaTaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace com.blocklynukkit.loader.other{
     class BNLogger extends java.lang.Object{
        /**  */
        name: java.lang.String;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         * @param {java.lang.Object[]} meses 
         */
        public  warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object,...meses: java.lang.Object[]): void;
        /**
         * 
         * @param {java.lang.Object} mes 
         */
        public warn(mes: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         */
        public warn(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes 
         */
        public log(mes: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         * @param {java.lang.Object[]} meses 
         */
        public  log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object,...meses: java.lang.Object[]): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         */
        public log(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         * @param {java.lang.Object[]} meses 
         */
        public  warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object,...meses: java.lang.Object[]): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes 
         */
        public warning(mes: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         */
        public warning(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         * @param {java.lang.Object} mes6 
         * @param {java.lang.Object} mes7 
         * @param {java.lang.Object} mes8 
         * @param {java.lang.Object[]} meses 
         */
        public  info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object,mes6: java.lang.Object,mes7: java.lang.Object,mes8: java.lang.Object,...meses: java.lang.Object[]): void;
        /**
         * 
         * @param {java.lang.Object} mes 
         */
        public info(mes: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.Object} mes1 
         * @param {java.lang.Object} mes2 
         * @param {java.lang.Object} mes3 
         * @param {java.lang.Object} mes4 
         * @param {java.lang.Object} mes5 
         */
        public info(mes1: java.lang.Object,mes2: java.lang.Object,mes3: java.lang.Object,mes4: java.lang.Object,mes5: java.lang.Object): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceGateDarkOak extends cn.nukkit.block.BlockFenceGate{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event{
    abstract class EventHandler extends java.lang.Object{
        /**
         * 
         */
        public abstract ignoreCancelled(): boolean;
        /**
         * 
         */
        public abstract priority(): cn.nukkit.event.EventPriority;
    }
}
declare namespace cn.nukkit.block{
     class BlockLeaves extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        OLD_LEAF_PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        PERSISTENT: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        SPRUCE: int;
        /**  */
        BIRCH: int;
        /**  */
        JUNGLE: int;
        /**  */
        VISIT_ORDER: cn.nukkit.math.BlockFace[];
        /**  */
        OAK: int;
        /**  */
        OLD_LEAF_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        UPDATE: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public isPersistent(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isCheckDecay(): boolean;
        /**
         * 
         */
        public diffusesSkyLight(): boolean;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {boolean} checkDecay 
         */
        public setCheckDecay(checkDecay: boolean): void;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         * @param {boolean} persistent 
         */
        public setPersistent(persistent: boolean): void;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        public setType(type: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        protected canDropApple(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} current 
         * @param {int} distance 
         * @param {it.unimi.dsi.fastutil.longs.Long2LongMap} visited 
         */
        private findLog(current: cn.nukkit.block.Block,distance: int,visited: it.unimi.dsi.fastutil.longs.Long2LongMap): java.lang.Boolean;
        /**
         * 
         */
        public getType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getBurnAbility(): int;
        /**
         * 
         */
        protected getSapling(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityVindicator extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockMeta extends cn.nukkit.block.Block{
        /**
         * 
         */
        public abstract getProperties(): cn.nukkit.blockproperty.BlockProperties;
    }
}
declare namespace cn.nukkit.block{
     class BlockSoulSand extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public isSoulSpeedCompatible(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockButtonWooden extends cn.nukkit.block.BlockButton{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemStick extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemBookWritable extends cn.nukkit.item.Item{
        /**
         * 
         * @param {int} pageId 
         */
        public deletePage(pageId: int): boolean;
        /**
         * 
         * @param {int} pageId 
         * @param {java.lang.String} pageText 
         */
        public setPageText(pageId: int,pageText: java.lang.String): boolean;
        /**
         * 
         * @param {int} pageId 
         */
        public pageExists(pageId: int): boolean;
        /**
         * 
         * @param {int} pageId 
         */
        public getPageText(pageId: int): java.lang.String;
        /**
         * 
         * @param {int} pageId1 
         * @param {int} pageId2 
         */
        public swapPages(pageId1: int,pageId2: int): boolean;
        /**
         * 
         * @param {int} pageId 
         */
        public addPage(pageId: int): boolean;
        /**
         * 
         */
        public getPages(): java.util.List;
        /**
         * 
         * @param {int} pageId 
         */
        public insertPage(pageId: int): boolean;
        /**
         * 
         * @param {int} pageId 
         * @param {java.lang.String} pageText 
         */
        public insertPage(pageId: int,pageText: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} pageText 
         */
        protected static createPageTag(pageText: java.lang.String): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        protected static createPageTag(): cn.nukkit.nbt.tag.CompoundTag;
    }
}
declare namespace cn.nukkit.event.plugin{
     class PluginEvent extends cn.nukkit.event.Event{
        /**  */
        plugin: cn.nukkit.plugin.Plugin;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPlugin(): cn.nukkit.plugin.Plugin;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoneycomb extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityBee extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        beehiveTimer: int;
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public isAngry(): boolean;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityBeehive} blockEntityBeehive 
         */
        public nectarDelivered(blockEntityBeehive: cn.nukkit.blockentity.BlockEntityBeehive): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        private static lambda$onUpdate$0(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public setAngry(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {boolean} angry 
         */
        public setAngry(angry: boolean): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        public getHasNectar(): boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {boolean} hasNectar 
         */
        public setHasNectar(hasNectar: boolean): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityBeehive} blockEntityBeehive 
         */
        public leftBeehive(blockEntityBeehive: cn.nukkit.blockentity.BlockEntityBeehive): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemShovelGold extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedCyan extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockBanner extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDirection(): cn.nukkit.math.CompassRoseDirection;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.math.CompassRoseDirection} direction 
         */
        public setDirection(direction: cn.nukkit.math.CompassRoseDirection): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsPurpur extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MobArmorEquipmentPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        slots: cn.nukkit.item.Item[];
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemEnderEye extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.biome{
    abstract class Biome extends java.lang.Object{
        /**  */
        biomes: cn.nukkit.level.biome.Biome[];
        /**  */
        MAX_BIOMES: int;
        /**  */
        populators: java.util.ArrayList;
        /**  */
        heightVariation: float;
        /**  */
        id: int;
        /**  */
        baseHeight: float;
        /**  */
        unorderedBiomes: java.util.List;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.level.generator.populator.type.Populator} populator 
         */
        public addPopulator(populator: cn.nukkit.level.generator.populator.type.Populator): void;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public getPopulators(): java.util.ArrayList;
        /**
         * 
         */
        public getBaseHeight(): float;
        /**
         * 
         */
        public isFreezing(): boolean;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getHeightVariation(): float;
        /**
         * 
         */
        public doesOverhang(): boolean;
        /**
         * 
         * @param {float} baseHeight 
         */
        public setBaseHeight(baseHeight: float): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        public populateChunk(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         * @param {float} heightVariation 
         */
        public setHeightVariation(heightVariation: float): void;
        /**
         * 
         * @param {int} id 
         */
        public setId(id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getHeightOffset(x: int,z: int): int;
        /**
         * 
         */
        public clearPopulators(): void;
        /**
         * 
         */
        public isDry(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getBiome(name: java.lang.String): cn.nukkit.level.biome.Biome;
        /**
         * 
         * @param {int} id 
         */
        public static getBiome(id: int): cn.nukkit.level.biome.Biome;
        /**
         * 
         * @param {int} id 
         * @param {cn.nukkit.level.biome.Biome} biome 
         */
        protected static register(id: int,biome: cn.nukkit.level.biome.Biome): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemBow extends cn.nukkit.item.ItemTool{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getEnchantAbility(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         * @param {cn.nukkit.inventory.BaseInventory} inv 
         */
        private static lambda$onClickAir$0(inv: cn.nukkit.inventory.BaseInventory): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onRelease(player: cn.nukkit.Player,ticksUsed: int): boolean;
    }
}
declare namespace com.blocklynukkit.loader.other.Entities{
     class BNNPC extends com.blocklynukkit.loader.other.ai.entity.MovingEntity{
        /**  */
        callbackfunction: java.lang.String;
        /**  */
        jumphigh: double;
        /**  */
        previousTo: cn.nukkit.math.Vector3;
        /**  */
        routeMax: int;
        /**  */
        dropHand: boolean;
        /**  */
        bnnpc: com.blocklynukkit.loader.other.Entities.BNNPC;
        /**  */
        dropOffhand: boolean;
        /**  */
        speed: double;
        /**  */
        actioinVec: cn.nukkit.math.Vector3;
        /**  */
        enableAttack: boolean;
        /**  */
        enableKnockBack: boolean;
        /**  */
        extraDropItems: java.util.List;
        /**  */
        dvec: cn.nukkit.math.Vector3;
        /**  */
        enableHurt: boolean;
        /**  */
        isjumping: boolean;
        /**  */
        g: double;
        /**  */
        knockBase: double;
        /**  */
        nowtarget: cn.nukkit.math.Vector3;
        /**  */
        justDamaged: boolean;
        /**  */
        enableGravity: boolean;
        /**  */
        calltimetick: int;
        /**  */
        isonRoute: boolean;
        /**  */
        dropSlot: java.util.List;
        /**  */
        actions: int;
        /**  */
        attackfunction: java.lang.String;
        /**
         * 
         * @param {java.util.List} tmp 
         * @param {java.lang.Integer} each 
         */
        private lambda$getDropItems$2(tmp: java.util.List,each: java.lang.Integer): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.network.protocol.EmotePacket} packet 
         * @param {cn.nukkit.Player} e 
         */
        private static lambda$doEmote$5(packet: cn.nukkit.network.protocol.EmotePacket,e: cn.nukkit.Player): void;
        /**
         * 
         */
        public setEnableHurt(): void;
        /**
         * 
         * @param {boolean} hurt 
         */
        public setEnableHurt(hurt: boolean): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} to 
         */
        public directMove(to: cn.nukkit.level.Position): boolean;
        /**
         * 
         */
        public setEnableKnockBack(): void;
        /**
         * 
         * @param {boolean} knock 
         */
        public setEnableKnockBack(knock: boolean): void;
        /**
         * 
         * @param {double} newg 
         */
        public setG(newg: double): void;
        /**
         * 
         */
        public getMovementSpeed(): float;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public setEntityRideOn(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public hit(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.EntityEventPacket} pk 
         * @param {cn.nukkit.Player} player 
         */
        private static lambda$displayHurt$3(pk: cn.nukkit.network.protocol.EntityEventPacket,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.EntityEventPacket} pk 
         * @param {cn.nukkit.Player} player 
         */
        private static lambda$displaySwing$4(pk: cn.nukkit.network.protocol.EntityEventPacket,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public isEntityRideOn(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {double} far 
         */
        public getNearestPlayer(far: double): cn.nukkit.Player;
        /**
         * 
         */
        public getNearestPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public getExtraDropItems(): cn.nukkit.item.Item[];
        /**
         * 
         * @param {double} distance 
         */
        public getPlayersIn(distance: double): java.util.List;
        /**
         * 
         * @param {java.lang.String} callback 
         */
        public setAttackCallback(callback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} callback 
         */
        public setTickCallback(callback: java.lang.String): void;
        /**
         * 
         */
        public getGravity(): float;
        /**
         * 
         */
        public jump(): void;
        /**
         * 
         * @param {int} slot 
         */
        public removeDropSlot(slot: int): void;
        /**
         * 
         */
        public setEnableGravity(): void;
        /**
         * 
         * @param {boolean} gravity 
         */
        public setEnableGravity(gravity: boolean): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} to 
         */
        public findAndMove(to: cn.nukkit.level.Position): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public removeExtraDropItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {double} j 
         */
        public setJumpHigh(j: double): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         */
        public lookAt(pos: cn.nukkit.level.Position): void;
        /**
         * 
         * @param {double} pitch 
         */
        public headUp(pitch: double): void;
        /**
         * 
         * @param {double} s 
         */
        public setSpeed(s: double): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public addExtraDropItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {int} m 
         */
        public setRouteMax(m: int): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public setEntityRideOff(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {double} distance 
         */
        public getEntitiesIn(distance: double): java.util.List;
        /**
         * 
         */
        public stopMove(): void;
        /**
         * 
         */
        public displaySwing(): void;
        /**
         * 
         * @param {boolean} drop 
         */
        public setDropHand(drop: boolean): void;
        /**
         * 
         */
        public setDropHand(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        private lambda$reFresh$6(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getDropItems(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getEyeHeight(): float;
        /**
         * 
         * @param {double} yaw 
         */
        public turnRound(yaw: double): void;
        /**
         * 
         */
        public getRidingPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public reFresh(): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public setEnableAttack(): void;
        /**
         * 
         * @param {boolean} attack 
         */
        public setEnableAttack(attack: boolean): void;
        /**
         * 
         */
        public displayHurt(): void;
        /**
         * 
         * @param {boolean} swim 
         */
        public setSwim(swim: boolean): void;
        /**
         * 
         */
        public setSwim(): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public hasDropItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {double} base 
         */
        public setKnockBase(base: double): void;
        /**
         * 
         */
        public setSneak(): void;
        /**
         * 
         * @param {boolean} sneak 
         */
        public setSneak(sneak: boolean): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public start(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public start(): void;
        /**
         * 
         * @param {int} slot 
         */
        public addDropSlot(slot: int): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} to 
         */
        public canMoveTo(to: cn.nukkit.level.Position): boolean;
        /**
         * 
         * @param {java.util.List} tmp 
         * @param {java.lang.Integer} each 
         */
        private lambda$close$0(tmp: java.util.List,each: java.lang.Integer): void;
        /**
         * 
         * @param {boolean} drop 
         */
        public setDropOffhand(drop: boolean): void;
        /**
         * 
         */
        public setDropOffhand(): void;
        /**
         * 
         */
        public getDropSlots(): int[];
        /**
         * 
         */
        public doEmote(): void;
        /**
         * 
         * @param {java.lang.String} action 
         */
        public doEmote(action: java.lang.String): void;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public isSneak(): boolean;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} each 
         */
        private lambda$close$1(each: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSwordDiamond extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace java.util{
     class Scanner extends java.lang.Object{
        /**  */
        hasNextPattern: java.util.regex.Pattern;
        /**  */
        sourceClosed: boolean;
        /**  */
        lastException: java.io.IOException;
        /**  */
        decimalSeparator: java.lang.String;
        /**  */
        positiveSuffix: java.lang.String;
        /**  */
        FIND_ANY_PATTERN: java.util.regex.Pattern;
        /**  */
        savedScannerPosition: int;
        /**  */
        hasNextPosition: int;
        /**  */
        typeCache: java.lang.Object;
        /**  */
        WHITESPACE_PATTERN: java.util.regex.Pattern;
        /**  */
        source: java.lang.Readable;
        /**  */
        patternCache: sun.misc.LRUCache;
        /**  */
        locale: java.util.Locale;
        /**  */
        positivePrefix: java.lang.String;
        /**  */
        skipped: boolean;
        /**  */
        matchValid: boolean;
        /**  */
        hasNextResult: java.lang.String;
        /**  */
        integerPattern: java.util.regex.Pattern;
        /**  */
        SIMPLE_GROUP_INDEX: int;
        /**  */
        linePattern: java.util.regex.Pattern;
        /**  */
        infinityString: java.lang.String;
        /**  */
        groupSeparator: java.lang.String;
        /**  */
        BUFFER_SIZE: int;
        /**  */
        LINE_PATTERN: java.lang.String;
        /**  */
        needInput: boolean;
        /**  */
        non0Digit: java.lang.String;
        /**  */
        boolPattern: java.util.regex.Pattern;
        /**  */
        decimalPattern: java.util.regex.Pattern;
        /**  */
        $assertionsDisabled: boolean;
        /**  */
        NON_ASCII_DIGIT: java.util.regex.Pattern;
        /**  */
        matcher: java.util.regex.Matcher;
        /**  */
        nanString: java.lang.String;
        /**  */
        radix: int;
        /**  */
        buf: java.nio.CharBuffer;
        /**  */
        negativePrefix: java.lang.String;
        /**  */
        LINE_SEPARATOR_PATTERN: java.lang.String;
        /**  */
        floatPattern: java.util.regex.Pattern;
        /**  */
        separatorPattern: java.util.regex.Pattern;
        /**  */
        closed: boolean;
        /**  */
        digits: java.lang.String;
        /**  */
        position: int;
        /**  */
        delimPattern: java.util.regex.Pattern;
        /**  */
        defaultRadix: int;
        /**  */
        negativeSuffix: java.lang.String;
        /**  */
        BOOLEAN_PATTERN: java.lang.String;
        /**
         * 
         */
        public nextFloat(): float;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private cacheResult(arg0: java.lang.String): void;
        /**
         * 
         */
        private cacheResult(): void;
        /**
         * 
         */
        private hasTokenInBuffer(): boolean;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private static toDecoder(arg0: java.lang.String): java.nio.charset.CharsetDecoder;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        private getCompleteTokenInBuffer(arg0: java.util.regex.Pattern): java.lang.String;
        /**
         * 
         * @param {int} arg0 
         */
        private translateSavedIndexes(arg0: int): void;
        /**
         * 
         */
        private integerPattern(): java.util.regex.Pattern;
        /**
         * 
         */
        public delimiter(): java.util.regex.Pattern;
        /**
         * 
         */
        private static linePattern(): java.util.regex.Pattern;
        /**
         * 
         * @param {int} arg0 
         */
        public nextShort(arg0: int): short;
        /**
         * 
         */
        public nextShort(): short;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public findInLine(arg0: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        public findInLine(arg0: java.util.regex.Pattern): java.lang.String;
        /**
         * 
         */
        private useTypeCache(): void;
        /**
         * 
         */
        public nextBigInteger(): java.math.BigInteger;
        /**
         * 
         * @param {int} arg0 
         */
        public nextBigInteger(arg0: int): java.math.BigInteger;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         * @param {int} arg1 
         */
        private findPatternInBuffer(arg0: java.util.regex.Pattern,arg1: int): java.lang.String;
        /**
         * 
         * @param {int} arg0 
         */
        public hasNextBigInteger(arg0: int): boolean;
        /**
         * 
         */
        public hasNextBigInteger(): boolean;
        /**
         * 
         */
        public nextBigDecimal(): java.math.BigDecimal;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        public hasNext(arg0: java.util.regex.Pattern): boolean;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public hasNext(arg0: java.lang.String): boolean;
        /**
         * 
         */
        public hasNext(): boolean;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public useDelimiter(arg0: java.lang.String): java.util.Scanner;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        public useDelimiter(arg0: java.util.regex.Pattern): java.util.Scanner;
        /**
         * 
         */
        private getCachedResult(): java.lang.String;
        /**
         * 
         */
        public ioException(): java.io.IOException;
        /**
         * 
         */
        private floatPattern(): java.util.regex.Pattern;
        /**
         * 
         */
        private static separatorPattern(): java.util.regex.Pattern;
        /**
         * 
         */
        public reset(): java.util.Scanner;
        /**
         * 
         * @param {int} arg0 
         */
        public hasNextInt(arg0: int): boolean;
        /**
         * 
         */
        public hasNextInt(): boolean;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private static toCharset(arg0: java.lang.String): java.nio.charset.Charset;
        /**
         * 
         */
        public hasNextDouble(): boolean;
        /**
         * 
         */
        private readInput(): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public next(arg0: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        public next(arg0: java.util.regex.Pattern): java.lang.String;
        /**
         * 
         */
        public  next(): java.lang.Object;
        /**
         * 
         */
        public next(): java.lang.String;
        /**
         * 
         */
        private clearCaches(): void;
        /**
         * 
         */
        public hasNextFloat(): boolean;
        /**
         * 
         */
        private saveState(): void;
        /**
         * 
         */
        public nextByte(): byte;
        /**
         * 
         * @param {int} arg0 
         */
        public nextByte(arg0: int): byte;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        private matchPatternInBuffer(arg0: java.util.regex.Pattern): java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public skip(arg0: java.lang.String): java.util.Scanner;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         */
        public skip(arg0: java.util.regex.Pattern): java.util.Scanner;
        /**
         * 
         * @param {java.util.regex.Pattern} arg0 
         * @param {int} arg1 
         */
        public findWithinHorizon(arg0: java.util.regex.Pattern,arg1: int): java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {int} arg1 
         */
        public findWithinHorizon(arg0: java.lang.String,arg1: int): java.lang.String;
        /**
         * 
         */
        public locale(): java.util.Locale;
        /**
         * 
         */
        private buildFloatAndDecimalPattern(): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private processFloatToken(arg0: java.lang.String): java.lang.String;
        /**
         * 
         */
        public remove(): void;
        /**
         * 
         */
        private ensureOpen(): void;
        /**
         * 
         * @param {java.nio.channels.ReadableByteChannel} arg0 
         */
        private static makeReadable(arg0: java.nio.channels.ReadableByteChannel): java.lang.Readable;
        /**
         * 
         * @param {java.nio.channels.ReadableByteChannel} arg0 
         * @param {java.nio.charset.CharsetDecoder} arg1 
         */
        private static makeReadable(arg0: java.nio.channels.ReadableByteChannel,arg1: java.nio.charset.CharsetDecoder): java.lang.Readable;
        /**
         * 
         * @param {java.io.InputStream} arg0 
         * @param {java.nio.charset.Charset} arg1 
         */
        private static makeReadable(arg0: java.io.InputStream,arg1: java.nio.charset.Charset): java.lang.Readable;
        /**
         * 
         */
        public nextBoolean(): boolean;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} arg0 
         */
        private setRadix(arg0: int): void;
        /**
         * 
         * @param {int} arg0 
         */
        public useRadix(arg0: int): java.util.Scanner;
        /**
         * 
         */
        public hasNextBoolean(): boolean;
        /**
         * 
         */
        public nextLine(): java.lang.String;
        /**
         * 
         * @param {int} arg0 
         */
        public hasNextByte(arg0: int): boolean;
        /**
         * 
         */
        public hasNextByte(): boolean;
        /**
         * 
         */
        private static boolPattern(): java.util.regex.Pattern;
        /**
         * 
         */
        private decimalPattern(): java.util.regex.Pattern;
        /**
         * 
         */
        public match(): java.util.regex.MatchResult;
        /**
         * 
         */
        public nextInt(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public nextInt(arg0: int): int;
        /**
         * 
         * @param {int} arg0 
         */
        public nextLong(arg0: int): long;
        /**
         * 
         */
        public nextLong(): long;
        /**
         * 
         */
        public nextDouble(): double;
        /**
         * 
         */
        public hasNextShort(): boolean;
        /**
         * 
         * @param {int} arg0 
         */
        public hasNextShort(arg0: int): boolean;
        /**
         * 
         */
        private throwFor(): void;
        /**
         * 
         */
        public radix(): int;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private processIntegerToken(arg0: java.lang.String): java.lang.String;
        /**
         * 
         */
        public hasNextLine(): boolean;
        /**
         * 
         */
        private makeSpace(): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        private buildIntegerPatternString(): java.lang.String;
        /**
         * 
         */
        public hasNextBigDecimal(): boolean;
        /**
         * 
         * @param {int} arg0 
         */
        public hasNextLong(arg0: int): boolean;
        /**
         * 
         */
        public hasNextLong(): boolean;
        /**
         * 
         * @param {boolean} arg0 
         */
        private revertState(arg0: boolean): boolean;
        /**
         * 
         */
        private revertState(): void;
        /**
         * 
         * @param {java.util.Locale} arg0 
         */
        public useLocale(arg0: java.util.Locale): java.util.Scanner;
    }
}
declare namespace cn.nukkit{
     class Server extends java.lang.Object{
        /**  */
        hasStopped: boolean;
        /**  */
        playerMetadata: cn.nukkit.metadata.PlayerMetadataStore;
        /**  */
        BROADCAST_CHANNEL_ADMINISTRATIVE: java.lang.String;
        /**  */
        instance: cn.nukkit.Server;
        /**  */
        safeSpawn: boolean;
        /**  */
        levelArray: cn.nukkit.level.Level[];
        /**  */
        allowNether: boolean;
        /**  */
        autoSave: boolean;
        /**  */
        maxUse: float;
        /**  */
        autoSaveTicks: int;
        /**  */
        pluginPath: java.lang.String;
        /**  */
        redstoneEnabled: boolean;
        /**  */
        lastLevelGC: int;
        /**  */
        currentThread: java.lang.Thread;
        /**  */
        dispatchSignals: boolean;
        /**  */
        maxPlayers: int;
        /**  */
        players: java.util.Map;
        /**  */
        queryRegenerateEvent: cn.nukkit.event.server.QueryRegenerateEvent;
        /**  */
        tickAverage: float[];
        /**  */
        whitelist: cn.nukkit.utils.Config;
        /**  */
        useAverage: float[];
        /**  */
        commandMap: cn.nukkit.command.SimpleCommandMap;
        /**  */
        serverID: java.util.UUID;
        /**  */
        banByName: cn.nukkit.permission.BanList;
        /**  */
        difficulty: int;
        /**  */
        launchTime: long;
        /**  */
        consoleSender: cn.nukkit.command.ConsoleCommandSender;
        /**  */
        queryHandler: cn.nukkit.network.query.QueryHandler;
        /**  */
        tickCounter: int;
        /**  */
        sendUsageTicker: int;
        /**  */
        banByIP: cn.nukkit.permission.BanList;
        /**  */
        baseLang: cn.nukkit.lang.BaseLang;
        /**  */
        networkCompressionAsync: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        craftingManager: cn.nukkit.inventory.CraftingManager;
        /**  */
        forceLanguage: boolean;
        /**  */
        defaultGamemode: int;
        /**  */
        autoSaveTicker: int;
        /**  */
        autoTickRateLimit: int;
        /**  */
        resourcePackManager: cn.nukkit.resourcepacks.ResourcePackManager;
        /**  */
        ignoredPackets: java.util.Set;
        /**  */
        network: cn.nukkit.network.Network;
        /**  */
        dataPath: java.lang.String;
        /**  */
        scheduler: cn.nukkit.scheduler.ServerScheduler;
        /**  */
        pluginManager: cn.nukkit.plugin.PluginManager;
        /**  */
        operators: cn.nukkit.utils.Config;
        /**  */
        isRunning: java.util.concurrent.atomic.AtomicBoolean;
        /**  */
        networkCompressionLevel: int;
        /**  */
        nextTick: long;
        /**  */
        nameLookup: org.iq80.leveldb.DB;
        /**  */
        networkZlibProvider: int;
        /**  */
        console: cn.nukkit.console.NukkitConsole;
        /**  */
        forceSkinTrusted: boolean;
        /**  */
        rcon: cn.nukkit.network.rcon.RCON;
        /**  */
        positionTrackingService: cn.nukkit.positiontracking.PositionTrackingService;
        /**  */
        filePath: java.lang.String;
        /**  */
        defaultLevel: cn.nukkit.level.Level;
        /**  */
        checkMovement: boolean;
        /**  */
        maxTick: float;
        /**  */
        BROADCAST_CHANNEL_USERS: java.lang.String;
        /**  */
        entityMetadata: cn.nukkit.metadata.EntityMetadataStore;
        /**  */
        alwaysTickPlayers: boolean;
        /**  */
        watchdog: cn.nukkit.utils.Watchdog;
        /**  */
        levelMetadata: cn.nukkit.metadata.LevelMetadataStore;
        /**  */
        getAllowFlight: java.lang.Boolean;
        /**  */
        profilingTickrate: int;
        /**  */
        playerList: java.util.Map;
        /**  */
        autoTickRate: boolean;
        /**  */
        playerDataSerializer: cn.nukkit.utils.PlayerDataSerializer;
        /**  */
        consoleThread: cn.nukkit.Server.ConsoleThread;
        /**  */
        uniquePlayers: java.util.Set;
        /**  */
        baseTickRate: int;
        /**  */
        config: cn.nukkit.utils.Config;
        /**  */
        properties: cn.nukkit.utils.Config;
        /**  */
        levels: java.util.Map;
        /**  */
        serviceManager: cn.nukkit.plugin.service.ServiceManager;
        /**
         * 
         */
        public getTickUsage(): float;
        /**
         * 
         */
        public getOnlinePlayers(): java.util.Map;
        /**
         * 
         * @param {boolean} redstoneEnabled 
         */
        public setRedstoneEnabled(redstoneEnabled: boolean): void;
        /**
         * 
         */
        private registerBlockEntities(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public addOnlinePlayer(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public isForceSkinTrusted(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} p 
         */
        private static lambda$sendFullPlayerListData$3(p: cn.nukkit.Player): cn.nukkit.network.protocol.PlayerListPacket.Entry;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public removePlayer(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {int} x$0 
         */
        private static lambda$sendFullPlayerListData$4(x$0: int): cn.nukkit.network.protocol.PlayerListPacket.Entry[];
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {boolean} forceUnload 
         */
        public unloadLevel(level: cn.nukkit.level.Level,forceUnload: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         */
        public unloadLevel(level: cn.nukkit.level.Level): boolean;
        /**
         * 
         */
        public getServerUniqueId(): java.util.UUID;
        /**
         * 
         */
        public getTickUsageAverage(): float;
        /**
         * 
         */
        public reloadWhitelist(): void;
        /**
         * 
         */
        public getSpawnRadius(): int;
        /**
         * 
         */
        public getLevelMetadata(): cn.nukkit.metadata.LevelMetadataStore;
        /**
         * 
         * @param {cn.nukkit.utils.PlayerDataSerializer} playerDataSerializer 
         */
        public setPlayerDataSerializer(playerDataSerializer: cn.nukkit.utils.PlayerDataSerializer): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public onPlayerLogin(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public sendFullPlayerListData(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {boolean} autoSave 
         */
        public setAutoSave(autoSave: boolean): void;
        /**
         * 
         */
        public getDataPath(): java.lang.String;
        /**
         * 
         */
        public disablePlugins(): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} defaultLevel 
         */
        public setDefaultLevel(defaultLevel: cn.nukkit.level.Level): void;
        /**
         * 
         * @param {cn.nukkit.Server} arg0 
         */
        static access$400(arg0: cn.nukkit.Server): cn.nukkit.console.NukkitConsole;
        /**
         * 
         * @param {cn.nukkit.Server} arg0 
         * @param {cn.nukkit.level.Level[]} arg1 
         */
        static access$002(arg0: cn.nukkit.Server,arg1: cn.nukkit.level.Level[]): cn.nukkit.level.Level[];
        /**
         * 
         */
        public getProperties(): cn.nukkit.utils.Config;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {boolean} value 
         */
        public setPropertyBoolean(variable: java.lang.String,value: boolean): void;
        /**
         * 
         */
        public getDefaultLevel(): cn.nukkit.level.Level;
        /**
         * 
         */
        public getLogger(): cn.nukkit.utils.MainLogger;
        /**
         * 
         * @param {java.net.InetSocketAddress} address 
         * @param {io.netty.buffer.ByteBuf} payload 
         */
        public handlePacket(address: java.net.InetSocketAddress,payload: io.netty.buffer.ByteBuf): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} runEvent 
         * @param {boolean} create 
         */
        private getOfflinePlayerDataInternal(name: java.lang.String,runEvent: boolean,create: boolean): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.Class} clazz 
         */
        public isIgnoredPacket(clazz: java.lang.Class): boolean;
        /**
         * 
         */
        public getIPBans(): cn.nukkit.permission.BanList;
        /**
         * 
         */
        public getPositionTrackingService(): cn.nukkit.positiontracking.PositionTrackingService;
        /**
         * 
         * @param {cn.nukkit.utils.PlayerDataSerializer} serializer 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.lang.String} name 
         * @param {java.util.UUID} uuid 
         */
        private saveOfflinePlayerDataInternal(serializer: cn.nukkit.utils.PlayerDataSerializer,tag: cn.nukkit.nbt.tag.CompoundTag,name: java.lang.String,uuid: java.util.UUID): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public sendRecipeList(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getTicksPerSecond(): float;
        /**
         * 
         */
        public isCheckMovement(): boolean;
        /**
         * 
         */
        public getFilePath(): java.lang.String;
        /**
         * 
         */
        public getPlayerSkinChangeCooldown(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public removeOnlinePlayer(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getCommandAliases(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {int} value 
         */
        public setPropertyInt(variable: java.lang.String,value: int): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         * @param {java.lang.String} permissions 
         */
        public broadcast(message: cn.nukkit.lang.TextContainer,permissions: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.String} permissions 
         */
        public broadcast(message: java.lang.String,permissions: java.lang.String): int;
        /**
         * 
         */
        private convertLegacyPlayerData(): void;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {java.lang.Object} defaultValue 
         */
        public getPropertyBoolean(variable: java.lang.String,defaultValue: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.String} variable 
         */
        public getPropertyBoolean(variable: java.lang.String): boolean;
        /**
         * 
         * @param {int} maxPlayers 
         */
        public setMaxPlayers(maxPlayers: int): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {boolean} create 
         */
        public getOfflinePlayerData(uuid: java.util.UUID,create: boolean): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} create 
         */
        public getOfflinePlayerData(name: java.lang.String,create: boolean): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public getOfflinePlayerData(uuid: java.util.UUID): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getOfflinePlayerData(name: java.lang.String): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getViewDistance(): int;
        /**
         * 
         */
        public getCodename(): java.lang.String;
        /**
         * 
         */
        public getWhitelist(): cn.nukkit.utils.Config;
        /**
         * 
         */
        public getLevels(): java.util.Map;
        /**
         * 
         */
        public isRedstoneEnabled(): boolean;
        /**
         * 
         */
        public getNetwork(): cn.nukkit.network.Network;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {cn.nukkit.Player} player 
         */
        public removePlayerListData(uuid: java.util.UUID,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public removePlayerListData(uuid: java.util.UUID): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {java.util.Collection} players 
         */
        public removePlayerListData(uuid: java.util.UUID,players: java.util.Collection): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {cn.nukkit.Player[]} players 
         */
        public removePlayerListData(uuid: java.util.UUID,players: cn.nukkit.Player[]): void;
        /**
         * 
         */
        public forceShutdown(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public lookupName(name: java.lang.String): java.util.Optional;
        /**
         * 
         */
        public getVersion(): java.lang.String;
        /**
         * 
         */
        public getLanguage(): cn.nukkit.lang.BaseLang;
        /**
         * 
         */
        public hasWhitelist(): boolean;
        /**
         * 
         */
        public isNetherAllowed(): boolean;
        /**
         * 
         */
        public getNameBans(): cn.nukkit.permission.BanList;
        /**
         * 
         * @param {java.lang.String} variable 
         */
        public getPropertyInt(variable: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {java.lang.Integer} defaultValue 
         */
        public getPropertyInt(variable: java.lang.String,defaultValue: java.lang.Integer): int;
        /**
         * 
         * @param {cn.nukkit.Server} arg0 
         */
        static access$100(arg0: cn.nukkit.Server): java.util.Map;
        /**
         * 
         */
        public getNextTick(): long;
        /**
         * 
         */
        public getMaxPlayers(): int;
        /**
         * 
         */
        private registerEntities(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public removeWhitelist(name: java.lang.String): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        private lambda$getOfflinePlayer$5(uuid: java.util.UUID): cn.nukkit.OfflinePlayer;
        /**
         * 
         */
        public getConfig(): cn.nukkit.utils.Config;
        /**
         * 
         * @param {java.lang.String} variable 
         */
        public getConfig(variable: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {java.lang.Object} defaultValue 
         */
        public getConfig(variable: java.lang.String,defaultValue: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {long} entityId 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.entity.data.Skin} skin 
         * @param {java.lang.String} xboxUserId 
         * @param {cn.nukkit.Player[]} players 
         */
        public updatePlayerListData(uuid: java.util.UUID,entityId: long,name: java.lang.String,skin: cn.nukkit.entity.data.Skin,xboxUserId: java.lang.String,players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {long} entityId 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.entity.data.Skin} skin 
         * @param {cn.nukkit.Player[]} players 
         */
        public updatePlayerListData(uuid: java.util.UUID,entityId: long,name: java.lang.String,skin: cn.nukkit.entity.data.Skin,players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {long} entityId 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.entity.data.Skin} skin 
         */
        public updatePlayerListData(uuid: java.util.UUID,entityId: long,name: java.lang.String,skin: cn.nukkit.entity.data.Skin): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {long} entityId 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.entity.data.Skin} skin 
         * @param {java.lang.String} xboxUserId 
         */
        public updatePlayerListData(uuid: java.util.UUID,entityId: long,name: java.lang.String,skin: cn.nukkit.entity.data.Skin,xboxUserId: java.lang.String): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {long} entityId 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.entity.data.Skin} skin 
         * @param {java.lang.String} xboxUserId 
         * @param {java.util.Collection} players 
         */
        public updatePlayerListData(uuid: java.util.UUID,entityId: long,name: java.lang.String,skin: cn.nukkit.entity.data.Skin,xboxUserId: java.lang.String,players: java.util.Collection): void;
        /**
         * 
         */
        public getEntityMetadata(): cn.nukkit.metadata.EntityMetadataStore;
        /**
         * 
         * @param {java.lang.String} partialName 
         */
        public matchPlayer(partialName: java.lang.String): cn.nukkit.Player[];
        /**
         * 
         * @param {int} levelId 
         */
        public getLevel(levelId: int): cn.nukkit.level.Level;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLine 
         */
        public dispatchCommand(sender: cn.nukkit.command.CommandSender,commandLine: java.lang.String): boolean;
        /**
         * 
         */
        public getPort(): int;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         */
        public shouldSavePlayerData(): boolean;
        /**
         * 
         */
        public getAllowFlight(): boolean;
        /**
         * 
         */
        public getGamemode(): int;
        /**
         * 
         */
        public getCraftingManager(): cn.nukkit.inventory.CraftingManager;
        /**
         * 
         */
        public doAutoSave(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getPlayer(name: java.lang.String): cn.nukkit.Player;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public getPlayer(uuid: java.util.UUID): java.util.Optional;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getPluginCommand(name: java.lang.String): cn.nukkit.command.PluginIdentifiableCommand;
        /**
         * 
         * @param {byte[]} data 
         * @param {java.util.List} targets 
         */
        public broadcastPacketsCallback(data: byte[],targets: java.util.List): void;
        /**
         * 
         */
        public getMotd(): java.lang.String;
        /**
         * 
         */
        public getConsoleSender(): cn.nukkit.command.ConsoleCommandSender;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public addWhitelist(name: java.lang.String): void;
        /**
         * 
         * @param {java.net.InetSocketAddress} socketAddress 
         * @param {cn.nukkit.Player} player 
         */
        public addPlayer(socketAddress: java.net.InetSocketAddress,player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getTick(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isOp(name: java.lang.String): boolean;
        /**
         * 
         */
        public getNukkitVersion(): java.lang.String;
        /**
         * 
         */
        public getLevelType(): java.lang.String;
        /**
         * 
         * @param {java.util.regex.Pattern} uuidPattern 
         * @param {java.io.File} file 
         */
        private static lambda$convertLegacyPlayerData$6(uuidPattern: java.util.regex.Pattern,file: java.io.File): boolean;
        /**
         * 
         */
        public getForceGamemode(): boolean;
        /**
         * 
         */
        public getPlayerDataSerializer(): cn.nukkit.utils.PlayerDataSerializer;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public static broadcastPacket(players: cn.nukkit.Player[],packet: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         * @param {java.util.Collection} players 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public static broadcastPacket(players: java.util.Collection,packet: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isLevelGenerated(name: java.lang.String): boolean;
        /**
         * 
         */
        public titleTick(): void;
        /**
         * 
         */
        public getQueryInformation(): cn.nukkit.event.server.QueryRegenerateEvent;
        /**
         * 
         * @param {java.lang.String} variable 
         */
        public getPropertyString(variable: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {java.lang.String} defaultValue 
         */
        public getPropertyString(variable: java.lang.String,defaultValue: java.lang.String): java.lang.String;
        /**
         * 
         */
        private tick(): boolean;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {java.lang.String} name 
         */
         updateName(uuid: java.util.UUID,name: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} str 
         */
        public static getGamemodeFromString(str: java.lang.String): int;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLine 
         */
        private lambda$dispatchCommand$2(sender: cn.nukkit.command.CommandSender,commandLine: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         * @param {cn.nukkit.network.protocol.DataPacket[]} packets 
         * @param {boolean} forceSync 
         */
        public batchPackets(players: cn.nukkit.Player[],packets: cn.nukkit.network.protocol.DataPacket[],forceSync: boolean): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         * @param {cn.nukkit.network.protocol.DataPacket[]} packets 
         */
        public batchPackets(players: cn.nukkit.Player[],packets: cn.nukkit.network.protocol.DataPacket[]): void;
        /**
         * 
         */
        public  isPrimaryThread(): boolean;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public getOfflinePlayer(uuid: java.util.UUID): cn.nukkit.IPlayer;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getOfflinePlayer(name: java.lang.String): cn.nukkit.IPlayer;
        /**
         * 
         * @param {int} mode 
         */
        public static getGamemodeString(mode: int): java.lang.String;
        /**
         * 
         * @param {int} mode 
         * @param {boolean} direct 
         */
        public static getGamemodeString(mode: int,direct: boolean): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         * @param {long} tickTime 
         */
        private checkTickUpdates(currentTick: int,tickTime: long): void;
        /**
         * 
         */
        public getGitCommit(): java.lang.String;
        /**
         * 
         */
        public shutdown(): void;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {java.lang.String} value 
         */
        public setPropertyString(variable: java.lang.String,value: java.lang.String): void;
        /**
         * 
         */
        public getPluginPath(): java.lang.String;
        /**
         * 
         */
        public getLaunchTime(): long;
        /**
         * 
         */
        public getIp(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public onPlayerCompleteLoginSequence(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public isSafeSpawn(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getLevelByName(name: java.lang.String): cn.nukkit.level.Level;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isWhitelisted(name: java.lang.String): boolean;
        /**
         * 
         */
        public getPluginManager(): cn.nukkit.plugin.PluginManager;
        /**
         * 
         */
        public getDefaultGamemode(): int;
        /**
         * 
         */
        public reload(): void;
        /**
         * 
         */
        public isRunning(): boolean;
        /**
         * 
         */
        public getSubMotd(): java.lang.String;
        /**
         * 
         */
        public getAutoSave(): boolean;
        /**
         * 
         */
        public getApiVersion(): java.lang.String;
        /**
         * 
         */
        public getPrimaryThread(): java.lang.Thread;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {boolean} async 
         * @param {boolean} runEvent 
         */
        private saveOfflinePlayerData(name: java.lang.String,tag: cn.nukkit.nbt.tag.CompoundTag,async: boolean,runEvent: boolean): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {boolean} async 
         */
        public saveOfflinePlayerData(name: java.lang.String,tag: cn.nukkit.nbt.tag.CompoundTag,async: boolean): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public saveOfflinePlayerData(name: java.lang.String,tag: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public saveOfflinePlayerData(uuid: java.util.UUID,tag: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {boolean} async 
         */
        public saveOfflinePlayerData(uuid: java.util.UUID,tag: cn.nukkit.nbt.tag.CompoundTag,async: boolean): void;
        /**
         * 
         */
        public getScheduler(): cn.nukkit.scheduler.ServerScheduler;
        /**
         * 
         * @param {java.lang.String} line 
         */
        private static lambda$new$0(line: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} variable 
         */
        public getProperty(variable: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} variable 
         * @param {java.lang.Object} defaultValue 
         */
        public getProperty(variable: java.lang.String,defaultValue: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} str 
         */
        public static getDifficultyFromString(str: java.lang.String): int;
        /**
         * 
         * @param {cn.nukkit.Server} arg0 
         * @param {cn.nukkit.utils.PlayerDataSerializer} arg1 
         * @param {cn.nukkit.nbt.tag.CompoundTag} arg2 
         * @param {java.lang.String} arg3 
         * @param {java.util.UUID} arg4 
         */
        static access$300(arg0: cn.nukkit.Server,arg1: cn.nukkit.utils.PlayerDataSerializer,arg2: cn.nukkit.nbt.tag.CompoundTag,arg3: java.lang.String,arg4: java.util.UUID): void;
        /**
         * 
         */
        public getGenerateStructures(): boolean;
        /**
         * 
         */
        public tickProcessor(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public addOp(name: java.lang.String): void;
        /**
         * 
         */
        public start(): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         * @param {java.util.Collection} recipients 
         */
        public broadcastMessage(message: cn.nukkit.lang.TextContainer,recipients: java.util.Collection): int;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         */
        public broadcastMessage(message: cn.nukkit.lang.TextContainer): int;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.util.Collection} recipients 
         */
        public broadcastMessage(message: java.lang.String,recipients: java.util.Collection): int;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {cn.nukkit.command.CommandSender[]} recipients 
         */
        public broadcastMessage(message: java.lang.String,recipients: cn.nukkit.command.CommandSender[]): int;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public broadcastMessage(message: java.lang.String): int;
        /**
         * 
         */
        public getResourcePackManager(): cn.nukkit.resourcepacks.ResourcePackManager;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public removeOp(name: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {long} seed 
         * @param {java.lang.Class} generator 
         */
        public generateLevel(name: java.lang.String,seed: long,generator: java.lang.Class): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {long} seed 
         * @param {java.lang.Class} generator 
         * @param {java.util.Map} options 
         */
        public generateLevel(name: java.lang.String,seed: long,generator: java.lang.Class,options: java.util.Map): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {long} seed 
         */
        public generateLevel(name: java.lang.String,seed: long): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public generateLevel(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {long} seed 
         * @param {java.lang.Class} generator 
         * @param {java.util.Map} options 
         * @param {java.lang.Class} provider 
         */
        public generateLevel(name: java.lang.String,seed: long,generator: java.lang.Class,options: java.util.Map,provider: java.lang.Class): boolean;
        /**
         * 
         */
        public getPlayerMetadata(): cn.nukkit.metadata.PlayerMetadataStore;
        /**
         * 
         */
        public getServiceManager(): cn.nukkit.plugin.service.ServiceManager;
        /**
         * 
         */
        public isHardcore(): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.Recipe} recipe 
         */
        public addRecipe(recipe: cn.nukkit.inventory.Recipe): void;
        /**
         * 
         */
        public getTicksPerSecondAverage(): float;
        /**
         * 
         */
        public getOps(): cn.nukkit.utils.Config;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getPlayerExact(name: java.lang.String): cn.nukkit.Player;
        /**
         * 
         */
        public isLanguageForced(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isLevelLoaded(name: java.lang.String): boolean;
        /**
         * 
         */
        public getCommandMap(): cn.nukkit.command.SimpleCommandMap;
        /**
         * 
         */
        public static getInstance(): cn.nukkit.Server;
        /**
         * 
         */
        public getForceResources(): boolean;
        /**
         * 
         */
        public getDifficulty(): int;
        /**
         * 
         * @param {cn.nukkit.plugin.PluginLoadOrder} type 
         */
        public enablePlugins(type: cn.nukkit.plugin.PluginLoadOrder): void;
        /**
         * 
         * @param {java.lang.String} line 
         */
        private static lambda$new$1(line: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public loadLevel(name: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityFallingBlock extends cn.nukkit.entity.Entity{
        /**  */
        blockId: int;
        /**  */
        breakOnLava: boolean;
        /**  */
        damage: int;
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getDamage(): int;
        /**
         * 
         */
        public getBlock(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public canBeMovedByCurrents(): boolean;
        /**
         * 
         */
        public canCollide(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
        /**
         * 
         */
        protected getBaseOffset(): float;
    }
}
declare namespace cn.nukkit.level{
     class Location extends cn.nukkit.level.Position{
        /**  */
        pitch: double;
        /**  */
        yaw: double;
        /**
         * 
         * @param {double} x 
         */
        public add(x: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public add(x: double,y: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public  add(x: double,y: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         */
        public  add(x: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public add(x: double,y: double,z: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  add(x: double,y: double,z: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public  add(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  add(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public  add(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         */
        public  add(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public  add(x: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         */
        public getLocation(): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Level} level 
         */
        public static fromObject(pos: cn.nukkit.math.Vector3,level: cn.nukkit.level.Level): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Level} level 
         * @param {double} yaw 
         * @param {double} pitch 
         */
        public static fromObject(pos: cn.nukkit.math.Vector3,level: cn.nukkit.level.Level,yaw: double,pitch: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Level} level 
         * @param {double} yaw 
         */
        public static fromObject(pos: cn.nukkit.math.Vector3,level: cn.nukkit.level.Level,yaw: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public static fromObject(pos: cn.nukkit.math.Vector3): cn.nukkit.level.Location;
        /**
         * 
         */
        public  subtract(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  subtract(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public  subtract(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public  subtract(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         */
        public  subtract(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         */
        public  subtract(x: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public  subtract(x: double,y: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  subtract(x: double,y: double,z: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public subtract(x: double,y: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public subtract(x: double,y: double,z: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public  subtract(x: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         */
        public subtract(): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} x 
         */
        public subtract(x: double): cn.nukkit.level.Location;
        /**
         * 
         */
        public  subtract(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  ceil(): cn.nukkit.level.Position;
        /**
         * 
         */
        public ceil(): cn.nukkit.level.Location;
        /**
         * 
         */
        public  ceil(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} yaw 
         */
        public setYaw(yaw: double): cn.nukkit.level.Location;
        /**
         * 
         */
        public getYaw(): double;
        /**
         * 
         */
        public  abs(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  abs(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public abs(): cn.nukkit.level.Location;
        /**
         * 
         */
        public getPitch(): double;
        /**
         * 
         */
        public round(): cn.nukkit.level.Location;
        /**
         * 
         */
        public  round(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  round(): cn.nukkit.level.Position;
        /**
         * 
         */
        public clone(): cn.nukkit.level.Location;
        /**
         * 
         */
        public  clone(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  clone(): cn.nukkit.positiontracking.NamedPosition;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         * @param {double} pitch 
         */
        public setPitch(pitch: double): cn.nukkit.level.Location;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {double} number 
         */
        public divide(number: double): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} number 
         */
        public  divide(number: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} number 
         */
        public  divide(number: double): cn.nukkit.level.Position;
        /**
         * 
         */
        public getDirectionVector(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  floor(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  floor(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public floor(): cn.nukkit.level.Location;
        /**
         * 
         * @param {double} number 
         */
        public  multiply(number: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} number 
         */
        public  multiply(number: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} number 
         */
        public multiply(number: double): cn.nukkit.level.Location;
    }
}
declare namespace cn.nukkit.block{
     class BlockCoal extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsSpruce extends cn.nukkit.block.BlockStairsWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoeGold extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class CriticalParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.utils{
    abstract class Faceable extends java.lang.Object{
        /**
         * 
         */
        public abstract getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemClay extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.timings{
     class LevelTimings extends java.lang.Object{
        /**  */
        doTick: co.aikar.timings.Timing;
        /**  */
        syncChunkLoadTimer: co.aikar.timings.Timing;
        /**  */
        doChunkGC: co.aikar.timings.Timing;
        /**  */
        tickChunks: co.aikar.timings.Timing;
        /**  */
        doTickPending: co.aikar.timings.Timing;
        /**  */
        syncChunkSendPrepareTimer: co.aikar.timings.Timing;
        /**  */
        syncChunkLoadDataTimer: co.aikar.timings.Timing;
        /**  */
        doChunkUnload: co.aikar.timings.Timing;
        /**  */
        syncChunkSendTimer: co.aikar.timings.Timing;
        /**  */
        entityTick: co.aikar.timings.Timing;
        /**  */
        blockEntityTick: co.aikar.timings.Timing;
        /**  */
        syncChunkLoadBlockEntitiesTimer: co.aikar.timings.Timing;
        /**  */
        syncChunkLoadEntitiesTimer: co.aikar.timings.Timing;
    }
}
declare namespace cn.nukkit.utils{
    abstract class IterableThreadLocal extends java.lang.ThreadLocal{
        /**  */
        flag: java.lang.ThreadLocal;
        /**  */
        allValues: java.util.concurrent.ConcurrentLinkedDeque;
        /**
         * 
         */
        public static cleanAll(): void;
        /**
         * 
         */
        public init(): java.lang.Object;
        /**
         * 
         */
        public  iterator(): java.util.Iterator;
        /**
         * 
         */
        public  getAll(): java.util.Collection;
        /**
         * 
         */
        protected finalize(): void;
        /**
         * 
         * @param {java.lang.ThreadLocal} instance 
         */
        public static clean(instance: java.lang.ThreadLocal): void;
        /**
         * 
         */
        public clean(): void;
        /**
         * 
         */
        protected  initialValue(): java.lang.Object;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorAcacia extends cn.nukkit.block.BlockDoorWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockUpdateEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.inventory{
    abstract class BaseInventory extends java.lang.Object{
        /**  */
        maxStackSize: int;
        /**  */
        slots: java.util.Map;
        /**  */
        viewers: java.util.Set;
        /**  */
        size: int;
        /**  */
        listeners: java.util.List;
        /**  */
        name: java.lang.String;
        /**  */
        holder: cn.nukkit.inventory.InventoryHolder;
        /**  */
        type: cn.nukkit.inventory.InventoryType;
        /**  */
        title: java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} slots 
         */
        public  removeItem(...slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} maxStackSize 
         */
        public setMaxStackSize(maxStackSize: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public firstEmpty(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {int} index 
         */
        public getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getViewers(): java.util.Set;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public remove(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public clearAll(): void;
        /**
         * 
         * @param {cn.nukkit.Player} p 
         */
        private static lambda$onSlotChange$0(p: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} slots 
         */
        public  addItem(...slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} size 
         */
        public setSize(size: int): void;
        /**
         * 
         */
        public getTitle(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public onOpen(who: cn.nukkit.Player): void;
        /**
         * 
         */
        public getContents(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public sendContents(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public  sendContents(...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {java.util.Collection} players 
         */
        public sendContents(players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public close(who: cn.nukkit.Player): void;
        /**
         * 
         * @param {java.util.Map} items 
         */
        public setContents(items: java.util.Map): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} send 
         */
        public setItem(index: int,item: cn.nukkit.item.Item,send: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.InventoryListener} listener 
         */
        public addListener(listener: cn.nukkit.inventory.InventoryListener): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public all(item: cn.nukkit.item.Item): java.util.Map;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} before 
         * @param {boolean} send 
         */
        public onSlotChange(index: int,before: cn.nukkit.item.Item,send: boolean): void;
        /**
         * 
         * @param {int} index 
         * @param {boolean} send 
         */
        public clear(index: int,send: boolean): boolean;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getFreeSpace(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {cn.nukkit.inventory.InventoryListener} listener 
         */
        public removeListener(listener: cn.nukkit.inventory.InventoryListener): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public contains(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public onClose(who: cn.nukkit.Player): void;
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.InventoryType;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canAddItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {int} slot 
         */
        public decreaseCount(slot: int): void;
        /**
         * 
         */
        public isFull(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.Player} player 
         */
        public sendSlot(index: int,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {int} index 
         * @param {java.util.Collection} players 
         */
        public sendSlot(index: int,players: java.util.Collection): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.Player[]} players 
         */
        public  sendSlot(index: int,...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} exact 
         */
        public first(item: cn.nukkit.item.Item,exact: boolean): int;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public open(who: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getHolder(): cn.nukkit.inventory.InventoryHolder;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityCauldron extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        POTION_TYPE_LAVA: int;
        /**  */
        POTION_TYPE_EMPTY: int;
        /**  */
        POTION_TYPE_NORMAL: int;
        /**  */
        POTION_TYPE_LINGERING: int;
        /**  */
        POTION_TYPE_SPLASH: int;
        /**
         * 
         */
        public clearCustomColor(): void;
        /**
         * 
         */
        public spawnToAll(): void;
        /**
         * 
         * @param {int} potionType 
         */
        public setPotionType(potionType: int): void;
        /**
         * 
         */
        public getPotionType(): int;
        /**
         * 
         * @param {int} potionId 
         */
        public setPotionId(potionId: int): void;
        /**
         * 
         */
        public getCustomColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         * @param {int} r 
         * @param {int} g 
         * @param {int} b 
         */
        public setCustomColor(r: int,g: int,b: int): void;
        /**
         * 
         * @param {cn.nukkit.utils.BlockColor} color 
         */
        public setCustomColor(color: cn.nukkit.utils.BlockColor): void;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityCauldron.PotionType} type 
         */
        public setType(type: cn.nukkit.blockentity.BlockEntityCauldron.PotionType): void;
        /**
         * 
         */
        public hasPotion(): boolean;
        /**
         * 
         */
        public isSplashPotion(): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Location} location 
         * @param {cn.nukkit.Player[]} viewers 
         */
        private lambda$spawnToAll$0(location: cn.nukkit.level.Location,viewers: cn.nukkit.Player[]): void;
        /**
         * 
         */
        public getType(): cn.nukkit.blockentity.BlockEntityCauldron.PotionType;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {boolean} value 
         */
        public setSplashPotion(value: boolean): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public getPotionId(): int;
        /**
         * 
         */
        public isCustomColor(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsBrick extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.generator.task{
     class LightPopulationTask extends cn.nukkit.scheduler.AsyncTask{
        /**  */
        levelId: int;
        /**  */
        chunk: cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {cn.nukkit.Server} server 
         */
        public onCompletion(server: cn.nukkit.Server): void;
        /**
         * 
         */
        public onRun(): void;
    }
}
declare namespace cn.nukkit.level.generator.task{
     class GenerationTask extends cn.nukkit.scheduler.AsyncTask{
        /**  */
        level: cn.nukkit.level.Level;
        /**  */
        chunk: cn.nukkit.level.format.generic.BaseFullChunk;
        /**  */
        state: boolean;
        /**
         * 
         * @param {cn.nukkit.Server} server 
         */
        public onCompletion(server: cn.nukkit.Server): void;
        /**
         * 
         */
        public onRun(): void;
    }
}
declare namespace cn.nukkit.metadata{
     class PlayerMetadataStore extends cn.nukkit.metadata.MetadataStore{
        /**
         * 
         * @param {cn.nukkit.metadata.Metadatable} player 
         * @param {java.lang.String} metadataKey 
         */
        protected disambiguate(player: cn.nukkit.metadata.Metadatable,metadataKey: java.lang.String): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class CompletedUsingItemPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        ACTION_UNKNOWN: int;
        /**  */
        ACTION_CONSUME: int;
        /**  */
        ACTION_PLACE: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        ACTION_FILL_BUCKET: int;
        /**  */
        ACTION_DYED: int;
        /**  */
        ACTION_TRADED: int;
        /**  */
        ACTION_RETRIEVE: int;
        /**  */
        ACTION_ATTACK: int;
        /**  */
        ACTION_POUR_BUCKET: int;
        /**  */
        ACTION_THROW: int;
        /**  */
        ACTION_EAT: int;
        /**  */
        itemId: int;
        /**  */
        ACTION_SHOOT: int;
        /**  */
        ACTION_USE_TOOL: int;
        /**  */
        ACTION_FILL_BOTTLE: int;
        /**  */
        ACTION_EQUIP_ARMOR: int;
        /**  */
        ACTION_INTERACT: int;
        /**  */
        action: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreGold extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.plugin{
    abstract class PluginLoader extends java.lang.Object{
        /**
         * 
         */
        public abstract getPluginFilters(): java.util.regex.Pattern[];
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public abstract enablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public abstract disablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public abstract getPluginDescription(filename: java.lang.String): cn.nukkit.plugin.PluginDescription;
        /**
         * 
         * @param {java.io.File} file 
         */
        public abstract getPluginDescription(file: java.io.File): cn.nukkit.plugin.PluginDescription;
        /**
         * 
         * @param {java.io.File} file 
         */
        public abstract loadPlugin(file: java.io.File): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public abstract loadPlugin(filename: java.lang.String): cn.nukkit.plugin.Plugin;
    }
}
declare namespace cn.nukkit.level{
     class GameRule extends java.lang.Enum{
        /**  */
        COMMAND_BLOCK_OUTPUT: cn.nukkit.level.GameRule;
        /**  */
        MOB_GRIEFING: cn.nukkit.level.GameRule;
        /**  */
        RANDOM_TICK_SPEED: cn.nukkit.level.GameRule;
        /**  */
        EMPTY_ARRAY: cn.nukkit.level.GameRule[];
        /**  */
        DO_IMMEDIATE_RESPAWN: cn.nukkit.level.GameRule;
        /**  */
        DO_MOB_SPAWNING: cn.nukkit.level.GameRule;
        /**  */
        deprecated: boolean;
        /**  */
        DO_MOB_LOOT: cn.nukkit.level.GameRule;
        /**  */
        COMMAND_BLOCKS_ENABLED: cn.nukkit.level.GameRule;
        /**  */
        FREEZE_DAMAGE: cn.nukkit.level.GameRule;
        /**  */
        PVP: cn.nukkit.level.GameRule;
        /**  */
        KEEP_INVENTORY: cn.nukkit.level.GameRule;
        /**  */
        FIRE_DAMAGE: cn.nukkit.level.GameRule;
        /**  */
        SPAWN_RADIUS: cn.nukkit.level.GameRule;
        /**  */
        DO_DAYLIGHT_CYCLE: cn.nukkit.level.GameRule;
        /**  */
        TNT_EXPLODES: cn.nukkit.level.GameRule;
        /**  */
        SHOW_COORDINATES: cn.nukkit.level.GameRule;
        /**  */
        DROWNING_DAMAGE: cn.nukkit.level.GameRule;
        /**  */
        DO_WEATHER_CYCLE: cn.nukkit.level.GameRule;
        /**  */
        DO_FIRE_TICK: cn.nukkit.level.GameRule;
        /**  */
        $VALUES: cn.nukkit.level.GameRule[];
        /**  */
        DO_INSOMNIA: cn.nukkit.level.GameRule;
        /**  */
        DO_TILE_DROPS: cn.nukkit.level.GameRule;
        /**  */
        SEND_COMMAND_FEEDBACK: cn.nukkit.level.GameRule;
        /**  */
        DO_ENTITY_DROPS: cn.nukkit.level.GameRule;
        /**  */
        FUNCTION_COMMAND_LIMIT: cn.nukkit.level.GameRule;
        /**  */
        NATURAL_REGENERATION: cn.nukkit.level.GameRule;
        /**  */
        SHOW_DEATH_MESSAGES: cn.nukkit.level.GameRule;
        /**  */
        SHOW_DEATH_MESSAGE: cn.nukkit.level.GameRule;
        /**  */
        EXPERIMENTAL_GAMEPLAY: cn.nukkit.level.GameRule;
        /**  */
        SHOW_TAGS: cn.nukkit.level.GameRule;
        /**  */
        MAX_COMMAND_CHAIN_LENGTH: cn.nukkit.level.GameRule;
        /**  */
        name: java.lang.String;
        /**  */
        FALL_DAMAGE: cn.nukkit.level.GameRule;
        /**
         * 
         */
        public isDeprecated(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.level.GameRule;
        /**
         * 
         * @param {java.lang.String} gameRuleString 
         */
        public static parseString(gameRuleString: java.lang.String): java.util.Optional;
        /**
         * 
         */
        public static values(): cn.nukkit.level.GameRule[];
        /**
         * 
         */
        public static getNames(): java.lang.String[];
    }
}
declare namespace cn.nukkit.event.block{
     class BlockPistonChangeEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        newPower: int;
        /**  */
        oldPower: int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewPower(): int;
        /**
         * 
         */
        public getOldPower(): int;
    }
}
declare namespace cn.nukkit.level.generator{
    abstract class SimpleChunkManager extends java.lang.Object{
        /**  */
        seed: long;
        /**
         * 
         */
        public getSeed(): long;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockDataAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockDataAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public setChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockIdAt(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public setBlockIdAt(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public setBlockAt(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockIdAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockIdAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockStateAt(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public setBlockFullIdAt(x: int,y: int,z: int,layer: int,fullId: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public setBlockFullIdAt(x: int,y: int,z: int,fullId: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockStateAt(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         * @param {int} data 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,id: int,data: int): boolean;
        /**
         * 
         * @param {long} seed 
         */
        public setSeed(seed: long): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockDataAt(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public setBlockDataAt(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {long} seed 
         */
        public cleanChunks(seed: long): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockChorusPlant extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        private isPositionValid(): boolean;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityFox extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockSnowLayer extends cn.nukkit.block.BlockFallableMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        SNOW_HEIGHT: cn.nukkit.blockproperty.IntBlockProperty;
        /**  */
        COVERED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} e 
         */
        private static lambda$place$2(e: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {boolean} covered 
         */
        public setCovered(covered: boolean): void;
        /**
         * 
         * @param {cn.nukkit.block.BlockSnowLayer} b 
         */
        private static lambda$place$1(b: cn.nukkit.block.BlockSnowLayer): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} b 
         */
        private static lambda$place$0(b: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {int} layers 
         */
        public melt(layers: int): boolean;
        /**
         * 
         */
        public melt(): boolean;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} snowHeight 
         */
        public setSnowHeight(snowHeight: int): void;
        /**
         * 
         */
        public isCovered(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getSnowHeight(): int;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.block.Block} newBlock 
         * @param {boolean} update 
         */
        public afterRemoval(newBlock: cn.nukkit.block.Block,update: boolean): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         */
        private lambda$afterRemoval$3(level: cn.nukkit.level.Level): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentFrostWalker extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        protected checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemCake extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.particle{
     class HugeExplodeSeedParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemColorArmor extends cn.nukkit.item.ItemArmor{
        /**
         * 
         * @param {cn.nukkit.utils.BlockColor} color 
         */
        public setColor(color: cn.nukkit.utils.BlockColor): cn.nukkit.item.ItemColorArmor;
        /**
         * 
         * @param {int} r 
         * @param {int} g 
         * @param {int} b 
         */
        public setColor(r: int,g: int,b: int): cn.nukkit.item.ItemColorArmor;
        /**
         * 
         * @param {cn.nukkit.utils.DyeColor} dyeColor 
         */
        public setColor(dyeColor: cn.nukkit.utils.DyeColor): cn.nukkit.item.ItemColorArmor;
        /**
         * 
         * @param {int} dyeColor 
         */
        public setColor(dyeColor: int): cn.nukkit.item.ItemColorArmor;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
    }
}
declare namespace cn.nukkit.event.block{
     class SignChangeEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        lines: java.lang.String[];
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {int} index 
         */
        public getLine(index: int): java.lang.String;
        /**
         * 
         */
        public getLines(): java.lang.String[];
        /**
         * 
         * @param {int} index 
         * @param {java.lang.String} line 
         */
        public setLine(index: int,line: java.lang.String): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.jungle{
     class JungleEdgeMBiome extends cn.nukkit.level.biome.impl.jungle.JungleEdgeBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerMoveEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        from: cn.nukkit.level.Location;
        /**  */
        resetBlocksAround: boolean;
        /**  */
        to: cn.nukkit.level.Location;
        /**
         * 
         * @param {boolean} value 
         */
        public setResetBlocksAround(value: boolean): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.level.Location} from 
         */
        public setFrom(from: cn.nukkit.level.Location): void;
        /**
         * 
         */
        public setCancelled(): void;
        /**
         * 
         * @param {cn.nukkit.level.Location} to 
         */
        public setTo(to: cn.nukkit.level.Location): void;
        /**
         * 
         */
        public getTo(): cn.nukkit.level.Location;
        /**
         * 
         */
        public getFrom(): cn.nukkit.level.Location;
        /**
         * 
         */
        public isResetBlocksAround(): boolean;
    }
}
declare namespace cn.nukkit.inventory{
    abstract class InventoryHolder extends java.lang.Object{
        /**
         * 
         */
        public abstract getInventory(): cn.nukkit.inventory.Inventory;
    }
}
declare namespace cn.nukkit.item{
     class ItemAxeWood extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityExplodeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        blocks: java.util.List;
        /**  */
        yield: double;
        /**  */
        position: cn.nukkit.level.Position;
        /**  */
        ignitions: java.util.Set;
        /**
         * 
         */
        public getPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getIgnitions(): java.util.Set;
        /**
         * 
         * @param {java.util.List} blocks 
         */
        public setBlockList(blocks: java.util.List): void;
        /**
         * 
         * @param {double} yield 
         */
        public setYield(yield: double): void;
        /**
         * 
         * @param {java.util.Set} ignitions 
         */
        public setIgnitions(ignitions: java.util.Set): void;
        /**
         * 
         */
        public getBlockList(): java.util.List;
        /**
         * 
         */
        public getYield(): double;
    }
}
declare namespace cn.nukkit.nbt.tag{
    abstract class Tag extends java.lang.Object{
        /**  */
        TAG_Int: byte;
        /**  */
        TAG_String: byte;
        /**  */
        TAG_Int_Array: byte;
        /**  */
        TAG_Short: byte;
        /**  */
        TAG_Double: byte;
        /**  */
        TAG_Compound: byte;
        /**  */
        TAG_Float: byte;
        /**  */
        TAG_Byte: byte;
        /**  */
        name: java.lang.String;
        /**  */
        TAG_End: byte;
        /**  */
        TAG_List: byte;
        /**  */
        TAG_Byte_Array: byte;
        /**  */
        TAG_Long: byte;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {byte} type 
         * @param {java.lang.String} name 
         */
        public static newTag(type: byte,name: java.lang.String): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public abstract getId(): byte;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
        public static readNamedTag(dis: cn.nukkit.nbt.stream.NBTInputStream): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
        public static writeNamedTag(tag: cn.nukkit.nbt.tag.Tag,name: java.lang.String,dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
        public static writeNamedTag(tag: cn.nukkit.nbt.tag.Tag,dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         * @param {java.lang.String} prefix 
         * @param {java.io.PrintStream} out 
         */
        public print(prefix: java.lang.String,out: java.io.PrintStream): void;
        /**
         * 
         * @param {java.io.PrintStream} out 
         */
        public print(out: java.io.PrintStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
        abstract load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         * @param {byte} type 
         */
        public static getTagName(type: byte): java.lang.String;
        /**
         * 
         */
        public abstract toString(): java.lang.String;
        /**
         * 
         */
        public abstract copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public abstract parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
        abstract write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.iceplains{
     class IcePlainsSpikesBiome extends cn.nukkit.level.biome.impl.iceplains.IcePlainsBiome{
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public isFreezing(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemHorseArmorIron extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemPotionSplash extends cn.nukkit.item.ProjectileItem{
        /**
         * 
         */
        public getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getThrowForce(): float;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         */
        protected correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityPolarBear extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemSpawnEgg extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getLegacySpawnEgg(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public getEntityNetworkId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class RiderJumpPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        unknown: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemFishingRod extends cn.nukkit.item.ItemTool{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getEnchantAbility(): int;
        /**
         * 
         */
        public damageWhenBreaking(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityGuardian extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorDeadBush extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockBricks extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.format.anvil{
     class ChunkSection extends java.lang.Object{
        /**  */
        compressedLight: byte[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        skyLight: byte[];
        /**  */
        SAVE_STORAGE_VERSION: int;
        /**  */
        STREAM_STORAGE_VERSION: int;
        /**  */
        layerStorage: cn.nukkit.level.format.anvil.LayerStorage;
        /**  */
        hasBlockLight: boolean;
        /**  */
        BYTE_MASK: java.math.BigInteger;
        /**  */
        HUGE_TAG_NAME: java.lang.String;
        /**  */
        blockLight: byte[];
        /**  */
        y: int;
        /**  */
        contentVersion: int;
        /**  */
        hasSkyLight: boolean;
        /**  */
        STORAGE_TAG_NAME: java.lang.String;
        /**
         * 
         * @param {int} index 
         * @param {int} blockId 
         * @param {int} composedData 
         * @param {cn.nukkit.nbt.tag.ListTag} hugeDataList 
         * @param {int} hugeDataSize 
         */
        private static loadHugeBigData(index: int,blockId: int,composedData: int,hugeDataList: cn.nukkit.nbt.tag.ListTag,hugeDataSize: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockData(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlock(x: int,y: int,z: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         */
        public setBlock(x: int,y: int,z: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public setBlockLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public  setBlockStateAtLayer(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} index 
         * @param {int} blockId 
         * @param {int} composedData 
         * @param {cn.nukkit.nbt.tag.ListTag} hugeDataList 
         * @param {int} hugeDataSize 
         */
        private static loadHugeLongData(index: int,blockId: int,composedData: int,hugeDataList: cn.nukkit.nbt.tag.ListTag,hugeDataSize: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,fullId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public  setFullBlockId(x: int,y: int,z: int,layer: int,fullId: int): boolean;
        /**
         * 
         * @param {int} contentVersion 
         */
        public setContentVersion(contentVersion: int): void;
        /**
         * 
         */
        public hasBlocks(): boolean;
        /**
         * 
         */
        public  compressStorageLayers(): void;
        /**
         * 
         */
        public  toNBT(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getFullBlock(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.format.anvil.LayerStorage} storage 
         */
        private setLayerStorage(storage: cn.nukkit.level.format.anvil.LayerStorage): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {int} version 
         */
        private static getStorageTagList(nbt: cn.nukkit.nbt.tag.CompoundTag,version: int): cn.nukkit.nbt.tag.ListTag;
        /**
         * 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         * @param {int} offsetX 
         * @param {int} offsetZ 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         */
        public  scanBlocks(provider: cn.nukkit.level.format.LevelProvider,offsetX: int,offsetZ: int,min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate): java.util.List;
        /**
         * 
         */
        public copy(): cn.nukkit.level.format.anvil.ChunkSection;
        /**
         * 
         */
        public  copy(): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         * @param {byte[]} idsBase 
         * @param {byte[]} idsExtra 
         * @param {cn.nukkit.level.format.anvil.util.NibbleArray} dataBase 
         * @param {cn.nukkit.level.format.anvil.util.NibbleArray} dataExtra 
         * @param {boolean} big 
         * @param {java.util.List} hugeList 
         * @param {boolean} huge 
         * @param {int} bx 
         * @param {int} by 
         * @param {int} bz 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        private lambda$saveData$0(idsBase: byte[],idsExtra: byte[],dataBase: cn.nukkit.level.format.anvil.util.NibbleArray,dataExtra: cn.nukkit.level.format.anvil.util.NibbleArray,big: boolean,hugeList: java.util.List,huge: boolean,bx: int,by: int,bz: int,state: cn.nukkit.blockstate.BlockState): void;
        /**
         * 
         * @param {java.util.List} hugeList 
         * @param {cn.nukkit.blockstate.BlockState} state 
         * @param {int} anvil 
         * @param {int} intData 
         */
        private saveHugeData(hugeList: java.util.List,state: cn.nukkit.blockstate.BlockState,anvil: int,intData: int): void;
        /**
         * 
         * @param {java.util.List} hugeList 
         * @param {int} pos 
         */
        private allocateBlob(hugeList: java.util.List,pos: int): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} index 
         * @param {int} blockId 
         * @param {int} composedData 
         * @param {cn.nukkit.nbt.tag.ListTag} hugeDataList 
         * @param {int} hugeDataSize 
         */
        private static loadState(index: int,blockId: int,composedData: int,hugeDataList: cn.nukkit.nbt.tag.ListTag,hugeDataSize: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockChangeStateAbove(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private static getAnvilIndex(x: int,y: int,z: int): int;
        /**
         * 
         */
        public compress(): boolean;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         * @param {cn.nukkit.level.format.anvil.util.BlockStorage} storage 
         * @param {byte[]} idsBase 
         * @param {byte[]} idsExtra 
         * @param {cn.nukkit.level.format.anvil.util.NibbleArray} dataBase 
         * @param {cn.nukkit.level.format.anvil.util.NibbleArray} dataExtra 
         */
        private saveData(storage: cn.nukkit.level.format.anvil.util.BlockStorage,idsBase: byte[],idsExtra: byte[],dataBase: cn.nukkit.level.format.anvil.util.NibbleArray,dataExtra: cn.nukkit.level.format.anvil.util.NibbleArray): java.util.List;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.block.Block} block 
         */
        public getAndSetBlock(x: int,y: int,z: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         */
        public  getAndSetBlock(x: int,y: int,z: int,layer: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} layer 
         * @param {cn.nukkit.nbt.tag.CompoundTag} storageTag 
         */
        private loadStorage(layer: int,storageTag: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         * @param {char[]} raw 
         */
        private toXZY(raw: char[]): byte[];
        /**
         * 
         * @param {byte} baseData 
         * @param {byte} extraData 
         */
        private static composeData(baseData: byte,extraData: byte): int;
        /**
         * 
         * @param {int} index 
         * @param {int} blockId 
         * @param {int} composedData 
         * @param {cn.nukkit.nbt.tag.ListTag} hugeDataList 
         * @param {int} hugeDataSize 
         */
        private static loadHugeIntData(index: int,blockId: int,composedData: int,hugeDataList: cn.nukkit.nbt.tag.ListTag,hugeDataSize: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public  setBlockData(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         */
        public getContentVersion(): int;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public  writeTo(stream: cn.nukkit.utils.BinaryStream): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockId(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public  setBlockId(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public setBlockSkyLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         */
        public  delayPaletteUpdates(): void;
        /**
         * 
         * @param {byte} baseId 
         * @param {byte} extraId 
         */
        private static composeBlockId(baseId: byte,extraId: byte): int;
        /**
         * 
         */
        public getY(): int;
        /**
         * 
         */
        public getLightArray(): byte[];
        /**
         * 
         */
        private inflate(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public  getAndSetBlockState(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getMaximumLayer(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockState(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getSkyLightArray(): byte[];
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerInteractEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        blockFace: cn.nukkit.math.BlockFace;
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        touchVector: cn.nukkit.math.Vector3;
        /**  */
        action: cn.nukkit.event.player.PlayerInteractEvent.Action;
        /**  */
        blockTouched: cn.nukkit.block.Block;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getAction(): cn.nukkit.event.player.PlayerInteractEvent.Action;
        /**
         * 
         */
        public getFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getTouchVector(): cn.nukkit.math.Vector3;
    }
}
declare namespace cn.nukkit.level.biome.impl.savanna{
     class SavannaMBiome extends cn.nukkit.level.biome.impl.savanna.SavannaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public doesOverhang(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemNuggetGold extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.generator.populator.type{
    abstract class Populator extends java.lang.Object{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager,x: int,z: int,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class SaveOnCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemRottenFlesh extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.level.format.generic{
    abstract class BaseRegionLoader extends java.lang.Object{
        /**  */
        COMPRESSION_LEVEL: int;
        /**  */
        primitiveLocationTable: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**  */
        levelProvider: cn.nukkit.level.format.LevelProvider;
        /**  */
        randomAccessFile: java.io.RandomAccessFile;
        /**  */
        lastUsed: long;
        /**  */
        COMPRESSION_ZLIB: byte;
        /**  */
        VERSION: int;
        /**  */
        x: int;
        /**  */
        lastSector: int;
        /**  */
        z: int;
        /**  */
        COMPRESSION_GZIP: byte;
        /**  */
        MAX_SECTOR_LENGTH: int;
        /**  */
        locationTable: java.util.Map;
        /**
         * 
         * @param {java.lang.Integer[]} table 
         */
        private static lambda$new$0(table: java.lang.Integer[]): int[];
        /**
         * 
         */
        public abstract doSlowCleanUp(): int;
        /**
         * 
         */
        protected abstract createBlank(): void;
        /**
         * 
         */
        public compress(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract readChunk(x: int,z: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        protected abstract loadLocationTable(): void;
        /**
         * 
         */
        public getLocationIndexes(): java.lang.Integer[];
        /**
         * 
         * @param {byte[]} data 
         */
        protected abstract unserializeChunk(data: byte[]): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} x$0 
         */
        private static lambda$null$1(x$0: int): java.lang.Integer[];
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract writeChunk(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         */
        public abstract getX(): int;
        /**
         * 
         * @param {int} index 
         */
        protected abstract isChunkGenerated(index: int): boolean;
        /**
         * 
         */
        public abstract getZ(): int;
        /**
         * 
         */
        public getRandomAccessFile(): java.io.RandomAccessFile;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {byte[]} chunkData 
         */
        protected abstract saveChunk(x: int,z: int,chunkData: byte[]): void;
        /**
         * 
         */
        public getIntLocationIndexes(): int[];
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract removeChunk(x: int,z: int): void;
        /**
         * 
         * @param {int} index 
         */
        protected abstract writeLocationIndex(index: int): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract chunkExists(x: int,z: int): boolean;
        /**
         * 
         * @param {int[]} table 
         */
        private static lambda$new$2(table: int[]): java.lang.Integer[];
    }
}
declare namespace cn.nukkit.level.biome.impl.mesa{
     class MesaPlateauFBiome extends cn.nukkit.level.biome.impl.mesa.MesaPlateauBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getCoverBlock(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AddPlayerPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        metadata: cn.nukkit.entity.data.EntityMetadata;
        /**  */
        speedZ: float;
        /**  */
        NETWORK_ID: byte;
        /**  */
        speedY: float;
        /**  */
        speedX: float;
        /**  */
        entityUniqueId: long;
        /**  */
        uuid: java.util.UUID;
        /**  */
        deviceId: java.lang.String;
        /**  */
        yaw: float;
        /**  */
        entityRuntimeId: long;
        /**  */
        buildPlatform: int;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        pitch: float;
        /**  */
        platformChatId: java.lang.String;
        /**  */
        username: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.nbt.tag{
    abstract class NumberTag extends cn.nukkit.nbt.tag.Tag{
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public abstract setData(data: java.lang.Number): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         */
        public abstract getData(): java.lang.Number;
    }
}
declare namespace cn.nukkit.network.protocol{
    abstract class DataPacket extends cn.nukkit.utils.BinaryStream{
        /**  */
        EMPTY_ARRAY: cn.nukkit.network.protocol.DataPacket[];
        /**  */
        isEncoded: boolean;
        /**  */
        reliability: com.nukkitx.network.raknet.RakNetReliability;
        /**  */
        channel: int;
        /**
         * 
         */
        public abstract encode(): void;
        /**
         * 
         */
        public  tryEncode(): void;
        /**
         * 
         */
        public getChannel(): int;
        /**
         * 
         * @param {int} level 
         */
        public compress(level: int): cn.nukkit.network.protocol.BatchPacket;
        /**
         * 
         */
        public compress(): cn.nukkit.network.protocol.BatchPacket;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public reset(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public  reset(): cn.nukkit.utils.BinaryStream;
        /**
         * 
         */
        public abstract pid(): byte;
        /**
         * 
         * @param {int} channel 
         */
        public setChannel(channel: int): void;
        /**
         * 
         */
        public abstract decode(): void;
        /**
         * 
         */
        public clean(): cn.nukkit.network.protocol.DataPacket;
    }
}
declare namespace cn.nukkit.item{
     class ItemPickaxeGold extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment.loot{
     class EnchantmentLootDigging extends cn.nukkit.item.enchantment.loot.EnchantmentLoot{
    }
}
declare namespace cn.nukkit.network.protocol{
     class LecternUpdatePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        blockPosition: cn.nukkit.math.BlockVector3;
        /**  */
        dropBook: boolean;
        /**  */
        totalPages: int;
        /**  */
        page: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item.enchantment.damage{
     class EnchantmentDamageAll extends cn.nukkit.item.enchantment.damage.EnchantmentDamage{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxEnchantableLevel(): int;
    }
}
declare namespace com.blocklynukkit.loader.script.window.windowCallbacks{
     class SimpleCallback extends com.blocklynukkit.loader.script.window.windowCallbacks.WindowCallback{
        /**  */
        defaultCallback: java.lang.String;
        /**  */
        actionCallbacks: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 
         */
        public call(event: cn.nukkit.event.player.PlayerFormRespondedEvent): void;
        /**
         * 
         */
        public hasDefaultCallback(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {java.lang.String} actionCallback 
         */
        public addActionCallback(index: int,actionCallback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} actionCallback 
         */
        public addActionCallback(actionCallback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} defaultCallback 
         */
        public setDefaultCallback(defaultCallback: java.lang.String): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityPiglin extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public isBaby(): boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.generator{
     class Flat extends cn.nukkit.level.generator.Generator{
        /**  */
        random: cn.nukkit.math.NukkitRandom;
        /**  */
        init: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        populators: java.util.List;
        /**  */
        biome: int;
        /**  */
        floorLevel: int;
        /**  */
        options: java.util.Map;
        /**  */
        preset: java.lang.String;
        /**  */
        structure: int[][];
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        public init(level: cn.nukkit.level.ChunkManager,random: cn.nukkit.math.NukkitRandom): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getChunkManager(): cn.nukkit.level.ChunkManager;
        /**
         * 
         */
        public getSpawn(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {java.lang.String} preset 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        protected parsePreset(preset: java.lang.String,chunkX: int,chunkZ: int): void;
        /**
         * 
         */
        public getSettings(): java.util.Map;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public populateChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        private generateChunk(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public generateChunk(chunkX: int,chunkZ: int): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityPufferfish extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemRabbitRaw extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.network.protocol{
     class BossEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        TYPE_REGISTER_PLAYER: int;
        /**  */
        color: int;
        /**  */
        overlay: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        bossEid: long;
        /**  */
        TYPE_UPDATE: int;
        /**  */
        type: int;
        /**  */
        title: java.lang.String;
        /**  */
        TYPE_SHOW: int;
        /**  */
        TYPE_HIDE: int;
        /**  */
        unknown: short;
        /**  */
        TYPE_UNREGISTER_PLAYER: int;
        /**  */
        playerEid: long;
        /**  */
        TYPE_HEALTH_PERCENT: int;
        /**  */
        healthPercent: float;
        /**  */
        TYPE_UNKNOWN_6: int;
        /**  */
        TYPE_TEXTURE: int;
        /**  */
        TYPE_TITLE: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSeedsPumpkin extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.format.generic{
    abstract class BaseFullChunk extends java.lang.Object{
        /**  */
        data: byte[];
        /**  */
        biomes: byte[];
        /**  */
        extraData: java.util.Map;
        /**  */
        blocks: byte[];
        /**  */
        chunkPacket: cn.nukkit.network.protocol.BatchPacket;
        /**  */
        NBTtiles: java.util.List;
        /**  */
        NBTentities: java.util.List;
        /**  */
        changes: long;
        /**  */
        skyLight: byte[];
        /**  */
        tiles: java.util.Map;
        /**  */
        heightMap: byte[];
        /**  */
        entities: java.util.Map;
        /**  */
        provider: cn.nukkit.level.format.LevelProvider;
        /**  */
        blockLight: byte[];
        /**  */
        x: int;
        /**  */
        tileList: java.util.Map;
        /**  */
        z: int;
        /**  */
        providerClass: java.lang.Class;
        /**  */
        hash: long;
        /**  */
        isInit: boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockExtraData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         */
        public  setX(x: int): void;
        /**
         * 
         */
        public  getIndex(): long;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public recalculateHeightMapColumn(x: int,z: int): int;
        /**
         * 
         */
        public getBlockEntities(): java.util.Map;
        /**
         * 
         */
        public isLoaded(): boolean;
        /**
         * 
         * @param {int} z 
         */
        public  setZ(z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public setPosition(x: int,z: int): void;
        /**
         * 
         */
        public hasChanged(): boolean;
        /**
         * 
         * @param {boolean} save 
         */
        public unload(save: boolean): boolean;
        /**
         * 
         * @param {boolean} save 
         * @param {boolean} safe 
         */
        public unload(save: boolean,safe: boolean): boolean;
        /**
         * 
         */
        public unload(): boolean;
        /**
         * 
         */
        public toFastBinary(): byte[];
        /**
         * 
         */
        public getProvider(): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         */
        public scanBlocks(min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate): java.util.stream.Stream;
        /**
         * 
         */
        public getBiomeIdArray(): byte[];
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} blockEntity 
         */
        public removeBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getTile(x: int,y: int,z: int): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public compress(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockIdAt(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public setBlockIdAt(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         */
        public isLightPopulated(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public setBlockAt(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         */
        public initChunk(): void;
        /**
         * 
         */
        public populateSkyLight(): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public addEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getEntities(): java.util.Map;
        /**
         * 
         */
        public setChanged(): void;
        /**
         * 
         * @param {boolean} changed 
         */
        public setChanged(changed: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockDataAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockDataAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {byte} biomeId 
         */
        public setBiomeId(x: int,z: int,biomeId: byte): void;
        /**
         * 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         */
        public setProvider(provider: cn.nukkit.level.format.LevelProvider): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getBiomeId(x: int,z: int): int;
        /**
         * 
         */
        public setLightPopulated(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setLightPopulated(value: boolean): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         */
        public backwardCompatibilityUpdate(level: cn.nukkit.level.Level): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockIdAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockIdAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getHeightMap(x: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getHighestBlockAt(x: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} cache 
         */
        public getHighestBlockAt(x: int,z: int,cache: boolean): int;
        /**
         * 
         * @param {boolean} generate 
         */
        public load(generate: boolean): boolean;
        /**
         * 
         */
        public load(): boolean;
        /**
         * 
         */
        public getChanges(): long;
        /**
         * 
         */
        public recalculateHeightMap(): void;
        /**
         * 
         */
        public getBlockLightArray(): byte[];
        /**
         * 
         * @param {cn.nukkit.network.protocol.BatchPacket} packet 
         */
        public setChunkPacket(packet: cn.nukkit.network.protocol.BatchPacket): void;
        /**
         * 
         */
        public getHeightMapArray(): byte[];
        /**
         * 
         */
        public getSeed(): long;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} blockEntity 
         */
        public addBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public setChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        public setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public removeEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public setBlockFullIdAt(x: int,y: int,z: int,fullId: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public setBlockFullIdAt(x: int,y: int,z: int,layer: int,fullId: int): void;
        /**
         * 
         */
        public getBlockExtraDataArray(): java.util.Map;
        /**
         * 
         */
        public  getX(): int;
        /**
         * 
         */
        public  getZ(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {int} value 
         */
        public setHeightMap(x: int,z: int,value: int): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public getChunkPacket(): cn.nukkit.network.protocol.BatchPacket;
        /**
         * 
         */
        public getBlockSkyLightArray(): byte[];
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockExtraData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public setBlockDataAt(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockDataAt(x: int,y: int,z: int,data: int): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.desert{
     class DesertHillsBiome extends cn.nukkit.level.biome.impl.desert.DesertBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.utils{
    abstract class ThreadedLogger extends java.lang.Thread{
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockTransparent extends cn.nukkit.block.Block{
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
    }
}
declare namespace cn.nukkit.item{
     class Item extends java.lang.Object{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        EMPTY_ARRAY: cn.nukkit.item.Item[];
        /**  */
        itemIds: java.util.Map;
        /**  */
        durability: int;
        /**  */
        count: int;
        /**  */
        blockIds: java.util.Map;
        /**  */
        list: java.lang.Class[];
        /**  */
        UNKNOWN_STR: java.lang.String;
        /**  */
        creative: java.util.ArrayList;
        /**  */
        tags: byte[];
        /**  */
        ITEM_STRING_PATTERN: java.util.regex.Pattern;
        /**  */
        meta: int;
        /**  */
        hasMeta: boolean;
        /**  */
        name: java.lang.String;
        /**  */
        cachedNBT: cn.nukkit.nbt.tag.CompoundTag;
        /**  */
        block: cn.nukkit.block.Block;
        /**  */
        itemList: java.util.List;
        /**  */
        id: int;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} compoundTag 
         */
        public setCustomBlockData(compoundTag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {java.lang.String} str 
         */
        public static fromStringMultiple(str: java.lang.String): cn.nukkit.item.Item[];
        /**
         * 
         * @param {java.lang.Integer} e1 
         * @param {java.lang.Integer} e2 
         */
        private static lambda$static$9(e1: java.lang.Integer,e2: java.lang.Integer): java.lang.Integer;
        /**
         * 
         */
        public clearCustomName(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.Player} player 
         */
        public getDestroySpeed(block: cn.nukkit.block.Block,player: cn.nukkit.Player): int;
        /**
         * 
         */
        public static clearCreativeItems(): void;
        /**
         * 
         * @param {int} id 
         */
        public hasEnchantment(id: int): boolean;
        /**
         * 
         * @param {java.lang.Integer} meta 
         */
        public setDamage(meta: java.lang.Integer): void;
        /**
         * 
         */
        public clearCustomBlockData(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public static addCreativeItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public hasEnchantments(): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getEnchantment(id: int): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         * @param {short} id 
         */
        public getEnchantment(id: short): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         */
        public hasCustomName(): boolean;
        /**
         * 
         */
        public isFertilizer(): boolean;
        /**
         * 
         */
        public getCount(): int;
        /**
         * 
         * @param {int} count 
         */
        public setCount(count: int): void;
        /**
         * 
         */
        public getDamage(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} other 
         */
        public  equalsExact(other: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public static init(): void;
        /**
         * 
         */
        public  getFuelTime(): java.lang.Short;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public isShears(): boolean;
        /**
         * 
         * @param {int} index 
         */
        public static getCreativeItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.lang.String[]} lines 
         */
        public  setLore(...lines: java.lang.String[]): cn.nukkit.item.Item;
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public hasMeta(): boolean;
        /**
         * 
         */
        public isUnbreakable(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public static isCreativeItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public isPickaxe(): boolean;
        /**
         * 
         */
        public isArmor(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getAttackSideEffects(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         * @param {int} amount 
         */
        public  increment(amount: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public damageWhenBreaking(): boolean;
        /**
         * 
         */
        public hasCustomBlockData(): boolean;
        /**
         * 
         */
        public isTool(): boolean;
        /**
         * 
         */
        public isChestplate(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        private static rebuildItemList(name: java.lang.String): java.lang.String;
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public  getNetworkId(): int;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         */
        public static get(id: int,meta: java.lang.Integer): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} id 
         */
        public static get(id: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         * @param {int} count 
         * @param {byte[]} tags 
         */
        public static get(id: int,meta: java.lang.Integer,count: int,tags: byte[]): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         * @param {int} count 
         */
        public static get(id: int,meta: java.lang.Integer,count: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.util.Map} data 
         */
        public static fromJsonNetworkId(data: java.util.Map): cn.nukkit.item.Item;
        /**
         * 
         */
        public getNamespaceId(): java.lang.String;
        /**
         * 
         * @param {int} x$0 
         */
        private static getAttackSideEffects(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        private static getAttackSideEffects(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity,enchantment: cn.nukkit.item.enchantment.Enchantment): java.util.stream.Stream;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public useOn(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public useOn(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public  canBePlaced(): boolean;
        /**
         * 
         */
        public getCustomName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onUse(player: cn.nukkit.Player,ticksUsed: int): boolean;
        /**
         * 
         */
        public hasCompoundTag(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getNamedTagEntry(name: java.lang.String): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public getEnchantAbility(): int;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public setNamedTag(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} checkDamage 
         */
        public  equalsIgnoringEnchantmentOrder(item: cn.nukkit.item.Item,checkDamage: boolean): boolean;
        /**
         * 
         */
        public getEnchantments(): cn.nukkit.item.enchantment.Enchantment[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public static getCreativeItemIndex(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$0(field: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {int} amount 
         */
        public  decrement(amount: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} checkDamage 
         * @param {boolean} checkCompound 
         */
        public  equals(item: cn.nukkit.item.Item,checkDamage: boolean,checkCompound: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} checkDamage 
         */
        public  equals(item: cn.nukkit.item.Item,checkDamage: boolean): boolean;
        /**
         * 
         * @param {java.lang.Object} item 
         */
        public  equals(item: java.lang.Object): boolean;
        /**
         * 
         */
        public isNull(): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$3(field: java.lang.reflect.Field): java.lang.Integer;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         * @param {java.util.Map} data 
         */
        public static fromJson(data: java.util.Map): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.util.Map} data 
         * @param {boolean} ignoreNegativeItemId 
         */
        private static fromJson(data: java.util.Map,ignoreNegativeItemId: boolean): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.lang.Integer} e1 
         * @param {java.lang.Integer} e2 
         */
        private static lambda$static$4(e1: java.lang.Integer,e2: java.lang.Integer): java.lang.Integer;
        /**
         * 
         */
        public  toString(): java.lang.String;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$1(field: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$2(field: java.lang.reflect.Field): java.lang.String;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$7(field: java.lang.reflect.Field): java.lang.String;
        /**
         * 
         */
        private static initCreativeItems(): void;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$8(field: java.lang.reflect.Field): java.lang.Integer;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$5(field: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$static$6(field: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getNamedTag(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public  getName(): java.lang.String;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setCustomName(name: java.lang.String): cn.nukkit.item.Item;
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         * @param {byte[]} tag 
         */
        public static parseCompoundTag(tag: byte[]): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onRelease(player: cn.nukkit.Player,ticksUsed: int): boolean;
        /**
         * 
         * @param {int} cost 
         */
        public setRepairCost(cost: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment[]} enchantments 
         */
        public  addEnchantment(...enchantments: cn.nukkit.item.enchantment.Enchantment[]): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public writeCompoundTag(tag: cn.nukkit.nbt.tag.CompoundTag): byte[];
        /**
         * 
         */
        public createFuzzyCraftingRecipe(): cn.nukkit.item.Item;
        /**
         * 
         */
        public static rebuildItemList(): java.util.List;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public isLeggings(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public  deepEquals(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} checkDamage 
         * @param {boolean} checkCompound 
         */
        public  deepEquals(item: cn.nukkit.item.Item,checkDamage: boolean,checkCompound: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} checkDamage 
         */
        public  deepEquals(item: cn.nukkit.item.Item,checkDamage: boolean): boolean;
        /**
         * 
         * @param {java.util.Map} data 
         */
        private static loadCreativeItemEntry(data: java.util.Map): cn.nukkit.item.Item;
        /**
         * 
         */
        public clearNamedTag(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getRepairCost(): int;
        /**
         * 
         */
        public static getItemList(): java.util.List;
        /**
         * 
         * @param {int} id 
         */
        public getEnchantmentLevel(id: int): int;
        /**
         * 
         */
        public getCompoundTag(): byte[];
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {byte[]} tags 
         */
        public setCompoundTag(tags: byte[]): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public setCompoundTag(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item;
        /**
         * 
         */
        public getBlockId(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public static getCreativeItems(): java.util.ArrayList;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         * @param {int} count 
         */
        public static getBlock(id: int,meta: java.lang.Integer,count: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         */
        public static getBlock(id: int,meta: java.lang.Integer): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} id 
         */
        public static getBlock(id: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         * @param {int} count 
         * @param {byte[]} tags 
         */
        public static getBlock(id: int,meta: java.lang.Integer,count: int,tags: byte[]): cn.nukkit.item.Item;
        /**
         * 
         */
        public  getNetworkFullId(): int;
        /**
         * 
         */
        public getLore(): java.lang.String[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public static removeCreativeItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getBlockUnsafe(): cn.nukkit.block.Block;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         * @param {java.lang.String} str 
         */
        public static fromString(str: java.lang.String): cn.nukkit.item.Item;
        /**
         * 
         */
        public getCustomBlockData(): cn.nukkit.nbt.tag.CompoundTag;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntitySkeletonHorse extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityExplosionPrimeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        fireChance: double;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        force: double;
        /**  */
        blockBreaking: boolean;
        /**
         * 
         * @param {boolean} incendiary 
         */
        public setIncendiary(incendiary: boolean): void;
        /**
         * 
         * @param {double} force 
         */
        public setForce(force: double): void;
        /**
         * 
         */
        public isIncendiary(): boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getForce(): double;
        /**
         * 
         */
        public isBlockBreaking(): boolean;
        /**
         * 
         */
        public getFireChance(): double;
        /**
         * 
         * @param {double} fireChance 
         */
        public setFireChance(fireChance: double): void;
        /**
         * 
         * @param {boolean} blockBreaking 
         */
        public setBlockBreaking(blockBreaking: boolean): void;
    }
}
declare namespace cn.nukkit.level.generator{
    abstract class Generator extends java.lang.Object{
        /**  */
        typeList: java.util.Map;
        /**  */
        TYPE_FLAT: int;
        /**  */
        TYPE_INFINITE: int;
        /**  */
        nameList: java.util.Map;
        /**  */
        TYPE_NETHER: int;
        /**  */
        TYPE_OLD: int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        public abstract init(level: cn.nukkit.level.ChunkManager,random: cn.nukkit.math.NukkitRandom): void;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         */
        public abstract getSpawn(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public abstract getSettings(): java.util.Map;
        /**
         * 
         */
        public static getGeneratorList(): java.lang.String[];
        /**
         * 
         */
        public abstract getId(): int;
        /**
         * 
         * @param {java.lang.Class} clazz 
         * @param {java.lang.String} name 
         * @param {int} type 
         */
        public static addGenerator(clazz: java.lang.Class,name: java.lang.String,type: int): boolean;
        /**
         * 
         */
        public abstract getChunkManager(): cn.nukkit.level.ChunkManager;
        /**
         * 
         * @param {int} type 
         */
        public static getGenerator(type: int): java.lang.Class;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getGenerator(name: java.lang.String): java.lang.Class;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public abstract populateChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {java.lang.Class} c 
         */
        public static getGeneratorType(c: java.lang.Class): int;
        /**
         * 
         * @param {java.lang.Class} c 
         */
        public static getGeneratorName(c: java.lang.Class): java.lang.String;
        /**
         * 
         */
        public getDimension(): int;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public abstract generateChunk(chunkX: int,chunkZ: int): void;
    }
}
declare namespace cn.nukkit.command.data{
     class CommandData extends java.lang.Object{
        /**  */
        aliases: cn.nukkit.command.data.CommandEnum;
        /**  */
        overloads: java.util.Map;
        /**  */
        flags: int;
        /**  */
        description: java.lang.String;
        /**  */
        permission: int;
        /**
         * 
         */
        public clone(): cn.nukkit.command.data.CommandData;
        /**
         * 
         */
        public  clone(): java.lang.Object;
    }
}
declare namespace cn.nukkit.block{
     class BlockDirt extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        DIRT_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDirtType(): java.util.Optional;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.DirtType} dirtType 
         */
        public setDirtType(dirtType: cn.nukkit.blockproperty.value.DirtType): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemBookWritten extends cn.nukkit.item.ItemBookWritable{
        /**  */
        GENERATION_COPY_OF_COPY: int;
        /**  */
        GENERATION_TATTERED: int;
        /**  */
        GENERATION_ORIGINAL: int;
        /**  */
        GENERATION_COPY: int;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} author 
         * @param {java.lang.String} xuid 
         * @param {int} generation 
         */
        public signBook(title: java.lang.String,author: java.lang.String,xuid: java.lang.String,generation: int): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getTitle(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} author 
         */
        public setAuthor(author: java.lang.String): void;
        /**
         * 
         */
        public getAuthor(): java.lang.String;
        /**
         * 
         * @param {int} generation 
         */
        public setGeneration(generation: int): void;
        /**
         * 
         */
        public getGeneration(): int;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public setXUID(title: java.lang.String): void;
        /**
         * 
         */
        public getXUID(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public setTitle(title: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} author 
         * @param {java.lang.String} title 
         * @param {cn.nukkit.nbt.tag.ListTag} pages 
         */
        public writeBook(author: java.lang.String,title: java.lang.String,pages: cn.nukkit.nbt.tag.ListTag): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.lang.String} author 
         * @param {java.lang.String} title 
         * @param {java.lang.String[]} pages 
         */
        public writeBook(author: java.lang.String,title: java.lang.String,pages: java.lang.String[]): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.level.particle{
    abstract class Particle extends cn.nukkit.math.Vector3{
        /**  */
        TYPE_NOTE_AND_DUST: int;
        /**  */
        TYPE_SPORE_BLOSSOM_AMBIENT: int;
        /**  */
        TYPE_REDSTONE: int;
        /**  */
        TYPE_FIREWORKS_SPARK: int;
        /**  */
        TYPE_LAVA: int;
        /**  */
        TYPE_FOOD: int;
        /**  */
        TYPE_PORTAL: int;
        /**  */
        TYPE_MOB_APPEARANCE: int;
        /**  */
        TYPE_COLORED_FLAME: int;
        /**  */
        TYPE_STALACTITE_DRIP_WATER: int;
        /**  */
        TYPE_CARROT: int;
        /**  */
        TYPE_STALACTITE_DRIP_LAVA: int;
        /**  */
        TYPE_RISING_RED_DUST: int;
        /**  */
        TYPE_DRAGONS_BREATH: int;
        /**  */
        TYPE_PORTAL_REVERSE: int;
        /**  */
        TYPE_SOUL: int;
        /**  */
        TYPE_VILLAGER_HAPPY: int;
        /**  */
        TYPE_NOTE: int;
        /**  */
        TYPE_OBSIDIAN_TEAR: int;
        /**  */
        TYPE_WAX: int;
        /**  */
        TYPE_BUBBLE_COLUMN_DOWN: int;
        /**  */
        TYPE_FLAME: int;
        /**  */
        TYPE_TERRAIN: int;
        /**  */
        TYPE_LARGE_EXPLOSION: int;
        /**  */
        TYPE_FALLING_DRAGONS_BREATH: int;
        /**  */
        TYPE_INK: int;
        /**  */
        TYPE_SMOKE: int;
        /**  */
        TYPE_TALL_CAMPFIRE_SMOKE: int;
        /**  */
        TYPE_CAMPFIRE_SMOKE: int;
        /**  */
        TYPE_DRIP_HONEY: int;
        /**  */
        TYPE_WATER_SPLASH: int;
        /**  */
        TYPE_TRACKING_EMITTER: int;
        /**  */
        TYPE_BUBBLE: int;
        /**  */
        TYPE_SPORE_BLOSSOM_SHOWER: int;
        /**  */
        TYPE_MYCELIUM_DUST: int;
        /**  */
        TYPE_SCULK_SENSOR_REDSTONE: int;
        /**  */
        TYPE_VILLAGER_ANGRY: int;
        /**  */
        TYPE_VIBRATION_SIGNAL: int;
        /**  */
        TYPE_FIREWORKS_STARTER: int;
        /**  */
        TYPE_SHULKER_BULLET: int;
        /**  */
        TYPE_EXPLODE: int;
        /**  */
        TYPE_RAIN_SPLASH: int;
        /**  */
        TYPE_WITCH_SPELL: int;
        /**  */
        TYPE_SNOWBALL_POOF: int;
        /**  */
        TYPE_BUBBLE_MANUAL: int;
        /**  */
        TYPE_BLOCK_FORCE_FIELD: int;
        /**  */
        TYPE_SLIME: int;
        /**  */
        TYPE_MOB_SPELL_AMBIENT: int;
        /**  */
        TYPE_CANDLE_FLAME: int;
        /**  */
        TYPE_END_ROD: int;
        /**  */
        TYPE_BALLOON_GAS: int;
        /**  */
        TYPE_SPLASH: int;
        /**  */
        TYPE_HUGE_EXPLODE_SEED: int;
        /**  */
        TYPE_MOB_PORTAL: int;
        /**  */
        TYPE_WATER_SPLASH_MANUAL: int;
        /**  */
        TYPE_EVAPORATION: int;
        /**  */
        TYPE_MOB_SPELL: int;
        /**  */
        TYPE_LARGE_SMOKE: int;
        /**  */
        TYPE_BUBBLE_COLUMN_UP: int;
        /**  */
        TYPE_ITEM_BREAK: int;
        /**  */
        TYPE_DUST: int;
        /**  */
        TYPE_SUSPENDED_TOWN: int;
        /**  */
        TYPE_HEART: int;
        /**  */
        TYPE_SPIT: int;
        /**  */
        TYPE_FALLING_DUST: int;
        /**  */
        TYPE_RISING_DRAGONS_BREATH: int;
        /**  */
        TYPE_CONDUIT: int;
        /**  */
        TYPE_HUGE_EXPLODE: int;
        /**  */
        TYPE_SNOWFLAKE: int;
        /**  */
        TYPE_MOB_FLAME: int;
        /**  */
        TYPE_BLUE_FLAME: int;
        /**  */
        TYPE_ELECTRIC_SPARK: int;
        /**  */
        TYPE_TOTEM: int;
        /**  */
        TYPE_FALLING_RED_DUST: int;
        /**  */
        TYPE_CRITICAL: int;
        /**  */
        TYPE_SPARKLER: int;
        /**  */
        TYPE_SNEEZE: int;
        /**  */
        TYPE_FIREWORKS_OVERLAY: int;
        /**  */
        TYPE_ENCHANTMENT_TABLE: int;
        /**  */
        TYPE_WATER_WAKE: int;
        /**  */
        TYPE_TOWN_AURA: int;
        /**  */
        TYPE_DRIP_WATER: int;
        /**  */
        TYPE_BLEACH: int;
        /**  */
        TYPE_DRIP_LAVA: int;
        /**  */
        TYPE_MOB_SPELL_INSTANTANEOUS: int;
        /**
         * 
         */
        public abstract encode(): cn.nukkit.network.protocol.DataPacket[];
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getParticleIdByName(name: java.lang.String): java.lang.Integer;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static particleExists(name: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.command.defaults{
     class DeopCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemSkull extends cn.nukkit.item.Item{
        /**  */
        DRAGON_HEAD: int;
        /**  */
        HEAD: int;
        /**  */
        WITHER_SKELETON_SKULL: int;
        /**  */
        CREEPER_HEAD: int;
        /**  */
        ZOMBIE_HEAD: int;
        /**  */
        SKELETON_SKULL: int;
        /**
         * 
         * @param {int} meta 
         */
        public static getItemSkullName(meta: int): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.jungle{
     class JungleBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class QQFriendMessageEvent extends cn.nukkit.event.Event{
        /**  */
        eventId: java.lang.String;
        /**  */
        fromQQ: java.lang.String;
        /**  */
        selfQQ: java.lang.String;
        /**  */
        eventSeed: java.lang.String;
        /**  */
        message: java.lang.String;
        /**
         * 
         */
        public getFromQQ(): java.lang.String;
        /**
         * 
         */
        public getSelfQQ(): java.lang.String;
        /**
         * 
         */
        public getMessage(): java.lang.String;
        /**
         * 
         */
        public getEventSeed(): java.lang.String;
        /**
         * 
         */
        public getEventId(): java.lang.String;
    }
}
declare namespace cn.nukkit.item.enchantment{
    abstract class Enchantment extends java.lang.Object{
        /**  */
        ID_PROTECTION_EXPLOSION: int;
        /**  */
        EMPTY_ARRAY: cn.nukkit.item.enchantment.Enchantment[];
        /**  */
        ID_CROSSBOW_PIERCING: int;
        /**  */
        ID_KNOCKBACK: int;
        /**  */
        ID_TRIDENT_RIPTIDE: int;
        /**  */
        ID_CROSSBOW_MULTISHOT: int;
        /**  */
        ID_MENDING: int;
        /**  */
        ID_DAMAGE_ALL: int;
        /**  */
        ID_BINDING_CURSE: int;
        /**  */
        ID_PROTECTION_FALL: int;
        /**  */
        ID_BOW_INFINITY: int;
        /**  */
        type: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        ID_PROTECTION_FIRE: int;
        /**  */
        ID_DAMAGE_SMITE: int;
        /**  */
        ID_VANISHING_CURSE: int;
        /**  */
        ID_FORTUNE_DIGGING: int;
        /**  */
        id: int;
        /**  */
        ID_BOW_POWER: int;
        /**  */
        ID_FROST_WALKER: int;
        /**  */
        ID_TRIDENT_CHANNELING: int;
        /**  */
        ID_PROTECTION_PROJECTILE: int;
        /**  */
        ID_LOOTING: int;
        /**  */
        ID_CROSSBOW_QUICK_CHARGE: int;
        /**  */
        level: int;
        /**  */
        ID_DAMAGE_ARTHROPODS: int;
        /**  */
        ID_BOW_KNOCKBACK: int;
        /**  */
        words: java.lang.String[];
        /**  */
        ID_WATER_BREATHING: int;
        /**  */
        enchantments: cn.nukkit.item.enchantment.Enchantment[];
        /**  */
        ID_EFFICIENCY: int;
        /**  */
        ID_DURABILITY: int;
        /**  */
        ID_LURE: int;
        /**  */
        ID_WATER_WALKER: int;
        /**  */
        ID_WATER_WORKER: int;
        /**  */
        ID_TRIDENT_IMPALING: int;
        /**  */
        ID_TRIDENT_LOYALTY: int;
        /**  */
        ID_SILK_TOUCH: int;
        /**  */
        ID_THORNS: int;
        /**  */
        ID_SOUL_SPEED: int;
        /**  */
        ID_BOW_FLAME: int;
        /**  */
        name: java.lang.String;
        /**  */
        ID_PROTECTION_ALL: int;
        /**  */
        ID_FIRE_ASPECT: int;
        /**  */
        ID_FORTUNE_FISHING: int;
        /**  */
        rarity: cn.nukkit.item.enchantment.Enchantment.Rarity;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getAttackSideEffects(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         */
        public static getRandomName(): java.lang.String;
        /**
         * 
         */
        public getWeight(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getRarity(): cn.nukkit.item.enchantment.Enchantment.Rarity;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public isCompatibleWith(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public setLevel(level: int): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         * @param {int} level 
         * @param {boolean} safe 
         */
        public setLevel(level: int,safe: boolean): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         */
        public getMaxEnchantableLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public static getRegisteredEnchantments(): java.util.Collection;
        /**
         * 
         * @param {int} id 
         */
        public static getEnchantment(id: int): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         * @param {int} id 
         */
        public static get(id: int): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public doPostAttack(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         */
        public static init(): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public doPostHurt(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getMaxLevel(): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} event 
         */
        public getProtectionFactor(event: cn.nukkit.event.entity.EntityDamageEvent): float;
        /**
         * 
         */
        public static getEnchantments(): cn.nukkit.item.enchantment.Enchantment[];
        /**
         * 
         */
        public getLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getMinLevel(): int;
        /**
         * 
         */
        protected  clone(): java.lang.Object;
        /**
         * 
         */
        protected clone(): cn.nukkit.item.enchantment.Enchantment;
        /**
         * 
         */
        public isMajor(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        protected checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double;
    }
}
declare namespace cn.nukkit.network.protocol{
     class CodeBuilderPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        isOpening: boolean;
        /**  */
        url: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityEnchantTable extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public hasName(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
    }
}
declare namespace cn.nukkit.utils{
    abstract class ZlibProvider extends java.lang.Object{
        /**
         * 
         * @param {byte[]} data 
         * @param {int} level 
         */
        public abstract deflate(data: byte[],level: int): byte[];
        /**
         * 
         * @param {byte[][]} data 
         * @param {int} level 
         */
        public abstract deflate(data: byte[][],level: int): byte[];
        /**
         * 
         * @param {byte[]} data 
         * @param {int} maxSize 
         */
        public abstract inflate(data: byte[],maxSize: int): byte[];
    }
}
declare namespace cn.nukkit.permission{
     class BanList extends java.lang.Object{
        /**  */
        file: java.lang.String;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        enable: boolean;
        /**  */
        list: java.util.LinkedHashMap;
        /**
         * 
         * @param {cn.nukkit.permission.BanEntry} entry 
         */
        public add(entry: cn.nukkit.permission.BanEntry): void;
        /**
         * 
         */
        public load(): void;
        /**
         * 
         * @param {boolean} enable 
         */
        public setEnable(enable: boolean): void;
        /**
         * 
         */
        public getEntires(): java.util.LinkedHashMap;
        /**
         * 
         */
        public save(): void;
        /**
         * 
         */
        public removeExpired(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isBanned(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} target 
         * @param {java.lang.String} reason 
         * @param {java.util.Date} expireDate 
         * @param {java.lang.String} source 
         */
        public addBan(target: java.lang.String,reason: java.lang.String,expireDate: java.util.Date,source: java.lang.String): cn.nukkit.permission.BanEntry;
        /**
         * 
         * @param {java.lang.String} target 
         * @param {java.lang.String} reason 
         * @param {java.util.Date} expireDate 
         */
        public addBan(target: java.lang.String,reason: java.lang.String,expireDate: java.util.Date): cn.nukkit.permission.BanEntry;
        /**
         * 
         * @param {java.lang.String} target 
         */
        public addBan(target: java.lang.String): cn.nukkit.permission.BanEntry;
        /**
         * 
         * @param {java.lang.String} target 
         * @param {java.lang.String} reason 
         */
        public addBan(target: java.lang.String,reason: java.lang.String): cn.nukkit.permission.BanEntry;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public remove(name: java.lang.String): void;
        /**
         * 
         */
        public isEnable(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedOrange extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.inventory{
     class RecipeType extends java.lang.Enum{
        /**  */
        BLAST_FURNACE: cn.nukkit.inventory.RecipeType;
        /**  */
        CAMPFIRE: cn.nukkit.inventory.RecipeType;
        /**  */
        SMOKER: cn.nukkit.inventory.RecipeType;
        /**  */
        SHAPED_CHEMISTRY: cn.nukkit.inventory.RecipeType;
        /**  */
        SMITHING: cn.nukkit.inventory.RecipeType;
        /**  */
        SMOKER_DATA: cn.nukkit.inventory.RecipeType;
        /**  */
        FURNACE: cn.nukkit.inventory.RecipeType;
        /**  */
        REPAIR: cn.nukkit.inventory.RecipeType;
        /**  */
        SHAPED: cn.nukkit.inventory.RecipeType;
        /**  */
        CAMPFIRE_DATA: cn.nukkit.inventory.RecipeType;
        /**  */
        STONECUTTER: cn.nukkit.inventory.RecipeType;
        /**  */
        SHAPELESS: cn.nukkit.inventory.RecipeType;
        /**  */
        FURNACE_DATA: cn.nukkit.inventory.RecipeType;
        /**  */
        SHULKER_BOX: cn.nukkit.inventory.RecipeType;
        /**  */
        SHAPELESS_CHEMISTRY: cn.nukkit.inventory.RecipeType;
        /**  */
        networkType: int;
        /**  */
        MULTI: cn.nukkit.inventory.RecipeType;
        /**  */
        BLAST_FURNACE_DATA: cn.nukkit.inventory.RecipeType;
        /**  */
        $VALUES: cn.nukkit.inventory.RecipeType[];
        /**  */
        CARTOGRAPHY: cn.nukkit.inventory.RecipeType;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.inventory.RecipeType;
        /**
         * 
         */
        public static values(): cn.nukkit.inventory.RecipeType[];
    }
}
declare namespace cn.nukkit.command.defaults{
     class PluginsCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         */
        private sendPluginList(sender: cn.nukkit.command.CommandSender): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordBlocks extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemGlowstoneDust extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.event.block{
     class BlockFadeEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        newState: cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewState(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ItemFrameDropItemPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item.enchantment.damage{
     class EnchantmentDamageArthropods extends cn.nukkit.item.enchantment.damage.EnchantmentDamage{
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public doPostAttack(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemBowl extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorSmallMushroom extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemEmerald extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorDarkOak extends cn.nukkit.block.BlockDoorWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockFlowerPot extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getFlower(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setFlower(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} id 
         */
        protected static canPlaceIntoFlowerPot(id: int): boolean;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public removeFlower(): void;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityItemFrame extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getItemRotation(): int;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public dropItemAndGetEntity(player: cn.nukkit.Player): cn.nukkit.entity.item.EntityItem;
        /**
         * 
         */
        public setDirty(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public dropItem(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getAnalogOutput(): int;
        /**
         * 
         */
        public getItemDropChance(): float;
        /**
         * 
         * @param {float} chance 
         */
        public setItemDropChance(chance: float): void;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {int} itemRotation 
         */
        public setItemRotation(itemRotation: int): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} setChanged 
         */
        public setItem(item: cn.nukkit.item.Item,setChanged: boolean): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(item: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityPanda extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockIgniteEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        cause: cn.nukkit.event.block.BlockIgniteEvent.BlockIgniteCause;
        /**  */
        source: cn.nukkit.block.Block;
        /**  */
        entity: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSource(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getCause(): cn.nukkit.event.block.BlockIgniteEvent.BlockIgniteCause;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace algorithm{
    /**
     * 从玩家构建坐标对象
     * @param {cn.nukkit.Player} player 从哪个玩家
     */
    function buildPositionfromPlayer(player: cn.nukkit.Player): cn.nukkit.level.Position;
    /**
     * 从实体构建坐标对象
     * @param {cn.nukkit.entity.Entity} entity 从哪个实体
     */
    function buildPositionfromEntity(entity: cn.nukkit.entity.Entity): cn.nukkit.level.Position;
    /**
     * 从方块构建坐标对象
     * @param {cn.nukkit.block.Block} block 从哪个方块
     */
    function buildPositionfromBlock(block: cn.nukkit.block.Block): cn.nukkit.level.Position;
    /**
     * 为a到b位置的所有方块执行回调函数
     * @param {cn.nukkit.level.Position} a 起点
     * @param {cn.nukkit.level.Position} b 终点
     * @param {boolean} isair 是否为空气方块也执行回调函数
     * @param {java.lang.String} callback 回调函数名，参数(cn.nukkit.Block)
     */
    function forEachBlockInArea(a: cn.nukkit.level.Position,b: cn.nukkit.level.Position,isair: boolean,callback: Fun1<cn.nukkit.block.Block>): void;
    /**
     * 为指定坐标相邻的同种方块及相邻同种方块的相邻同种方块执行回调函数
     * @param {cn.nukkit.level.Position} a 指定坐标
     * @param {java.lang.String} callback 回调函数，参数(cn.nukkit.level.Position)
     */
    function forLinkedBlock(a: cn.nukkit.level.Position,callback: Fun1<cn.nukkit.level.Position>): void;
    /**
     * forLinkedBlock(cn.nukkit.level.Position,java.lang.String)的递归函数
     * @param {int} x 
     * @param {int} y 
     * @param {int} z 
     * @param {java.lang.String} callback 
     * @param {int} step 
     * @param {cn.nukkit.level.Level} level 
     * @param {int} id 
     */
    function forLinkedBlock(x: int,y: int,z: int,callback: java.lang.String,step: int,level: cn.nukkit.level.Level,id: int): void;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 通过xyz和世界构建坐标对象
     * @param {double} x x
     * @param {double} y y
     * @param {double} z z
     * @param {cn.nukkit.level.Level} level 世界
     */
    function buildPosition(x: double,y: double,z: double,level: cn.nukkit.level.Level): cn.nukkit.level.Position;
    /**
     * xyz转字符串
     * @param {int} x 
     * @param {int} y 
     * @param {int} z 
     */
    function posinttostr(x: int,y: int,z: int): java.lang.String;
}
declare namespace cn.nukkit.block{
     class BlockStairsCobblestone extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class RainSplashParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
     class BlockLapis extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreLapis extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemPickaxeWood extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment.trident{
     class EnchantmentTridentImpaling extends cn.nukkit.item.enchantment.trident.EnchantmentTrident{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerJumpEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentEfficiency extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemBrick extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.network.protocol{
     class LevelEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        EVENT_SOUND_BLAZE_SHOOT: int;
        /**  */
        data: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        EVENT_PARTICLE_WAX_ON: int;
        /**  */
        EVENT_SOUND_ITEM_FRAME_ITEM_ROTATED: int;
        /**  */
        EVENT_PLAYERS_SLEEPING: int;
        /**  */
        EVENT_SOUND_INK_SACE_USED: int;
        /**  */
        EVENT_PARTICLE_VIBRATION_SIGNAL: int;
        /**  */
        EVENT_SOUND_GHAST: int;
        /**  */
        EVENT_SOUND_ENDERMAN_TELEPORT: int;
        /**  */
        EVENT_SOUND_TOTEM: int;
        /**  */
        EVENT_SOUND_SPLASH: int;
        /**  */
        EVENT_PARTICLE_EYE_DESPAWN: int;
        /**  */
        EVENT_PARTICLE_SPAWN: int;
        /**  */
        EVENT_SOUND_DOOR_BUMP: int;
        /**  */
        EVENT_SOUND_POINTED_DRIPSTONE_LAND: int;
        /**  */
        EVENT_PARTICLE_SCRAPE: int;
        /**  */
        EVENT_SOUND_DYE_USED: int;
        /**  */
        EVENT_START_RAIN: int;
        /**  */
        EVENT_SOUND_ITEM_FRAME_ITEM_REMOVED: int;
        /**  */
        evid: int;
        /**  */
        EVENT_PARTICLE_SHOOT: int;
        /**  */
        EVENT_SOUND_ARMOR_STAND_PLACE: int;
        /**  */
        EVENT_SOUND_BUTTON_CLICK: int;
        /**  */
        EVENT_PARTICLE_ENDERMAN_TELEPORT: int;
        /**  */
        EVENT_SOUND_ANVIL_BREAK: int;
        /**  */
        EVENT_SET_DATA: int;
        /**  */
        EVENT_PARTICLE_BONEMEAL: int;
        /**  */
        EVENT_CAULDRON_TAKE_POTION: int;
        /**  */
        EVENT_SOUND_CAULDRON_TAKE_POWDER_SNOW: int;
        /**  */
        EVENT_SOUND_GHAST_SHOOT: int;
        /**  */
        EVENT_SOUND_TNT: int;
        /**  */
        EVENT_STOP_THUNDER: int;
        /**  */
        EVENT_BLOCK_STOP_BREAK: int;
        /**  */
        EVENT_SOUND_ARMOR_STAND_FALL: int;
        /**  */
        EVENT_PARTICLE_FIZZ_EFFECT: int;
        /**  */
        EVENT_PARTICLE_DRIPSTONE_DRIP: int;
        /**  */
        EVENT_SOUND_ITEM_DROP: int;
        /**  */
        EVENT_SOUND_CAULDRON_DYE_ARMOR: int;
        /**  */
        EVENT_CAULDRON_FILL_POTION: int;
        /**  */
        EVENT_STOP_RAIN: int;
        /**  */
        EVENT_SOUND_CAULDRON_FILL_POTION: int;
        /**  */
        EVENT_SOUND_CAULDRON_FILL_WATER: int;
        /**  */
        EVENT_GUARDIAN_CURSE: int;
        /**  */
        EVENT_PARTICLE_PUNCH_BLOCK: int;
        /**  */
        EVENT_CAULDRON_CLEAN_BANNER: int;
        /**  */
        EVENT_START_THUNDER: int;
        /**  */
        EVENT_SOUND_EXPERIENCE_ORB: int;
        /**  */
        EVENT_CAULDRON_DYE_ARMOR: int;
        /**  */
        EVENT_PARTICLE_BLOCK_FORCE_FIELD: int;
        /**  */
        EVENT_CAULDRON_CLEAN_ARMOR: int;
        /**  */
        EVENT_SOUND_ITEM_FRAME_PLACED: int;
        /**  */
        EVENT_PARTICLE_ELECTRIC_SPARK: int;
        /**  */
        EVENT_SOUND_CLICK_FAIL: int;
        /**  */
        EVENT_SOUND_DOOR_CRASH: int;
        /**  */
        EVENT_SOUND_ITEM_THROWN: int;
        /**  */
        EVENT_CAULDRON_ADD_DYE: int;
        /**  */
        EVENT_SOUND_CAULDRON_FILL_POWDER_SNOW: int;
        /**  */
        EVENT_ADD_PARTICLE_MASK: int;
        /**  */
        EVENT_PARTICLE_DESTROY: int;
        /**  */
        EVENT_PARTICLE_PROJECTILE_HIT: int;
        /**  */
        EVENT_SOUND_FIZZ: int;
        /**  */
        EVENT_SOUND_CAMERA_TAKE_PICTURE: int;
        /**  */
        EVENT_SOUND_SHOOT: int;
        /**  */
        EVENT_SOUND_ARMOR_STAND_BREAK: int;
        /**  */
        EVENT_SOUND_ARMOR_STAND_HIT: int;
        /**  */
        EVENT_SOUND_ITEM_FRAME_REMOVED: int;
        /**  */
        EVENT_PARTICLE_DRAGON_EGG_TELEPORT: int;
        /**  */
        EVENT_SOUND_ANVIL_USE: int;
        /**  */
        EVENT_BLOCK_START_BREAK: int;
        /**  */
        EVENT_PARTICLE_SPLASH: int;
        /**  */
        EVENT_SOUND_CLICK: int;
        /**  */
        EVENT_CAULDRON_TAKE_WATER: int;
        /**  */
        EVENT_SOUND_ANVIL_FALL: int;
        /**  */
        EVENT_SOUND_CAULDRON: int;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        EVENT_PARTICLE_WAX_OFF: int;
        /**  */
        EVENT_SOUND_DOOR: int;
        /**  */
        EVENT_SOUND_ITEM_FRAME_ITEM_ADDED: int;
        /**  */
        EVENT_SOUND_PORTAL: int;
        /**  */
        EVENT_SOUND_EXPLODE: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedGray extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.util{
     class Pow2BitArray extends java.lang.Object{
        /**  */
        size: int;
        /**  */
        words: int[];
        /**  */
        version: cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         */
        public getVersion(): cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         * @param {int} index 
         * @param {int} value 
         */
        public set(index: int,value: int): void;
        /**
         * 
         */
        public size(): int;
        /**
         * 
         * @param {int} index 
         */
        public get(index: int): int;
        /**
         * 
         */
        public copy(): cn.nukkit.level.util.BitArray;
        /**
         * 
         */
        public getWords(): int[];
    }
}
declare namespace cn.nukkit.entity.weather{
    abstract class EntityWeather extends java.lang.Object{
    }
}
declare namespace cn.nukkit.item{
     class ItemAppleGold extends cn.nukkit.item.ItemEdible{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.blockentity{
    abstract class BlockEntityContainer extends java.lang.Object{
        /**
         * 
         */
        public abstract getSize(): int;
        /**
         * 
         * @param {int} index 
         */
        public abstract getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         */
        public abstract setItem(index: int,item: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemMap extends cn.nukkit.item.Item{
        /**  */
        image: java.awt.image.BufferedImage;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        mapCount: int;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getMapId(): long;
        /**
         * 
         */
        protected loadImageFromNBT(): java.awt.image.BufferedImage;
        /**
         * 
         * @param {cn.nukkit.Player} p 
         */
        public sendImage(p: cn.nukkit.Player): void;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {java.awt.image.BufferedImage} image 
         */
        public setImage(image: java.awt.image.BufferedImage): void;
        /**
         * 
         * @param {java.io.File} file 
         */
        public setImage(file: java.io.File): void;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentType extends java.lang.Enum{
        /**  */
        ALL: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        ARMOR_HEAD: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        BREAKABLE: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        ARMOR: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        ARMOR_LEGS: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        FISHING_ROD: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        SWORD: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        BOW: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        ARMOR_FEET: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        TRIDENT: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        WEARABLE: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        ARMOR_TORSO: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        DIGGER: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        CROSSBOW: cn.nukkit.item.enchantment.EnchantmentType;
        /**  */
        $VALUES: cn.nukkit.item.enchantment.EnchantmentType[];
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.item.enchantment.EnchantmentType;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchantItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public static values(): cn.nukkit.item.enchantment.EnchantmentType[];
    }
}
declare namespace cn.nukkit.block{
     class BlockSlabStone extends cn.nukkit.block.BlockSlab{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        SANDSTONE: int;
        /**  */
        WOODEN: int;
        /**  */
        COBBLESTONE: int;
        /**  */
        BRICK: int;
        /**  */
        NETHER_BRICK: int;
        /**  */
        STONE: int;
        /**  */
        STONE_BRICK: int;
        /**  */
        QUARTZ: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.block.BlockSlab} slab 
         */
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getSlabName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.StoneSlab1Type} type 
         */
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab1Type): void;
        /**
         * 
         */
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab1Type;
    }
}
declare namespace cn.nukkit{
     class Player extends cn.nukkit.entity.EntityHuman{
        /**  */
        SURVIVAL: int;
        /**  */
        achievements: java.util.HashSet;
        /**  */
        clientID: java.lang.Long;
        /**  */
        hiddenPlayers: java.util.Map;
        /**  */
        delayedPosTrackingUpdate: cn.nukkit.scheduler.TaskHandler;
        /**  */
        iusername: java.lang.String;
        /**  */
        breakingBlock: cn.nukkit.block.Block;
        /**  */
        CRAFTING_CARTOGRAPHY: int;
        /**  */
        smithingTransaction: cn.nukkit.inventory.transaction.SmithingTransaction;
        /**  */
        formWindowCount: int;
        /**  */
        gamemode: int;
        /**  */
        adventureSettings: cn.nukkit.AdventureSettings;
        /**  */
        wasInSoulSandCompatible: boolean;
        /**  */
        killer: cn.nukkit.entity.Entity;
        /**  */
        exp: int;
        /**  */
        buttonText: java.lang.String;
        /**  */
        PERMISSION_CUSTOM: int;
        /**  */
        playerUIInventory: cn.nukkit.inventory.PlayerUIInventory;
        /**  */
        randomClientId: long;
        /**  */
        startAction: int;
        /**  */
        shouldLogin: boolean;
        /**  */
        windowIndex: com.google.common.collect.BiMap;
        /**  */
        serverSettings: java.util.Map;
        /**  */
        CRAFTING_BIG: int;
        /**  */
        enchantTransaction: cn.nukkit.inventory.transaction.EnchantTransaction;
        /**  */
        craftingTransaction: cn.nukkit.inventory.transaction.CraftingTransaction;
        /**  */
        loggedIn: boolean;
        /**  */
        removeFormat: boolean;
        /**  */
        SMITHING_WINDOW_ID: int;
        /**  */
        interfaz: cn.nukkit.network.SourceInterface;
        /**  */
        chunkLoadCount: int;
        /**  */
        stepHeight: float;
        /**  */
        viewDistance: int;
        /**  */
        hash: int;
        /**  */
        spawned: boolean;
        /**  */
        enableClientCommand: boolean;
        /**  */
        CRAFTING_ENCHANT: int;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        EMPTY_ARRAY: cn.nukkit.Player[];
        /**  */
        spawnThreshold: int;
        /**  */
        displayName: java.lang.String;
        /**  */
        DEFAULT_SPEED: float;
        /**  */
        ADVENTURE: int;
        /**  */
        windowCnt: int;
        /**  */
        closingWindowId: int;
        /**  */
        lastSkinChange: long;
        /**  */
        timeSinceRest: int;
        /**  */
        lastEnderPearl: int;
        /**  */
        MAXIMUM_SPEED: float;
        /**  */
        expLevel: int;
        /**  */
        lastPlayerdLevelUpSoundTime: int;
        /**  */
        viewingEnderChest: cn.nukkit.block.BlockEnderChest;
        /**  */
        grindstoneTransaction: cn.nukkit.inventory.transaction.GrindstoneTransaction;
        /**  */
        SPECTATOR: int;
        /**  */
        CRAFTING_ANVIL: int;
        /**  */
        permanentWindows: java.util.Set;
        /**  */
        startAirTicks: int;
        /**  */
        lastRightClickPos: cn.nukkit.math.Vector3;
        /**  */
        CRAFTING_GRINDSTONE: int;
        /**  */
        checkMovement: boolean;
        /**  */
        lastBreak: long;
        /**  */
        connected: boolean;
        /**  */
        lastRightClickTime: double;
        /**  */
        dummyBossBars: java.util.Map;
        /**  */
        pickedXPOrb: int;
        /**  */
        lastChorusFruitTeleport: int;
        /**  */
        teleportPosition: cn.nukkit.math.Vector3;
        /**  */
        loaderId: int;
        /**  */
        CREATIVE: int;
        /**  */
        PERMISSION_OPERATOR: int;
        /**  */
        soulSpeedMultiplier: float;
        /**  */
        VIEW: int;
        /**  */
        PERMISSION_VISITOR: int;
        /**  */
        newPosition: cn.nukkit.math.Vector3;
        /**  */
        loginChainData: cn.nukkit.utils.LoginChainData;
        /**  */
        clientSecret: java.lang.String;
        /**  */
        usedChunks: java.util.Map;
        /**  */
        CREATIVE_SLOTS: int;
        /**  */
        forceMovement: cn.nukkit.math.Vector3;
        /**  */
        spawnBlockPosition: cn.nukkit.math.Vector3;
        /**  */
        chunkRadius: int;
        /**  */
        ENCHANT_WINDOW_ID: int;
        /**  */
        lastBreakPosition: cn.nukkit.math.BlockVector3;
        /**  */
        CRAFTING_SMALL: int;
        /**  */
        repairItemTransaction: cn.nukkit.inventory.transaction.RepairItemTransaction;
        /**  */
        ANVIL_WINDOW_ID: int;
        /**  */
        chunksPerTick: int;
        /**  */
        craftingGrid: cn.nukkit.inventory.CraftingGrid;
        /**  */
        playedBefore: boolean;
        /**  */
        craftingType: int;
        /**  */
        SURVIVAL_SLOTS: int;
        /**  */
        foodData: cn.nukkit.PlayerFood;
        /**  */
        noShieldTicks: int;
        /**  */
        creationTime: long;
        /**  */
        nextChunkOrderRun: int;
        /**  */
        perm: cn.nukkit.permission.PermissibleBase;
        /**  */
        loadQueue: it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
        /**  */
        CRAFTING_STONECUTTER: int;
        /**  */
        BEACON_WINDOW_ID: int;
        /**  */
        GRINDSTONE_WINDOW_ID: int;
        /**  */
        locale: java.util.concurrent.atomic.AtomicReference;
        /**  */
        speed: cn.nukkit.math.Vector3;
        /**  */
        sleeping: cn.nukkit.math.Vector3;
        /**  */
        inventoryOpen: boolean;
        /**  */
        messageCounter: int;
        /**  */
        socketAddress: java.net.InetSocketAddress;
        /**  */
        foodEnabled: boolean;
        /**  */
        PERMISSION_MEMBER: int;
        /**  */
        formWindows: java.util.Map;
        /**  */
        fishing: cn.nukkit.entity.item.EntityFishingHook;
        /**  */
        CRAFTING_SMITHING: int;
        /**  */
        inAirTicks: int;
        /**  */
        windows: com.google.common.collect.BiMap;
        /**  */
        spawnPosition: cn.nukkit.level.Position;
        /**  */
        CRAFTING_BEACON: int;
        /**  */
        locallyInitialized: boolean;
        /**  */
        preLoginEventTask: cn.nukkit.scheduler.AsyncTask;
        /**  */
        NO_SHIELD_DELAY: int;
        /**  */
        username: java.lang.String;
        /**
         * 
         * @param {cn.nukkit.form.window.FormWindow} window 
         */
        public showFormWindow(window: cn.nukkit.form.window.FormWindow): int;
        /**
         * 
         * @param {cn.nukkit.form.window.FormWindow} window 
         * @param {int} id 
         */
        public showFormWindow(window: cn.nukkit.form.window.FormWindow,id: int): int;
        /**
         * 
         */
        public sendAttributes(): void;
        /**
         * 
         * @param {cn.nukkit.entity.data.EntityData} data 
         */
        public setDataProperty(data: cn.nukkit.entity.data.EntityData): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.data.EntityData} data 
         * @param {boolean} send 
         */
        public setDataProperty(data: cn.nukkit.entity.data.EntityData,send: boolean): boolean;
        /**
         * 
         * @param {float} speed 
         */
        public sendMovementSpeed(speed: float): void;
        /**
         * 
         * @param {int} level 
         */
        public static calculateRequireExperience(level: int): int;
        /**
         * 
         */
        public getAdventureSettings(): cn.nukkit.AdventureSettings;
        /**
         * 
         */
        public isEnableClientCommand(): boolean;
        /**
         * 
         * @param {java.lang.String} achievementId 
         */
        public hasAchievement(achievementId: java.lang.String): boolean;
        /**
         * 
         * @param {long} bossBarId 
         */
        public getDummyBossBar(bossBarId: long): cn.nukkit.utils.DummyBossBar;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public onChunkUnloaded(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         */
        public getSoulSpeedMultiplier(): float;
        /**
         * 
         */
        public isBanned(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public canSee(player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {java.lang.String} source 
         * @param {java.lang.String} message 
         */
        public sendWhisper(source: java.lang.String,message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendWhisper(message: java.lang.String): void;
        /**
         * 
         */
        public getEffectivePermissions(): java.util.Map;
        /**
         * 
         */
        public hasAutoJump(): boolean;
        /**
         * 
         */
        public startAction(): void;
        /**
         * 
         * @param {int} exp 
         */
        public setExperience(exp: int): void;
        /**
         * 
         * @param {int} exp 
         * @param {int} level 
         * @param {boolean} playLevelUpSound 
         */
        public setExperience(exp: int,level: int,playLevelUpSound: boolean): void;
        /**
         * 
         * @param {int} exp 
         * @param {int} level 
         */
        public setExperience(exp: int,level: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public setMotion(motion: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getKiller(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         * @param {double} movX 
         * @param {double} movY 
         * @param {double} movZ 
         * @param {double} dx 
         * @param {double} dy 
         * @param {double} dz 
         */
        protected checkGroundState(movX: double,movY: double,movZ: double,dx: double,dy: double,dz: double): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {int} fadein 
         * @param {int} duration 
         * @param {int} fadeout 
         */
        public setTitleAnimationTimes(fadein: int,duration: int,fadeout: int): void;
        /**
         * 
         */
        public isUsingItem(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public hasPermission(name: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         */
        public getTimeSinceRest(): int;
        /**
         * 
         */
        public getInAirTicks(): int;
        /**
         * 
         */
        public onThrowEnderPearl(): void;
        /**
         * 
         * @param {int} gamemode 
         */
        public setGamemode(gamemode: int): boolean;
        /**
         * 
         * @param {int} gamemode 
         * @param {boolean} clientSide 
         */
        public setGamemode(gamemode: int,clientSide: boolean): boolean;
        /**
         * 
         * @param {int} gamemode 
         * @param {boolean} clientSide 
         * @param {cn.nukkit.AdventureSettings} newSettings 
         */
        public setGamemode(gamemode: int,clientSide: boolean,newSettings: cn.nukkit.AdventureSettings): boolean;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public onChunkChanged(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected isValidRespawnBlock(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        protected respawn(): void;
        /**
         * 
         * @param {java.lang.String} text 
         */
        public setButtonText(text: java.lang.String): void;
        /**
         * 
         */
        public getClientId(): java.lang.Long;
        /**
         * 
         */
        public checkNetwork(): void;
        /**
         * 
         */
        public getViewDistance(): int;
        /**
         * 
         */
        public getExperience(): int;
        /**
         * 
         * @param {boolean} permanent 
         */
        public removeAllWindows(permanent: boolean): void;
        /**
         * 
         */
        public removeAllWindows(): void;
        /**
         * 
         * @param {java.lang.String} xuid 
         */
        public showXboxProfile(xuid: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendPopupJukebox(message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {boolean} near 
         */
        public pickupEntity(entity: cn.nukkit.entity.Entity,near: boolean): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public setUsingItem(value: boolean): void;
        /**
         * 
         */
        public resetInAirTicks(): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} b 
         */
        private static lambda$checkBlockCollision$0(b: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.String} reason 
         * @param {boolean} notify 
         */
        public close(message: java.lang.String,reason: java.lang.String,notify: boolean): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public close(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.String} reason 
         */
        public close(message: java.lang.String,reason: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         */
        public close(message: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         * @param {java.lang.String} reason 
         */
        public close(message: cn.nukkit.lang.TextContainer,reason: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         * @param {java.lang.String} reason 
         * @param {boolean} notify 
         */
        public close(message: cn.nukkit.lang.TextContainer,reason: java.lang.String,notify: boolean): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public getUIInventory(): cn.nukkit.inventory.PlayerUIInventory;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public sleepOn(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        private lambda$onBlock$5(): void;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public onChunkLoaded(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         */
        public onChorusFruitTeleport(): void;
        /**
         * 
         */
        public getClientSecret(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendMessage(message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         */
        public sendMessage(message: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         */
        public getPing(): int;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public batchDataPacket(packet: cn.nukkit.network.protocol.DataPacket): boolean;
        /**
         * 
         * @param {cn.nukkit.permission.PermissionAttachment} attachment 
         */
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public setMetadata(metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         */
        protected checkNearEntities(): void;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerKickEvent.Reason} reason 
         * @param {boolean} isAdmin 
         */
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent.Reason,isAdmin: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerKickEvent.Reason} reason 
         * @param {java.lang.String} reasonString 
         * @param {boolean} isAdmin 
         */
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent.Reason,reasonString: java.lang.String,isAdmin: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerKickEvent.Reason} reason 
         * @param {java.lang.String} reasonString 
         */
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent.Reason,reasonString: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerKickEvent.Reason} reason 
         */
        public kick(reason: cn.nukkit.event.player.PlayerKickEvent.Reason): boolean;
        /**
         * 
         * @param {java.lang.String} reason 
         */
        public kick(reason: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} reason 
         * @param {boolean} isAdmin 
         */
        public kick(reason: java.lang.String,isAdmin: boolean): boolean;
        /**
         * 
         */
        public kick(): boolean;
        /**
         * 
         */
        public getSocketAddress(): java.net.InetSocketAddress;
        /**
         * 
         */
        public getAllowFlight(): boolean;
        /**
         * 
         * @param {int} timeSinceRest 
         */
        public setTimeSinceRest(timeSinceRest: int): void;
        /**
         * 
         */
        public getGamemode(): int;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getNoShieldTicks(): int;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingGrid} grid 
         */
        public setCraftingGrid(grid: cn.nukkit.inventory.CraftingGrid): void;
        /**
         * 
         */
        public isCheckingMovement(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected doFirstSpawn(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} block 
         */
        public onBlockChanged(block: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         * @param {java.lang.Boolean} value 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String,value: java.lang.Boolean): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         */
        public getDummyBossBars(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public dropItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        protected checkBlockCollision(): void;
        /**
         * 
         * @param {boolean} delayed 
         */
        public updateTrackingPositions(delayed: boolean): void;
        /**
         * 
         */
        public updateTrackingPositions(): void;
        /**
         * 
         */
        public isOp(): boolean;
        /**
         * 
         * @param {float} speed 
         * @param {boolean} send 
         */
        public setMovementSpeed(speed: float,send: boolean): void;
        /**
         * 
         * @param {float} speed 
         */
        public setMovementSpeed(speed: float): void;
        /**
         * 
         */
        protected forceSendEmptyChunks(): void;
        /**
         * 
         * @param {int} level 
         */
        public sendExperienceLevel(level: int): void;
        /**
         * 
         */
        public sendExperienceLevel(): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} fishingRod 
         */
        public startFishing(fishingRod: cn.nukkit.item.Item): void;
        /**
         * 
         */
        protected checkTeleportPosition(): boolean;
        /**
         * 
         */
        public sendExperience(): void;
        /**
         * 
         * @param {int} exp 
         */
        public sendExperience(exp: int): void;
        /**
         * 
         * @param {java.lang.String} text 
         */
        private setTitle(text: java.lang.String): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setAllowFlight(value: boolean): void;
        /**
         * 
         */
        public isFoodEnabled(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.data.Skin} skin 
         */
        public setSkin(skin: cn.nukkit.entity.data.Skin): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setAutoJump(value: boolean): void;
        /**
         * 
         * @param {java.lang.String} text 
         * @param {int} length 
         * @param {long} bossBarId 
         */
        public updateBossBar(text: java.lang.String,length: int,bossBarId: long): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {boolean} animate 
         */
        protected onBlock(entity: cn.nukkit.entity.Entity,animate: boolean): void;
        /**
         * 
         */
        public hasPlayedBefore(): boolean;
        /**
         * 
         */
        public getLastPlayed(): java.lang.Long;
        /**
         * 
         */
        public getStartActionTick(): int;
        /**
         * 
         */
        public resetFallDistance(): void;
        /**
         * 
         */
        public getLeaveMessage(): cn.nukkit.lang.TranslationContainer;
        /**
         * 
         */
        public getFirstPlayed(): java.lang.Long;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.String} subtitle 
         */
        public sendPopup(message: java.lang.String,subtitle: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendPopup(message: java.lang.String): void;
        /**
         * 
         * @param {int} status 
         * @param {boolean} immediate 
         */
        protected sendPlayStatus(status: int,immediate: boolean): void;
        /**
         * 
         * @param {int} status 
         */
        protected sendPlayStatus(status: int): void;
        /**
         * 
         * @param {java.lang.String} displayName 
         */
        public setDisplayName(displayName: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         */
        public removeWindow(inventory: cn.nukkit.inventory.Inventory): void;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         * @param {boolean} isResponse 
         */
        protected removeWindow(inventory: cn.nukkit.inventory.Inventory,isResponse: boolean): void;
        /**
         * 
         */
        public isWhitelisted(): boolean;
        /**
         * 
         */
        public getLastChorusFruitTeleport(): int;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public handleDataPacket(packet: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} items 
         */
        public  giveItem(...items: cn.nukkit.item.Item[]): void;
        /**
         * 
         * @param {cn.nukkit.entity.Attribute} attribute 
         */
        public setAttribute(attribute: cn.nukkit.entity.Attribute): void;
        /**
         * 
         */
        public getTopWindow(): java.util.Optional;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {int} tickDiff 
         */
        protected processMovement(tickDiff: int): void;
        /**
         * 
         */
        public getAddress(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} achievementId 
         */
        public removeAchievement(achievementId: java.lang.String): void;
        /**
         * 
         * @param {float} health 
         */
        public setHealth(health: float): void;
        /**
         * 
         */
        public getSpawn(): cn.nukkit.level.Position;
        /**
         * 
         * @param {int} id 
         */
        public getWindowById(id: int): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public sendCommandData(): void;
        /**
         * 
         * @param {int} tickDiff 
         */
        public entityBaseTick(tickDiff: int): boolean;
        /**
         * 
         */
        public isSleeping(): boolean;
        /**
         * 
         */
        public getButtonText(): java.lang.String;
        /**
         * 
         */
        public getNextPosition(): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isPermissionSet(name: java.lang.String): boolean;
        /**
         * 
         */
        public getFoodData(): cn.nukkit.PlayerFood;
        /**
         * 
         */
        public getCursorInventory(): cn.nukkit.inventory.PlayerCursorInventory;
        /**
         * 
         * @param {boolean} click 
         */
        public stopFishing(click: boolean): void;
        /**
         * 
         * @param {int} add 
         * @param {boolean} playLevelUpSound 
         */
        public addExperience(add: int,playLevelUpSound: boolean): void;
        /**
         * 
         * @param {int} add 
         */
        public addExperience(add: int): void;
        /**
         * 
         * @param {int} maxDistance 
         */
        public getEntityPlayerLookingAt(maxDistance: int): cn.nukkit.entity.EntityInteractable;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public onChunkPopulated(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendSystem(message: java.lang.String): void;
        /**
         * 
         */
        public setRemoveFormat(): void;
        /**
         * 
         * @param {boolean} remove 
         */
        public setRemoveFormat(remove: boolean): void;
        /**
         * 
         */
        public  getLocale(): java.util.Locale;
        /**
         * 
         * @param {boolean} value 
         */
        public setWhitelisted(value: boolean): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setAllowModifyWorld(value: boolean): void;
        /**
         * 
         */
        protected completeLoginSequence(): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public dataPacketImmediately(packet: cn.nukkit.network.protocol.DataPacket): boolean;
        /**
         * 
         */
        public recalculatePermissions(): void;
        /**
         * 
         * @param {java.lang.String} achievementId 
         */
        public awardAchievement(achievementId: java.lang.String): boolean;
        /**
         * 
         */
        public getCraftingGrid(): cn.nukkit.inventory.CraftingGrid;
        /**
         * 
         */
        public checkInteractNearby(): void;
        /**
         * 
         */
        protected checkChunks(): void;
        /**
         * 
         * @param {long} bossBarId 
         */
        public removeBossBar(bossBarId: long): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public directDataPacket(packet: cn.nukkit.network.protocol.DataPacket): boolean;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {boolean} needACK 
         */
        public directDataPacket(packet: cn.nukkit.network.protocol.DataPacket,needACK: boolean): int;
        /**
         * 
         */
        public getViewingEnderChest(): cn.nukkit.block.BlockEnderChest;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {int} maxHealth 
         */
        public setMaxHealth(maxHealth: int): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        static access$000(arg0: cn.nukkit.Player): java.util.UUID;
        /**
         * 
         */
        public stopAction(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public showPlayer(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getLastEnderPearlThrowingTick(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public setBanned(value: boolean): void;
        /**
         * 
         */
        public isSpectator(): boolean;
        /**
         * 
         */
        public getDisplayName(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} text 
         * @param {int} length 
         */
        public createBossBar(text: java.lang.String,length: int): long;
        /**
         * 
         * @param {cn.nukkit.utils.DummyBossBar} dummyBossBar 
         */
        public createBossBar(dummyBossBar: cn.nukkit.utils.DummyBossBar): long;
        /**
         * 
         */
        public doesTriggerPressurePlate(): boolean;
        /**
         * 
         * @param {cn.nukkit.AdventureSettings} adventureSettings 
         */
        public setAdventureSettings(adventureSettings: cn.nukkit.AdventureSettings): void;
        /**
         * 
         */
        protected addDefaultWindows(): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {boolean} needACK 
         */
        public dataPacket(packet: cn.nukkit.network.protocol.DataPacket,needACK: boolean): int;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public dataPacket(packet: cn.nukkit.network.protocol.DataPacket): boolean;
        /**
         * 
         * @param {int} gamemode 
         */
        private static getClientFriendlyGamemode(gamemode: int): int;
        /**
         * 
         * @param {cn.nukkit.level.Location} location 
         * @param {cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause} cause 
         */
        public teleportImmediate(location: cn.nukkit.level.Location,cause: cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause): void;
        /**
         * 
         * @param {cn.nukkit.level.Location} location 
         */
        public teleportImmediate(location: cn.nukkit.level.Location): void;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public sendTitle(title: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} subtitle 
         * @param {int} fadeIn 
         * @param {int} stay 
         * @param {int} fadeOut 
         */
        public sendTitle(title: java.lang.String,subtitle: java.lang.String,fadeIn: int,stay: int,fadeOut: int): void;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} subtitle 
         */
        public sendTitle(title: java.lang.String,subtitle: java.lang.String): void;
        /**
         * 
         */
        public save(): void;
        /**
         * 
         * @param {boolean} async 
         */
        public save(async: boolean): void;
        /**
         * 
         */
        public isConnected(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getLoginChainData(): cn.nukkit.utils.LoginChainData;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendChat(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} source 
         * @param {java.lang.String} message 
         */
        public sendChat(source: java.lang.String,message: java.lang.String): void;
        /**
         * 
         * @param {int} itemId 
         * @param {int} action 
         */
        public completeUsingItem(itemId: int,action: int): void;
        /**
         * 
         * @param {int} dimension 
         */
        private setDimension(dimension: int): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendAnnouncement(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} source 
         * @param {java.lang.String} message 
         */
        public sendAnnouncement(source: java.lang.String,message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} subtitle 
         */
        public setSubtitle(subtitle: java.lang.String): void;
        /**
         * 
         */
        private updateBlockingFlag(): void;
        /**
         * 
         * @param {boolean} foodEnabled 
         */
        public setFoodEnabled(foodEnabled: boolean): void;
        /**
         * 
         * @param {boolean} checkMovement 
         */
        public setCheckMovement(checkMovement: boolean): void;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$handleDataPacket$1(field: java.lang.reflect.Field): boolean;
        /**
         * 
         */
        public sendSettings(): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {java.lang.reflect.Field} field 
         */
        private static lambda$handleDataPacket$2(packet: cn.nukkit.network.protocol.DataPacket,field: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        static access$100(arg0: cn.nukkit.Player): cn.nukkit.utils.LoginChainData;
        /**
         * 
         * @param {java.lang.String} name 
         */
        private static lambda$handleDataPacket$3(name: java.lang.String): java.lang.String;
        /**
         * 
         * @param {boolean} value 
         */
        public setOp(value: boolean): void;
        /**
         * 
         * @param {java.lang.Integer} id 
         * @param {cn.nukkit.form.window.FormWindow} window 
         */
        private lambda$handleDataPacket$4(id: java.lang.Integer,window: cn.nukkit.form.window.FormWindow): void;
        /**
         * 
         */
        public getClosingWindowId(): int;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         */
        public switchLevel(level: cn.nukkit.level.Level): boolean;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public hasMetadata(metadataKey: java.lang.String): boolean;
        /**
         * 
         */
        public kill(): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {int} subChunkCount 
         * @param {byte[]} payload 
         */
        public static getChunkCacheFromData(chunkX: int,chunkZ: int,subChunkCount: int,payload: byte[]): cn.nukkit.network.protocol.BatchPacket;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public sendPosition(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {int} mode 
         * @param {cn.nukkit.Player[]} targets 
         */
        public sendPosition(pos: cn.nukkit.math.Vector3,yaw: double,pitch: double,mode: int,targets: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {int} mode 
         */
        public sendPosition(pos: cn.nukkit.math.Vector3,yaw: double,pitch: double,mode: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} yaw 
         * @param {double} pitch 
         */
        public sendPosition(pos: cn.nukkit.math.Vector3,yaw: double,pitch: double): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} yaw 
         */
        public sendPosition(pos: cn.nukkit.math.Vector3,yaw: double): void;
        /**
         * 
         */
        public getPort(): int;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public chat(message: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public isLoaderActive(): boolean;
        /**
         * 
         * @param {cn.nukkit.form.window.FormWindow} window 
         */
        public addServerSettings(window: cn.nukkit.form.window.FormWindow): int;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {int} fadein 
         * @param {int} duration 
         * @param {int} fadeout 
         */
        public sendActionBar(title: java.lang.String,fadein: int,duration: int,fadeout: int): void;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public sendActionBar(title: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.String[]} parameters 
         */
        public sendTranslation(message: java.lang.String,parameters: java.lang.String[]): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendTranslation(message: java.lang.String): void;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         * @param {boolean} enable 
         */
        public setEnableClientCommand(enable: boolean): void;
        /**
         * 
         */
        public stopSleep(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setSpawn(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        public getRemoveFormat(): boolean;
        /**
         * 
         */
        public sendAllInventories(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public hidePlayer(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {boolean} value 
         * @param {boolean} containers 
         */
        public setAllowInteract(value: boolean,containers: boolean): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setAllowInteract(value: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} maxDistance 
         */
        public canInteract(pos: cn.nukkit.math.Vector3,maxDistance: double): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} maxDistance 
         * @param {double} maxDiff 
         */
        public canInteract(pos: cn.nukkit.math.Vector3,maxDistance: double,maxDiff: double): boolean;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public getMetadata(metadataKey: java.lang.String): java.util.List;
        /**
         * 
         * @param {cn.nukkit.entity.Entity[]} nearbyEntities 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private getEntityAtPosition(nearbyEntities: cn.nukkit.entity.Entity[],x: int,y: int,z: int): cn.nukkit.entity.EntityInteractable;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        static access$200(arg0: cn.nukkit.Player): cn.nukkit.Server;
        /**
         * 
         */
        public resetCraftingGridType(): void;
        /**
         * 
         */
        protected orderChunks(): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         */
        public addWindow(inventory: cn.nukkit.inventory.Inventory): int;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         * @param {java.lang.Integer} forceId 
         */
        public addWindow(inventory: cn.nukkit.inventory.Inventory,forceId: java.lang.Integer): int;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         * @param {java.lang.Integer} forceId 
         * @param {boolean} isPermanent 
         */
        public addWindow(inventory: cn.nukkit.inventory.Inventory,forceId: java.lang.Integer,isPermanent: boolean): int;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         * @param {java.lang.Integer} forceId 
         * @param {boolean} isPermanent 
         * @param {boolean} alwaysOpen 
         */
        public addWindow(inventory: cn.nukkit.inventory.Inventory,forceId: java.lang.Integer,isPermanent: boolean,alwaysOpen: boolean): int;
        /**
         * 
         * @param {java.net.InetSocketAddress} address 
         */
        public transfer(address: java.net.InetSocketAddress): void;
        /**
         * 
         */
        public clearTitle(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setSprinting(value: boolean): void;
        /**
         * 
         * @param {java.util.Locale} locale 
         */
        public  setLocale(locale: java.util.Locale): void;
        /**
         * 
         */
        public isPlayer(): boolean;
        /**
         * 
         */
        public isCreative(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {int} subChunkCount 
         * @param {byte[]} payload 
         */
        public sendChunk(x: int,z: int,subChunkCount: int,payload: byte[]): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public sendChunk(x: int,z: int,packet: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         */
        protected sendNextChunk(): void;
        /**
         * 
         * @param {cn.nukkit.block.BlockEnderChest} chest 
         */
        public setViewingEnderChest(chest: cn.nukkit.block.BlockEnderChest): void;
        /**
         * 
         * @param {cn.nukkit.level.Location} location 
         * @param {cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause} cause 
         */
        public teleport(location: cn.nukkit.level.Location,cause: cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause): boolean;
        /**
         * 
         */
        public isOnline(): boolean;
        /**
         * 
         */
        public isBreakingBlock(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public dropAndGetItem(item: cn.nukkit.item.Item): cn.nukkit.entity.item.EntityItem;
        /**
         * 
         * @param {int} noShieldTicks 
         */
        public setNoShieldTicks(noShieldTicks: int): void;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {double} headYaw 
         */
        public addMovement(x: double,y: double,z: double,yaw: double,pitch: double,headYaw: double): void;
        /**
         * 
         */
        public getExperienceLevel(): int;
        /**
         * 
         */
        public getSpawnBlock(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public isSurvival(): boolean;
        /**
         * 
         */
        public isAdventure(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} spawnBlock 
         */
        public setSpawnBlock(spawnBlock: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        public getLoaderId(): int;
        /**
         * 
         */
        public resetTitleSettings(): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendTip(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public removeMetadata(metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         */
        protected processLogin(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public unloadChunk(x: int,z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.Level} level 
         */
        public unloadChunk(x: int,z: int,level: cn.nukkit.level.Level): void;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         * @param {java.lang.String} ip 
         * @param {int} port 
         */
        private static uncheckedNewInetSocketAddress(ip: java.lang.String,port: int): java.net.InetSocketAddress;
        /**
         * 
         * @param {int} distance 
         */
        public setViewDistance(distance: int): void;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         */
        public getWindowId(inventory: cn.nukkit.inventory.Inventory): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ResourcePackStackPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        resourcePackStack: cn.nukkit.resourcepacks.ResourcePack[];
        /**  */
        mustAccept: boolean;
        /**  */
        isExperimental: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        behaviourPackStack: cn.nukkit.resourcepacks.ResourcePack[];
        /**  */
        gameVersion: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerListPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        entries: cn.nukkit.network.protocol.PlayerListPacket.Entry[];
        /**  */
        NETWORK_ID: byte;
        /**  */
        TYPE_ADD: byte;
        /**  */
        type: byte;
        /**  */
        TYPE_REMOVE: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemChestplateChain extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemSeedsWheat extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.resourcepacks{
    abstract class ResourcePack extends java.lang.Object{
        /**  */
        EMPTY_ARRAY: cn.nukkit.resourcepacks.ResourcePack[];
        /**
         * 
         */
        public abstract getPackId(): java.util.UUID;
        /**
         * 
         */
        public abstract getPackVersion(): java.lang.String;
        /**
         * 
         */
        public abstract getPackSize(): int;
        /**
         * 
         */
        public abstract getSha256(): byte[];
        /**
         * 
         */
        public abstract getPackName(): java.lang.String;
        /**
         * 
         * @param {int} off 
         * @param {int} len 
         */
        public abstract getPackChunk(off: int,len: int): byte[];
    }
}
declare namespace com.blocklynukkit.loader.script.window{
     class Custom extends java.lang.Object{
        /**  */
        previousElement: cn.nukkit.form.element.Element;
        /**  */
        elementMap: java.util.LinkedHashMap;
        /**  */
        id: int;
        /**  */
        title: java.lang.String;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} placeholder 
         * @param {java.lang.String} defaulttext 
         */
        public buildInput(title: java.lang.String,placeholder: java.lang.String,defaulttext: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} placeholder 
         */
        public buildInput(title: java.lang.String,placeholder: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {double} min 
         * @param {double} max 
         * @param {int} step 
         */
        public slider(title: java.lang.String,min: double,max: double,step: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {double} min 
         * @param {double} max 
         * @param {int} step 
         * @param {double} defaultvalue 
         */
        public slider(title: java.lang.String,min: double,max: double,step: int,defaultvalue: double): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {double} min 
         * @param {double} max 
         */
        public slider(title: java.lang.String,min: double,max: double): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {boolean} open 
         */
        public buildToggle(title: java.lang.String,open: boolean): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public buildToggle(title: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} callback 
         */
        public setAction(callback: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} text 
         */
        public buildLabel(text: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         */
        public show(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public show(p: cn.nukkit.Player,callback: java.lang.String,acceptClose: boolean): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {boolean} accpetClose 玩家关闭窗口是否触发回调
         */
        public show(p: cn.nukkit.Player,accpetClose: boolean): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         */
        public show(p: cn.nukkit.Player): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} inner 
         * @param {int} index 
         */
        public buildDropdown(title: java.lang.String,inner: java.lang.String,index: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} inner 
         */
        public buildDropdown(title: java.lang.String,inner: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 设置窗口标题
         * @param {java.lang.String} title 窗口标题
         */
        public setTitle(title: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {boolean} open 
         */
        public toggle(title: java.lang.String,open: boolean): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public toggle(title: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} text 
         */
        public label(text: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {double} min 
         * @param {double} max 
         * @param {int} step 
         */
        public buildSlider(title: java.lang.String,min: double,max: double,step: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {double} min 
         * @param {double} max 
         */
        public buildSlider(title: java.lang.String,min: double,max: double): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {double} min 
         * @param {double} max 
         * @param {int} step 
         * @param {double} defaultvalue 
         */
        public buildSlider(title: java.lang.String,min: double,max: double,step: int,defaultvalue: double): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public showToPlayer(p: cn.nukkit.Player,callback: java.lang.String,acceptClose: boolean): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         */
        public showToPlayer(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         */
        public showToPlayer(p: cn.nukkit.Player): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public showToPlayer(p: cn.nukkit.Player,acceptClose: boolean): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} inner 
         */
        public dropdown(title: java.lang.String,inner: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} inner 
         * @param {int} index 
         */
        public dropdown(title: java.lang.String,inner: java.lang.String,index: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} placeholder 
         * @param {java.lang.String} defaulttext 
         */
        public input(title: java.lang.String,placeholder: java.lang.String,defaulttext: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} placeholder 
         */
        public input(title: java.lang.String,placeholder: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 将窗口作为服务器设置向玩家发送
         * @param {cn.nukkit.Player} p 
         * @param {java.lang.String} callback 
         */
        public showAsSetting(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 将窗口作为服务器设置向玩家发送
         * @param {cn.nukkit.Player} p 
         * @param {java.lang.String} imageURL 
         * @param {java.lang.String} callback 
         */
        public showAsSetting(p: cn.nukkit.Player,imageURL: java.lang.String,callback: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} options 
         */
        public buildStepSlider(title: java.lang.String,options: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} options 
         * @param {int} index 
         */
        public buildStepSlider(title: java.lang.String,options: java.lang.String,index: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} callback 
         */
        public action(callback: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.form.element.Element} element 
         */
        public addNewElement(element: cn.nukkit.form.element.Element): void;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} options 
         */
        public stepSlider(title: java.lang.String,options: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} options 
         * @param {int} index 
         */
        public stepSlider(title: java.lang.String,options: java.lang.String,index: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} options 
         * @param {int} index 
         */
        public stepslider(title: java.lang.String,options: java.lang.String,index: int): com.blocklynukkit.loader.script.window.Custom;
        /**
         * 
         * @param {java.lang.String} title 
         * @param {java.lang.String} options 
         */
        public stepslider(title: java.lang.String,options: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerAnimationEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        rowingTime: float;
        /**  */
        animationType: cn.nukkit.network.protocol.AnimatePacket.Action;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getRowingTime(): float;
        /**
         * 
         */
        public getAnimationType(): cn.nukkit.network.protocol.AnimatePacket.Action;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockFormEvent extends cn.nukkit.event.block.BlockGrowEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.item.enchantment.protection{
    abstract class EnchantmentProtection extends cn.nukkit.item.enchantment.Enchantment{
        /**  */
        protectionType: cn.nukkit.item.enchantment.protection.EnchantmentProtection.TYPE;
        /**
         * 
         */
        public getTypeModifier(): double;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public isMajor(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockHugeMushroomRed extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.level.generator.task{
     class PopulationTask extends cn.nukkit.scheduler.AsyncTask{
        /**  */
        isPopulated: boolean;
        /**  */
        centerChunk: cn.nukkit.level.format.generic.BaseFullChunk;
        /**  */
        seed: long;
        /**  */
        level: cn.nukkit.level.Level;
        /**  */
        chunks: cn.nukkit.level.format.generic.BaseFullChunk[];
        /**  */
        state: boolean;
        /**
         * 
         * @param {cn.nukkit.Server} server 
         */
        public onCompletion(server: cn.nukkit.Server): void;
        /**
         * 
         */
        public onRun(): void;
        /**
         * 
         * @param {int} i 
         */
        private syncGen(i: int): void;
        /**
         * 
         */
        private generationTask(): void;
    }
}
declare namespace cn.nukkit.network{
     class Network extends java.lang.Object{
        /**  */
        CHANNEL_WORLD_EVENTS: byte;
        /**  */
        CHANNEL_END: byte;
        /**  */
        server: cn.nukkit.Server;
        /**  */
        interfaces: java.util.Set;
        /**  */
        CHANNEL_PRIORITY: byte;
        /**  */
        packetPool: java.lang.Class[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        CHANNEL_MOVEMENT: byte;
        /**  */
        CHANNEL_TEXT: byte;
        /**  */
        upload: double;
        /**  */
        CHANNEL_ENTITY_SPAWNING: byte;
        /**  */
        BUFFER: java.lang.ThreadLocal;
        /**  */
        DEFLATER_RAW: java.lang.ThreadLocal;
        /**  */
        download: double;
        /**  */
        advancedInterfaces: java.util.Set;
        /**  */
        CHANNEL_WORLD_CHUNKS: byte;
        /**  */
        INFLATER_RAW: java.lang.ThreadLocal;
        /**  */
        subName: java.lang.String;
        /**  */
        name: java.lang.String;
        /**  */
        CHANNEL_BLOCKS: byte;
        /**  */
        CHANNEL_NONE: byte;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} id 
         */
        public getPacket(id: int): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         * @param {byte} id 
         */
        public getPacket(id: byte): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         * @param {java.net.InetSocketAddress} socketAddress 
         * @param {io.netty.buffer.ByteBuf} payload 
         */
        public sendPacket(socketAddress: java.net.InetSocketAddress,payload: io.netty.buffer.ByteBuf): void;
        /**
         * 
         */
        public getDownload(): double;
        /**
         * 
         * @param {byte[]} data 
         */
        public static inflateRaw(data: byte[]): byte[];
        /**
         * 
         */
        public processInterfaces(): void;
        /**
         * 
         * @param {byte[]} data 
         * @param {int} level 
         */
        public static deflateRaw(data: byte[],level: int): byte[];
        /**
         * 
         * @param {byte[][]} datas 
         * @param {int} level 
         */
        public static deflateRaw(datas: byte[][],level: int): byte[];
        /**
         * 
         * @param {java.net.InetAddress} address 
         */
        public blockAddress(address: java.net.InetAddress): void;
        /**
         * 
         * @param {java.net.InetAddress} address 
         * @param {int} timeout 
         */
        public blockAddress(address: java.net.InetAddress,timeout: int): void;
        /**
         * 
         */
        public getSubName(): java.lang.String;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {java.net.InetAddress} address 
         */
        public unblockAddress(address: java.net.InetAddress): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} p 
         */
        private static lambda$processPackets$3(player: cn.nukkit.Player,p: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         * @param {byte[]} payload 
         * @param {java.util.Collection} packets 
         */
        public processBatch(payload: byte[],packets: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.network.protocol.BatchPacket} packet 
         * @param {cn.nukkit.Player} player 
         */
        public processBatch(packet: cn.nukkit.network.protocol.BatchPacket,player: cn.nukkit.Player): void;
        /**
         * 
         */
        public resetStatistics(): void;
        /**
         * 
         */
        public getInterfaces(): java.util.Set;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {java.util.List} packets 
         */
        public processPackets(player: cn.nukkit.Player,packets: java.util.List): void;
        /**
         * 
         * @param {byte} id 
         * @param {java.lang.Class} clazz 
         */
        public registerPacket(id: byte,clazz: java.lang.Class): void;
        /**
         * 
         * @param {double} upload 
         * @param {double} download 
         */
        public addStatistics(upload: double,download: double): void;
        /**
         * 
         */
        public getUpload(): double;
        /**
         * 
         */
        public updateName(): void;
        /**
         * 
         * @param {cn.nukkit.network.SourceInterface} sourceInterface 
         */
        public unregisterInterface(sourceInterface: cn.nukkit.network.SourceInterface): void;
        /**
         * 
         * @param {cn.nukkit.network.SourceInterface} interfaz 
         */
        public registerInterface(interfaz: cn.nukkit.network.SourceInterface): void;
        /**
         * 
         * @param {java.lang.String} subName 
         */
        public setSubName(subName: java.lang.String): void;
        /**
         * 
         */
        private static lambda$static$0(): java.util.zip.Inflater;
        /**
         * 
         */
        private registerPackets(): void;
        /**
         * 
         */
        private static lambda$static$1(): java.util.zip.Deflater;
        /**
         * 
         */
        private static lambda$static$2(): byte[];
    }
}
declare namespace cn.nukkit.network.protocol{
     class CommandRequestPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        TYPE_GAME_ARGUMENT: int;
        /**  */
        TYPE_COMMAND_BLOCK: int;
        /**  */
        TYPE_DEV_CONSOLE: int;
        /**  */
        data: cn.nukkit.network.protocol.types.CommandOriginData;
        /**  */
        NETWORK_ID: byte;
        /**  */
        TYPE_AUTOMATION_PLAYER: int;
        /**  */
        TYPE_CLIENT_AUTOMATION: int;
        /**  */
        TYPE_MINECART_COMMAND_BLOCK: int;
        /**  */
        TYPE_INTERNAL: int;
        /**  */
        TYPE_PLAYER: int;
        /**  */
        command: java.lang.String;
        /**  */
        TYPE_ENTITY: int;
        /**  */
        TYPE_VIRTUAL: int;
        /**  */
        TYPE_DEDICATED_SERVER: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlaySoundPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        volume: float;
        /**  */
        NETWORK_ID: byte;
        /**  */
        name: java.lang.String;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**  */
        pitch: float;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class DustParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockFallable extends cn.nukkit.block.BlockSolid{
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} customNbt 
         */
        protected createFallingEntity(customNbt: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.entity.item.EntityFallingBlock;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.event{
    abstract class Event extends java.lang.Object{
        /**  */
        isCancelled: boolean;
        /**  */
        eventName: java.lang.String;
        /**
         * 
         */
        public isCancelled(): boolean;
        /**
         * 
         */
        public  getEventName(): java.lang.String;
        /**
         * 
         */
        public setCancelled(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setCancelled(value: boolean): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordPigstep extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoeWood extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityInteractEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        block: cn.nukkit.block.Block;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockSolid extends cn.nukkit.block.Block{
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
    }
}
declare namespace cn.nukkit.item{
     class ItemTurtleShell extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.potion{
    abstract class PotionEvent extends cn.nukkit.event.Event{
        /**  */
        potion: cn.nukkit.potion.Potion;
        /**
         * 
         */
        public getPotion(): cn.nukkit.potion.Potion;
        /**
         * 
         * @param {cn.nukkit.potion.Potion} potion 
         */
        public setPotion(potion: cn.nukkit.potion.Potion): void;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityJukebox extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        recordItem: cn.nukkit.item.Item;
        /**
         * 
         */
        public onBreak(): void;
        /**
         * 
         */
        public play(): void;
        /**
         * 
         */
        public dropItem(): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getRecordItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public stop(): void;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} recordItem 
         */
        public setRecordItem(recordItem: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.level.generator{
     class Normal extends cn.nukkit.level.generator.Generator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        biomes: java.lang.ThreadLocal;
        /**  */
        depthNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF;
        /**  */
        depthRegion: java.lang.ThreadLocal;
        /**  */
        biomeWeights: float[];
        /**  */
        scaleNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF;
        /**  */
        localSeed1: long;
        /**  */
        random: java.util.Random;
        /**  */
        heightMap: java.lang.ThreadLocal;
        /**  */
        generationPopulators: java.util.List;
        /**  */
        surfaceNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorPerlinF;
        /**  */
        localSeed2: long;
        /**  */
        populators: java.util.List;
        /**  */
        maxLimitRegion: java.lang.ThreadLocal;
        /**  */
        seaHeight: int;
        /**  */
        nukkitRandom: cn.nukkit.math.NukkitRandom;
        /**  */
        minLimitRegion: java.lang.ThreadLocal;
        /**  */
        maxLimitPerlinNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF;
        /**  */
        mainPerlinNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF;
        /**  */
        selector: cn.nukkit.level.biome.BiomeSelector;
        /**  */
        minLimitPerlinNoise: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorOctavesF;
        /**  */
        mainNoiseRegion: java.lang.ThreadLocal;
        /**
         * 
         */
        private static lambda$new$0(): cn.nukkit.level.biome.Biome[];
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        public init(level: cn.nukkit.level.ChunkManager,random: cn.nukkit.math.NukkitRandom): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public pickBiome(x: int,z: int): cn.nukkit.level.biome.Biome;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getSpawn(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getSettings(): java.util.Map;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getChunkManager(): cn.nukkit.level.ChunkManager;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public populateChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         */
        private static lambda$new$5(): float[];
        /**
         * 
         */
        private static lambda$new$4(): float[];
        /**
         * 
         */
        private static lambda$new$3(): float[];
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public generateChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         */
        private static lambda$new$2(): float[];
        /**
         * 
         */
        private static lambda$new$1(): float[];
    }
}
declare namespace cn.nukkit.event.server{
     class DataPacketReceiveEvent extends cn.nukkit.event.server.ServerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        packet: cn.nukkit.network.protocol.DataPacket;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public getPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.level.generator.object{
    abstract class BasicGenerator extends java.lang.Object{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.Vector3} v 
         * @param {cn.nukkit.block.Block} b 
         */
        protected setBlock(level: cn.nukkit.level.ChunkManager,v: cn.nukkit.math.Vector3,b: cn.nukkit.block.Block): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {cn.nukkit.math.Vector3} position 
         */
        public abstract generate(level: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,position: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public setDecorationDefaults(): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} state 
         */
        protected setBlockAndNotifyAdequately(level: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3,state: cn.nukkit.block.Block): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.BlockVector3} pos 
         * @param {cn.nukkit.block.Block} state 
         */
        protected setBlockAndNotifyAdequately(level: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.BlockVector3,state: cn.nukkit.block.Block): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetEntityDataPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        metadata: cn.nukkit.entity.data.EntityMetadata;
        /**  */
        NETWORK_ID: byte;
        /**  */
        frame: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemLeggingsChain extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isLeggings(): boolean;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityHumanType extends cn.nukkit.entity.EntityCreature{
        /**  */
        enderChestInventory: cn.nukkit.inventory.PlayerEnderChestInventory;
        /**  */
        offhandInventory: cn.nukkit.inventory.PlayerOffhandInventory;
        /**  */
        inventory: cn.nukkit.inventory.PlayerInventory;
        /**
         * 
         * @param {int} seconds 
         */
        public setOnFire(seconds: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} armor 
         * @param {cn.nukkit.entity.Entity} damager 
         */
        protected damageArmor(armor: cn.nukkit.item.Item,damager: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         */
        protected applyNameTag(player: cn.nukkit.Player,item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public applyNameTag(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getOffhandInventory(): cn.nukkit.inventory.PlayerOffhandInventory;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        protected calculateEnchantmentProtectionFactor(item: cn.nukkit.item.Item,source: cn.nukkit.event.entity.EntityDamageEvent): double;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.PlayerInventory;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getEnderChestInventory(): cn.nukkit.inventory.PlayerEnderChestInventory;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityEndermite extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item.enchantment.bow{
    abstract class EnchantmentBow extends cn.nukkit.item.enchantment.Enchantment{
    }
}
declare namespace cn.nukkit.level.biome.type{
    abstract class SnowyBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public getCoverBlock(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemHorseArmorDiamond extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ContainerOpenPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**  */
        entityId: long;
        /**  */
        type: int;
        /**  */
        windowId: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.player{
    abstract class PlayerEvent extends cn.nukkit.event.Event{
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstone extends cn.nukkit.block.BlockSolidMeta{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getWeakPower(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.event.server{
     class ServerCommandEvent extends cn.nukkit.event.server.ServerEvent{
        /**  */
        sender: cn.nukkit.command.CommandSender;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        command: java.lang.String;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getCommand(): java.lang.String;
        /**
         * 
         */
        public getSender(): cn.nukkit.command.CommandSender;
        /**
         * 
         * @param {java.lang.String} command 
         */
        public setCommand(command: java.lang.String): void;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityCreature extends cn.nukkit.entity.EntityLiving{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         */
        public  playerApplyNameTag(player: cn.nukkit.Player,item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         */
        protected applyNameTag(player: cn.nukkit.Player,item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneRepeaterPowered extends cn.nukkit.block.BlockRedstoneRepeater{
        /**
         * 
         */
        protected getUnpowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected getPowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class EnchantParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.level.generator.noise.nukkit.f{
    abstract class NoiseF extends java.lang.Object{
        /**  */
        offsetX: float;
        /**  */
        octaves: float;
        /**  */
        offsetZ: float;
        /**  */
        offsetY: float;
        /**  */
        perm: int[];
        /**  */
        persistence: float;
        /**  */
        expansion: float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} q00 
         * @param {float} q01 
         * @param {float} q10 
         * @param {float} q11 
         * @param {float} x1 
         * @param {float} x2 
         * @param {float} y1 
         * @param {float} y2 
         */
        public static bilinearLerp(x: float,y: float,q00: float,q01: float,q10: float,q11: float,x1: float,x2: float,y1: float,y2: float): float;
        /**
         * 
         * @param {float} x 
         */
        public static fade(x: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} z 
         */
        public abstract getNoise2D(x: float,z: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public static lerp(x: float,y: float,z: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public setOffset(x: float,y: float,z: float): void;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public abstract getNoise3D(x: float,y: float,z: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} z 
         */
        public noise2D(x: float,z: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} z 
         * @param {boolean} normalized 
         */
        public noise2D(x: float,z: float,normalized: boolean): float;
        /**
         * 
         * @param {float} x 
         * @param {float} x1 
         * @param {float} x2 
         * @param {float} q0 
         * @param {float} q1 
         */
        public static linearLerp(x: float,x1: float,x2: float,q0: float,q1: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         * @param {float} q000 
         * @param {float} q001 
         * @param {float} q010 
         * @param {float} q011 
         * @param {float} q100 
         * @param {float} q101 
         * @param {float} q110 
         * @param {float} q111 
         * @param {float} x1 
         * @param {float} x2 
         * @param {float} y1 
         * @param {float} y2 
         * @param {float} z1 
         * @param {float} z2 
         */
        public static trilinearLerp(x: float,y: float,z: float,q000: float,q001: float,q010: float,q011: float,q100: float,q101: float,q110: float,q111: float,x1: float,x2: float,y1: float,y2: float,z1: float,z2: float): float;
        /**
         * 
         * @param {float} x 
         */
        public static floor(x: float): int;
        /**
         * 
         * @param {int} hash 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public static grad(hash: int,x: float,y: float,z: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         * @param {boolean} normalized 
         */
        public noise3D(x: float,y: float,z: float,normalized: boolean): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public noise3D(x: float,y: float,z: float): float;
    }
}
declare namespace cn.nukkit.block{
     class BlockSlime extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightFilter(): int;
    }
}
declare namespace cn.nukkit.command{
    abstract class Command extends java.lang.Object{
        /**  */
        permissionMessage: java.lang.String;
        /**  */
        aliases: java.lang.String[];
        /**  */
        usageMessage: java.lang.String;
        /**  */
        timing: co.aikar.timings.Timing;
        /**  */
        activeAliases: java.lang.String[];
        /**  */
        description: java.lang.String;
        /**  */
        commandData: cn.nukkit.command.data.CommandData;
        /**  */
        permission: java.lang.String;
        /**  */
        label: java.lang.String;
        /**  */
        defaultDataTemplate: cn.nukkit.command.data.CommandData;
        /**  */
        commandMap: cn.nukkit.command.CommandMap;
        /**  */
        commandParameters: java.util.Map;
        /**  */
        name: java.lang.String;
        /**  */
        nextLabel: java.lang.String;
        /**
         * 
         */
        public getDefaultCommandData(): cn.nukkit.command.data.CommandData;
        /**
         * 
         */
        public getAliases(): java.lang.String[];
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getLabel(): java.lang.String;
        /**
         * 
         * @param {java.lang.String[]} aliases 
         */
        public setAliases(aliases: java.lang.String[]): void;
        /**
         * 
         * @param {java.lang.String} arg 
         * @param {double} pos 
         */
        protected parseTilde(arg: java.lang.String,pos: double): double;
        /**
         * 
         * @param {java.lang.String} description 
         */
        public setDescription(description: java.lang.String): void;
        /**
         * 
         */
        public getDescription(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} usageMessage 
         */
        public setUsage(usageMessage: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {cn.nukkit.command.data.CommandParameter[]} parameters 
         */
        public addCommandParameters(key: java.lang.String,parameters: cn.nukkit.command.data.CommandParameter[]): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public generateCustomCommandData(player: cn.nukkit.Player): cn.nukkit.command.data.CommandDataVersions;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} target 
         */
        public testPermission(target: cn.nukkit.command.CommandSender): boolean;
        /**
         * 
         * @param {cn.nukkit.command.CommandMap} commandMap 
         */
        public allowChangesFrom(commandMap: cn.nukkit.command.CommandMap): boolean;
        /**
         * 
         * @param {java.lang.String} permission 
         */
        public setPermission(permission: java.lang.String): void;
        /**
         * 
         * @param {java.util.Map} commandParameters 
         */
        public setCommandParameters(commandParameters: java.util.Map): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} target 
         */
        public testPermissionSilent(target: cn.nukkit.command.CommandSender): boolean;
        /**
         * 
         */
        public getPermission(): java.lang.String;
        /**
         * 
         */
        public getOverloads(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.command.data.CommandData} customData 
         * @param {java.lang.String} key 
         * @param {cn.nukkit.command.data.CommandParameter[]} par 
         */
        private static lambda$generateCustomCommandData$0(customData: cn.nukkit.command.data.CommandData,key: java.lang.String,par: cn.nukkit.command.data.CommandParameter[]): void;
        /**
         * 
         */
        public static generateDefaultData(): cn.nukkit.command.data.CommandData;
        /**
         * 
         */
        public getCommandParameters(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getCommandParameters(key: java.lang.String): cn.nukkit.command.data.CommandParameter[];
        /**
         * 
         * @param {cn.nukkit.command.CommandMap} commandMap 
         */
        public unregister(commandMap: cn.nukkit.command.CommandMap): boolean;
        /**
         * 
         */
        public getPermissionMessage(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public abstract execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
        /**
         * 
         */
        public getUsage(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} permissionMessage 
         */
        public setPermissionMessage(permissionMessage: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} source 
         * @param {java.lang.String} message 
         * @param {boolean} sendToSource 
         */
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender,message: java.lang.String,sendToSource: boolean): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} source 
         * @param {java.lang.String} message 
         */
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender,message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} source 
         * @param {cn.nukkit.lang.TextContainer} message 
         * @param {boolean} sendToSource 
         */
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender,message: cn.nukkit.lang.TextContainer,sendToSource: boolean): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} source 
         * @param {cn.nukkit.lang.TextContainer} message 
         */
        public static broadcastCommandMessage(source: cn.nukkit.command.CommandSender,message: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setLabel(name: java.lang.String): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public isRegistered(): boolean;
        /**
         * 
         * @param {cn.nukkit.command.CommandMap} commandMap 
         */
        public register(commandMap: cn.nukkit.command.CommandMap): boolean;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace entity{
    /**
     * 获取玩家的经验值等级
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerExpLevel(player: cn.nukkit.Player): int;
    /**
     * 获取实体所在的世界
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityLevel(entity: cn.nukkit.entity.Entity): cn.nukkit.level.Level;
    /**
     * 
     */
    function recycleAllBNNPC(): void;
    /**
     * 
     */
    function recycleAllFloatingText(): void;
    /**
     * 设置玩家的饥饿度
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {int} hunger 饥饿度
     */
    function setPlayerHunger(player: cn.nukkit.Player,hunger: int): void;
    /**
     * 获取生物血量
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     */
    function getEntityHealth(entity: cn.nukkit.entity.Entity): float;
    /**
     * 获取玩家的经验值
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerExp(player: cn.nukkit.Player): int;
    /**
     * 给玩家添加经验
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {int} exp 经验值量
     */
    function setPlayerExp(player: cn.nukkit.Player,exp: int): void;
    /**
     * 
     * @param {cn.nukkit.network.protocol.EntityEventPacket} pk 
     * @param {cn.nukkit.Player} player 
     */
    function lambda$displayHurt$0(pk: cn.nukkit.network.protocol.EntityEventPacket,player: cn.nukkit.Player): void;
    /**
     * 设置实体位置
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function setEntityPosition(entity: cn.nukkit.entity.Entity,position: cn.nukkit.level.Position): void;
    /**
     * 获取实体位置
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityPosition(entity: cn.nukkit.entity.Entity): cn.nukkit.level.Position;
    /**
     * 设置玩家的披风图像
     * @param {cn.nukkit.Player} player 玩家
     * @param {java.lang.String} capeImagePath 披风图片路径
     */
    function setPlayerCape(player: cn.nukkit.Player,capeImagePath: java.lang.String): void;
    /**
     * 在指定位置构造浮空字实体
     * @param {java.lang.String} text 浮空字内容，其实就是实体名
     * @param {cn.nukkit.level.Position} pos 浮空字实体的位置
     * @param {int} calltick 回调函数回调间隔(tick)
     * @param {java.lang.String} callback 回调函数名,参数(cn.nukkit.entity.Entity 浮空字实体自身)
     */
    function buildFloatingText(text: java.lang.String,pos: cn.nukkit.level.Position,calltick: int,callback: Fun1<com.blocklynukkit.loader.other.Entities.FloatingText>): cn.nukkit.entity.Entity;
    /**
     * 让指定生物显示死亡动画
     * @param {cn.nukkit.entity.Entity} e 实体对象
     */
    function displayDie(e: cn.nukkit.entity.Entity): void;
    /**
     * 取消浮空物品展示
     * @param {cn.nukkit.level.Position} pos 浮空物品的坐标
     * @param {cn.nukkit.item.Item} item 浮空物品的内容
     */
    function removeFloatingItem(pos: cn.nukkit.level.Position,item: cn.nukkit.item.Item): void;
    /**
     * 让生物转动视角看向指定坐标
     * @param {cn.nukkit.entity.Entity} e 实体对象
     * @param {cn.nukkit.level.Position} pos 坐标
     */
    function lookAt(e: cn.nukkit.entity.Entity,pos: cn.nukkit.level.Position): void;
    /**
     * 构建bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     * @param {java.lang.String} skinID 皮肤名称
     * @param {int} calltick 定时回调函数回调间隔
     * @param {java.lang.String} callfunction 定时回调函数名，参数(cn.nukkit.Entity bnnpc自身)
     * @param {java.lang.String} attackfunction 被打回调函数名，参数(cn.nukkit.Entity bnnpc自身, cn.nukkit.event.Event 实体收到伤害事件)
     */
    function buildNPC(pos: cn.nukkit.level.Position,name: java.lang.String,skinID: java.lang.String,calltick: int,callfunction: Fun2<com.blocklynukkit.loader.other.Entities.BNNPC,int>,attackfunction: Fun2<com.blocklynukkit.loader.other.Entities.BNNPC,cn.nukkit.event.entity.EntityDamageEvent>): com.blocklynukkit.loader.other.Entities.BNNPC;
    /**
     * 构建bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     * @param {java.lang.String} skinID 皮肤名称
     * @param {int} calltick 定时回调函数回调间隔
     * @param {java.lang.String} callfunction 定时回调函数名，参数(cn.nukkit.Entity bnnpc自身)
     */
    function buildNPC(pos: cn.nukkit.level.Position,name: java.lang.String,skinID: java.lang.String,calltick: int,callfunction: Fun2<com.blocklynukkit.loader.other.Entities.BNNPC,int>): com.blocklynukkit.loader.other.Entities.BNNPC;
    /**
     * 构建bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     */
    function buildNPC(pos: cn.nukkit.level.Position,name: java.lang.String): com.blocklynukkit.loader.other.Entities.BNNPC;
    /**
     * 构建bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     * @param {java.lang.String} skinID 皮肤名称
     */
    function buildNPC(pos: cn.nukkit.level.Position,name: java.lang.String,skinID: java.lang.String): com.blocklynukkit.loader.other.Entities.BNNPC;
    /**
     * 启动浮空字实体显示
     * @param {cn.nukkit.entity.Entity} entity 浮空字实体
     */
    function startDisplayFloatingText(entity: cn.nukkit.entity.Entity): void;
    /**
     * 构建4d展示模型
     * @param {cn.nukkit.level.Position} pos 生成模型的位置
     * @param {java.lang.String} modelSkinID 模型4d皮肤id
     * @param {double} length 模型长
     * @param {double} width 模型宽
     * @param {double} height 模型高
     * @param {double} scale 模型缩放比例
     * @param {java.lang.String} tickCallback 定时回调函数
     * @param {int} callTick 定时回调函数回调间隔(刻)
     * @param {java.lang.String} attackCallback 被攻击回调函数
     * @param {java.lang.String} interactCallback 实体交互回调函数
     */
    function buildModel(pos: cn.nukkit.level.Position,modelSkinID: java.lang.String,length: double,width: double,height: double,scale: double,tickCallback: Fun2<com.blocklynukkit.loader.other.Entities.BNModel,int>,callTick: int,attackCallback: Fun2<com.blocklynukkit.loader.other.Entities.BNModel,cn.nukkit.event.entity.EntityDamageEvent>,interactCallback: Fun4<com.blocklynukkit.loader.other.Entities.BNModel,cn.nukkit.Player,cn.nukkit.item.Item,cn.nukkit.math.Vector3>): com.blocklynukkit.loader.other.Entities.BNModel;
    /**
     * 获取生物最大血量
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     */
    function getEntityMaxHealth(entity: cn.nukkit.entity.Entity): float;
    /**
     * 设置玩家的经验值等级
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {int} lel 经验值等级
     */
    function setPlayerExpLevel(player: cn.nukkit.Player,lel: int): void;
    /**
     * 获取实体的唯一标识符(ID)
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityID(entity: cn.nukkit.entity.Entity): java.lang.String;
    /**
     * 获取生物标识名
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getIDName(entity: cn.nukkit.entity.Entity): java.lang.String;
    /**
     * 检测实体是否是玩家
     * @param {cn.nukkit.entity.Entity} e 实体对象
     */
    function isPlayer(e: cn.nukkit.entity.Entity): boolean;
    /**
     * 设置生物血量
     * @param {cn.nukkit.entity.Entity} entity 
     * @param {double} health 血量
     */
    function setEntityHealth(entity: cn.nukkit.entity.Entity,health: double): void;
    /**
     * 设置玩家指南针指向
     * @param {cn.nukkit.Player} player 玩家
     * @param {cn.nukkit.level.Position} target 指向的位置
     */
    function setPlayerCompassTarget(player: cn.nukkit.Player,target: cn.nukkit.level.Position): void;
    /**
     * 获取实体或玩家的所有的药水效果对象
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityEffect(entity: cn.nukkit.entity.Entity): cn.nukkit.potion.Effect[];
    /**
     * 为生物添加药水状态
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     * @param {int} id 药水id
     * @param {int} level 药效等级
     * @param {int} tick 持续时间(刻)
     * @param {int} r 药效粒子颜色 r
     * @param {int} g 药效粒子颜色 g
     * @param {int} b 药效粒子颜色 b
     */
    function addEntityEffect(entity: cn.nukkit.entity.Entity,id: int,level: int,tick: int,r: int,g: int,b: int): void;
    /**
     * 为生物添加药水状态
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     * @param {int} id 药水id
     * @param {int} level 药效等级
     * @param {int} tick 持续时间(刻)
     */
    function addEntityEffect(entity: cn.nukkit.entity.Entity,id: int,level: int,tick: int): void;
    /**
     * 获取掉落物的物品
     * @param {cn.nukkit.entity.item.EntityItem} entityItem 掉落物实体对象
     */
    function getDropItemStack(entityItem: cn.nukkit.entity.item.EntityItem): cn.nukkit.item.Item;
    /**
     * 清除生物的药水状态
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     */
    function clearEntityEffect(entity: cn.nukkit.entity.Entity): void;
    /**
     * 发射箭矢
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     */
    function shootArrow(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position): cn.nukkit.entity.projectile.EntityArrow;
    /**
     * 发射箭矢
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {double} multiply 速度扩倍倍率
     */
    function shootArrow(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,multiply: double): cn.nukkit.entity.projectile.EntityArrow;
    /**
     * 发射箭矢
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {boolean} canPickUp 是否可以被捡起
     * @param {double} multiply 速度扩倍倍率
     */
    function shootArrow(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,canPickUp: boolean,multiply: double): cn.nukkit.entity.projectile.EntityArrow;
    /**
     * 发射箭矢
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {boolean} canPickUp 是否可以被捡起
     */
    function shootArrow(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,canPickUp: boolean): cn.nukkit.entity.projectile.EntityArrow;
    /**
     * 发射箭矢
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {cn.nukkit.entity.Entity} shooter 发射箭矢的实体
     * @param {boolean} canPickUp 是否可以被捡起
     * @param {double} multiply 速度扩倍倍率
     */
    function shootArrow(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,shooter: cn.nukkit.entity.Entity,canPickUp: boolean,multiply: double): cn.nukkit.entity.projectile.EntityArrow;
    /**
     * 设置生物名称是否高亮（永远能看到）
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     * @param {boolean} vis 是否高亮
     */
    function setEntityNameTagAlwaysVisable(entity: cn.nukkit.entity.Entity,vis: boolean): void;
    /**
     * 让指定生物显示受伤动画
     * @param {cn.nukkit.entity.Entity} e 实体对象
     */
    function displayHurt(e: cn.nukkit.entity.Entity): void;
    /**
     * 生成生物
     * @param {java.lang.String} name 生物标识名
     * @param {cn.nukkit.level.Position} pos 生成的位置
     */
    function spawnEntity(name: java.lang.String,pos: cn.nukkit.level.Position): cn.nukkit.entity.Entity;
    /**
     * 获取玩家的饥饿度
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerHunger(player: cn.nukkit.Player): int;
    /**
     * 构建旧版bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     * @param {java.lang.String} skinID 皮肤名称
     */
    function buildNPC_Old(pos: cn.nukkit.level.Position,name: java.lang.String,skinID: java.lang.String): com.blocklynukkit.loader.other.Entities.BNNPC_Fix;
    /**
     * 构建旧版bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     */
    function buildNPC_Old(pos: cn.nukkit.level.Position,name: java.lang.String): com.blocklynukkit.loader.other.Entities.BNNPC_Fix;
    /**
     * 构建旧版bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     * @param {java.lang.String} skinID 皮肤名称
     * @param {int} calltick 定时回调函数回调间隔
     * @param {java.lang.String} callfunction 定时回调函数名，参数(cn.nukkit.Entity bnnpc自身)
     */
    function buildNPC_Old(pos: cn.nukkit.level.Position,name: java.lang.String,skinID: java.lang.String,calltick: int,callfunction: Fun2<com.blocklynukkit.loader.other.Entities.BNNPC_Fix,int>): com.blocklynukkit.loader.other.Entities.BNNPC_Fix;
    /**
     * 构建旧版bnNPC
     * @param {cn.nukkit.level.Position} pos 生成bnnpc的位置
     * @param {java.lang.String} name bnnpc的名字
     * @param {java.lang.String} skinID 皮肤名称
     * @param {int} calltick 定时回调函数回调间隔
     * @param {java.lang.String} callfunction 定时回调函数名，参数(cn.nukkit.Entity bnnpc自身)
     * @param {java.lang.String} attackfunction 被打回调函数名，参数(cn.nukkit.Entity bnnpc自身, cn.nukkit.event.Event 实体收到伤害事件)
     */
    function buildNPC_Old(pos: cn.nukkit.level.Position,name: java.lang.String,skinID: java.lang.String,calltick: int,callfunction: Fun2<com.blocklynukkit.loader.other.Entities.BNNPC,int>,attackfunction: Fun2<com.blocklynukkit.loader.other.Entities.BNNPC_Fix,cn.nukkit.event.entity.EntityDamageEvent>): com.blocklynukkit.loader.other.Entities.BNNPC_Fix;
    /**
     * 获取药水效果ID
     * @param {cn.nukkit.potion.Effect} effect 药水效果对象
     */
    function getEffectID(effect: cn.nukkit.potion.Effect): int;
    /**
     * 获取实体名称
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityName(entity: cn.nukkit.entity.Entity): java.lang.String;
    /**
     * 展示浮空物品
     * @param {cn.nukkit.level.Position} pos 展示浮空物品的坐标
     * @param {cn.nukkit.item.Item} item 展示的内容
     */
    function showFloatingItem(pos: cn.nukkit.level.Position,item: cn.nukkit.item.Item): void;
    /**
     * 发射雪球
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {boolean} canPickUp 是否可以被捡起
     * @param {double} multiply 速度扩倍倍率
     */
    function shootSnowball(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,canPickUp: boolean,multiply: double): cn.nukkit.entity.projectile.EntitySnowball;
    /**
     * 发射雪球
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {boolean} canPickUp 是否可以被捡起
     */
    function shootSnowball(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,canPickUp: boolean): cn.nukkit.entity.projectile.EntitySnowball;
    /**
     * 发射雪球
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {cn.nukkit.entity.Entity} shooter 发射雪球的实体
     * @param {boolean} canPickUp 是否可以被捡起
     * @param {double} multiply 速度扩倍倍率
     */
    function shootSnowball(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,shooter: cn.nukkit.entity.Entity,canPickUp: boolean,multiply: double): cn.nukkit.entity.projectile.EntitySnowball;
    /**
     * 发射雪球
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     * @param {double} multiply 速度扩倍倍率
     */
    function shootSnowball(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position,multiply: double): cn.nukkit.entity.projectile.EntitySnowball;
    /**
     * 发射雪球
     * @param {cn.nukkit.level.Position} from 发射的起点
     * @param {cn.nukkit.level.Position} to 目标终点方向坐标
     */
    function shootSnowball(from: cn.nukkit.level.Position,to: cn.nukkit.level.Position): cn.nukkit.entity.projectile.EntitySnowball;
    /**
     * 向指定玩家播放声音
     * @param {cn.nukkit.Player} player 要指定播放声音的玩家
     * @param {java.lang.String} sound 声音名称，详见[声音列表](https://ci.opencollab.dev/job/NukkitX/job/Nukkit/job/master/javadoc/cn/nukkit/level/Sound.html)
     */
    function makeSoundToPlayer(player: cn.nukkit.Player,sound: java.lang.String): void;
    /**
     * 获取指定世界的所有浮空字
     * @param {cn.nukkit.level.Level} level 世界对象
     */
    function getLevelFloatingText(level: cn.nukkit.level.Level): com.blocklynukkit.loader.other.Entities.FloatingText[];
    /**
     * 
     * @param {cn.nukkit.network.protocol.EntityEventPacket} pk 
     * @param {cn.nukkit.Player} player 
     */
    function lambda$displayDie$1(pk: cn.nukkit.network.protocol.EntityEventPacket,player: cn.nukkit.Player): void;
    /**
     * 为实体创建寻路器
     * @param {cn.nukkit.entity.Entity} entity 
     */
    function buildRouteFinder(entity: cn.nukkit.entity.Entity): com.blocklynukkit.loader.other.ai.route.AdvancedRouteFinder;
    /**
     * 移除生物
     * @param {cn.nukkit.entity.Entity} entity 生物实体对象
     */
    function removeEntity(entity: cn.nukkit.entity.Entity): void;
    /**
     * 设置生物最大血量
     * @param {cn.nukkit.entity.Entity} entity 生物对象
     * @param {double} health 最大血量
     */
    function setEntityMaxHealth(entity: cn.nukkit.entity.Entity,health: double): void;
    /**
     * 设置生物的名称
     * @param {cn.nukkit.entity.Entity} entity 生物实体对象
     * @param {java.lang.String} name 名称
     */
    function setEntityName(entity: cn.nukkit.entity.Entity,name: java.lang.String): void;
    /**
     * 根据实体唯一标识符(ID)获取实体对象
     * @param {cn.nukkit.level.Level} level 实体所在的世界
     * @param {java.lang.String} id 实体唯一标识符(ID)
     */
    function getEntityByLevelAndID(level: cn.nukkit.level.Level,id: java.lang.String): cn.nukkit.entity.Entity;
    /**
     * 获取生物networkid
     * @param {cn.nukkit.entity.Entity} entity 药水效果对象
     */
    function getNetworkID(entity: cn.nukkit.entity.Entity): int;
    /**
     * 获取药水效果剩余的对象
     * @param {cn.nukkit.potion.Effect} effect 药水效果对象
     */
    function getEffectTime(effect: cn.nukkit.potion.Effect): int;
    /**
     * 获取药水效果等级
     * @param {cn.nukkit.potion.Effect} effect 药水效果对象
     */
    function getEffectLevel(effect: cn.nukkit.potion.Effect): int;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 生成实体方块
     * @param {cn.nukkit.level.Position} pos 生成的位置
     * @param {cn.nukkit.block.Block} block 方块
     * @param {boolean} enableGravity 是否启用重力
     * @param {boolean} canBePlaced 掉到地上是否成为固体方块
     */
    function spawnFallingBlock(pos: cn.nukkit.level.Position,block: cn.nukkit.block.Block,enableGravity: boolean,canBePlaced: boolean): cn.nukkit.entity.Entity;
}
declare namespace cn.nukkit.block{
     class BlockGlassPaneStained extends cn.nukkit.block.BlockGlassPane{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemBootsDiamond extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.command.defaults{
     class WhitelistCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} perm 
         */
        private badPerm(sender: cn.nukkit.command.CommandSender,perm: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordMall extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.util{
     class PalettedBlockStorage extends java.lang.Object{
        /**  */
        bitArray: cn.nukkit.level.util.BitArray;
        /**  */
        SIZE: int;
        /**  */
        palette: it.unimi.dsi.fastutil.ints.IntList;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void;
        /**
         * 
         * @param {cn.nukkit.level.util.BitArrayVersion} version 
         */
        private onResize(version: cn.nukkit.level.util.BitArrayVersion): void;
        /**
         * 
         * @param {cn.nukkit.level.util.BitArrayVersion} version 
         * @param {boolean} runtime 
         */
        private getPaletteHeader(version: cn.nukkit.level.util.BitArrayVersion,runtime: boolean): int;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {int} runtimeId 
         */
        public setBlock(index: int,runtimeId: int): void;
        /**
         * 
         * @param {int} runtimeId 
         */
        private idFor(runtimeId: int): int;
        /**
         * 
         */
        public copy(): cn.nukkit.level.util.PalettedBlockStorage;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityStray extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class LevelEventGenericPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eventId: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        tag: cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class RespawnPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        respawnState: int;
        /**  */
        STATE_CLIENT_READY_TO_SPAWN: int;
        /**  */
        STATE_SEARCHING_FOR_SPAWN: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        runtimeEntityId: long;
        /**  */
        z: float;
        /**  */
        STATE_READY_TO_SPAWN: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class StopCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.redstone{
     class RedstoneUpdateEvent extends cn.nukkit.event.block.BlockUpdateEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntitySmite extends java.lang.Object{
    }
}
declare namespace cn.nukkit.utils{
     class TerracottaColor extends java.lang.Enum{
        /**  */
        dyeColorMeta: int;
        /**  */
        colorName: java.lang.String;
        /**  */
        BY_TERRACOTA_DATA: cn.nukkit.utils.TerracottaColor[];
        /**  */
        GRAY: cn.nukkit.utils.TerracottaColor;
        /**  */
        WHITE: cn.nukkit.utils.TerracottaColor;
        /**  */
        BLUE: cn.nukkit.utils.TerracottaColor;
        /**  */
        dyeName: java.lang.String;
        /**  */
        terracottaColorMeta: int;
        /**  */
        PURPLE: cn.nukkit.utils.TerracottaColor;
        /**  */
        GREEN: cn.nukkit.utils.TerracottaColor;
        /**  */
        RED: cn.nukkit.utils.TerracottaColor;
        /**  */
        PINK: cn.nukkit.utils.TerracottaColor;
        /**  */
        LIGHT_GRAY: cn.nukkit.utils.TerracottaColor;
        /**  */
        blockColor: cn.nukkit.utils.BlockColor;
        /**  */
        LIGHT_BLUE: cn.nukkit.utils.TerracottaColor;
        /**  */
        LIME: cn.nukkit.utils.TerracottaColor;
        /**  */
        BY_DYE_DATA: cn.nukkit.utils.TerracottaColor[];
        /**  */
        BLACK: cn.nukkit.utils.TerracottaColor;
        /**  */
        MAGENTA: cn.nukkit.utils.TerracottaColor;
        /**  */
        YELLOW: cn.nukkit.utils.TerracottaColor;
        /**  */
        CYAN: cn.nukkit.utils.TerracottaColor;
        /**  */
        BROWN: cn.nukkit.utils.TerracottaColor;
        /**  */
        $VALUES: cn.nukkit.utils.TerracottaColor[];
        /**  */
        ORANGE: cn.nukkit.utils.TerracottaColor;
        /**
         * 
         */
        public getTerracottaData(): int;
        /**
         * 
         */
        public getDyeData(): int;
        /**
         * 
         * @param {int} dyeColorMeta 
         */
        public static getByDyeData(dyeColorMeta: int): cn.nukkit.utils.TerracottaColor;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} terracottaColorMeta 
         */
        public static getByTerracottaData(terracottaColorMeta: int): cn.nukkit.utils.TerracottaColor;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.utils.TerracottaColor;
        /**
         * 
         */
        public static values(): cn.nukkit.utils.TerracottaColor[];
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getDyeName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorBirch extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.biome.impl.jungle{
     class JungleEdgeBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.command{
    abstract class CommandExecutor extends java.lang.Object{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {cn.nukkit.command.Command} command 
         * @param {java.lang.String} label 
         * @param {java.lang.String[]} args 
         */
        public abstract onCommand(sender: cn.nukkit.command.CommandSender,command: cn.nukkit.command.Command,label: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockStairs extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        UPSIDE_DOWN: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        STAIRS_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {boolean} upsideDown 
         */
        public setUpsideDown(upsideDown: boolean): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public collidesWithBB(bb: cn.nukkit.math.AxisAlignedBB): boolean;
        /**
         * 
         */
        public isUpsideDown(): boolean;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMinY(): double;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityRavager extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockButton extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        BUTTON_PRESSED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {boolean} activated 
         */
        public setActivated(activated: boolean): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public isActivated(): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.command.defaults{
     class GameruleCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {java.util.List} boolGameRules 
         * @param {java.util.List} intGameRules 
         * @param {java.util.List} floatGameRules 
         * @param {java.util.List} unknownGameRules 
         * @param {cn.nukkit.level.GameRule} rule 
         * @param {cn.nukkit.level.GameRules.Value} value 
         */
        private static lambda$new$0(boolGameRules: java.util.List,intGameRules: java.util.List,floatGameRules: java.util.List,unknownGameRules: java.util.List,rule: cn.nukkit.level.GameRule,value: cn.nukkit.level.GameRules.Value): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace com.blocklynukkit.loader.other.Entities{
     class FloatingText extends com.blocklynukkit.loader.other.Entities.EntityMob{
        /**  */
        CallBack: java.lang.String;
        /**  */
        NetWorkId: int;
        /**  */
        CallTick: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordStrad extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.mushroom{
     class MushroomIslandShoreBiome extends cn.nukkit.level.biome.impl.mushroom.MushroomIslandBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace com.blocklynukkit.loader.other.net.websocket{
     class WsServer extends org.java_websocket.server.WebSocketServer{
        /**  */
        __self: com.blocklynukkit.loader.other.net.websocket.WsServer;
        /**  */
        openCallback: java.lang.String;
        /**  */
        port: int;
        /**  */
        messageStringCallback: java.lang.String;
        /**  */
        messageDataCallback: java.lang.String;
        /**  */
        closeCallback: java.lang.String;
        /**  */
        workingThread: java.lang.Thread;
        /**
         * 
         * @param {org.java_websocket.WebSocket} conn 
         * @param {int} code 
         * @param {java.lang.String} reason 
         * @param {boolean} remote 
         */
        public onClose(conn: org.java_websocket.WebSocket,code: int,reason: java.lang.String,remote: boolean): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} conn 
         * @param {java.lang.Exception} ex 
         */
        public onError(conn: org.java_websocket.WebSocket,ex: java.lang.Exception): void;
        /**
         * 
         */
        public onStart(): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} conn 
         * @param {org.java_websocket.handshake.ClientHandshake} handshake 
         */
        public onOpen(conn: org.java_websocket.WebSocket,handshake: org.java_websocket.handshake.ClientHandshake): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} conn 
         * @param {java.nio.ByteBuffer} message 
         */
        public onMessage(conn: org.java_websocket.WebSocket,message: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} conn 
         * @param {java.lang.String} message 
         */
        public onMessage(conn: org.java_websocket.WebSocket,message: java.lang.String): void;
    }
}
declare namespace cn.nukkit.event.inventory{
    abstract class InventoryEvent extends cn.nukkit.event.Event{
        /**  */
        inventory: cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getViewers(): cn.nukkit.Player[];
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityPhantom extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item.enchantment.trident{
     class EnchantmentTridentChanneling extends cn.nukkit.item.enchantment.trident.EnchantmentTrident{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemBanner extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getBaseColor(): int;
        /**
         * 
         */
        public getPatternsSize(): int;
        /**
         * 
         * @param {cn.nukkit.utils.DyeColor} color 
         */
        public setBaseColor(color: cn.nukkit.utils.DyeColor): void;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {int} index 
         */
        public removePattern(index: int): void;
        /**
         * 
         */
        public correctNBT(): void;
        /**
         * 
         * @param {cn.nukkit.utils.BannerPattern} pattern 
         */
        public addPattern(pattern: cn.nukkit.utils.BannerPattern): void;
        /**
         * 
         */
        public hasPattern(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public setType(type: int): void;
        /**
         * 
         * @param {int} index 
         */
        public getPattern(index: int): cn.nukkit.utils.BannerPattern;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MobEquipmentPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        NETWORK_ID: byte;
        /**  */
        hotbarSlot: int;
        /**  */
        inventorySlot: int;
        /**  */
        windowId: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemExpBottle extends cn.nukkit.item.ProjectileItem{
        /**
         * 
         */
        public getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public getThrowForce(): float;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerRespawnEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        keepRespawnBlockPosition: boolean;
        /**  */
        sendInvalidRespawnBlockMessage: boolean;
        /**  */
        firstSpawn: boolean;
        /**  */
        spawnBlockAvailable: boolean;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        originalSpawnPosition: cn.nukkit.level.Position;
        /**  */
        position: cn.nukkit.level.Position;
        /**  */
        keepRespawnPosition: boolean;
        /**  */
        spawnBlock: cn.nukkit.level.Position;
        /**  */
        consumeCharge: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {boolean} keepRespawnPosition 
         */
        public setKeepRespawnPosition(keepRespawnPosition: boolean): void;
        /**
         * 
         */
        public isKeepRespawnBlockPosition(): boolean;
        /**
         * 
         */
        public isConsumeCharge(): boolean;
        /**
         * 
         */
        public isSendInvalidRespawnBlockMessage(): boolean;
        /**
         * 
         * @param {boolean} consumeCharge 
         */
        public setConsumeCharge(consumeCharge: boolean): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} position 
         */
        public setRespawnPosition(position: cn.nukkit.level.Position): void;
        /**
         * 
         */
        public getRespawnPosition(): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.level.Position} spawnBlock 
         */
        public setRespawnBlockPosition(spawnBlock: cn.nukkit.level.Position): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} originalSpawnPosition 
         */
        public setOriginalRespawnPosition(originalSpawnPosition: cn.nukkit.level.Position): void;
        /**
         * 
         */
        public getRespawnBlockPosition(): cn.nukkit.level.Position;
        /**
         * 
         * @param {boolean} spawnBlockAvailable 
         */
        public setRespawnBlockAvailable(spawnBlockAvailable: boolean): void;
        /**
         * 
         */
        public getOriginalRespawnPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public isKeepRespawnPosition(): boolean;
        /**
         * 
         * @param {boolean} keepRespawnBlockPosition 
         */
        public setKeepRespawnBlockPosition(keepRespawnBlockPosition: boolean): void;
        /**
         * 
         * @param {boolean} sendInvalidRespawnBlockMessage 
         */
        public setSendInvalidRespawnBlockMessage(sendInvalidRespawnBlockMessage: boolean): void;
        /**
         * 
         */
        public isRespawnBlockAvailable(): boolean;
        /**
         * 
         */
        public isFirstSpawn(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockBedrock extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        INFINIBURN: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {boolean} infiniburn 
         */
        public setBurnIndefinitely(infiniburn: boolean): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnIndefinitely(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockLever extends cn.nukkit.block.BlockFlowable{
        /**  */
        LEVER_DIRECTION: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public getLeverOrientation(): cn.nukkit.block.BlockLever.LeverOrientation;
        /**
         * 
         */
        public isPowerOn(): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.block.BlockLever.LeverOrientation} value 
         */
        public setLeverOrientation(value: cn.nukkit.block.BlockLever.LeverOrientation): void;
        /**
         * 
         * @param {boolean} powerOn 
         */
        public setPowerOn(powerOn: boolean): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.block.Block} support 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public static isSupportValid(support: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace): boolean;
    }
}
declare namespace com.blocklynukkit.loader.other.control{
     class JClass extends java.lang.Object{
        /**  */
        objStore: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**  */
        trueClass: java.lang.Class;
        /**  */
        clazz: javassist.CtClass;
        /**
         * 
         * @param {java.lang.String} modifier 
         * @param {java.lang.String} proxyFunction 
         * @param {java.lang.String[]} argumentClasses 
         */
        public  addConstructor(modifier: java.lang.String,proxyFunction: java.lang.String,...argumentClasses: java.lang.String[]): com.blocklynukkit.loader.other.control.JClass;
        /**
         * 
         * @param {int} index 
         */
        public static getStore(index: int): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} index 
         */
        public static getStore(index: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} modifier 
         * @param {java.lang.String} fieldClass 
         * @param {java.lang.String} fieldName 
         * @param {java.lang.Object} defaultValue 
         */
        public addField(modifier: java.lang.String,fieldClass: java.lang.String,fieldName: java.lang.String,defaultValue: java.lang.Object): com.blocklynukkit.loader.other.control.JClass;
        /**
         * 
         * @param {java.lang.String} modifier 
         * @param {java.lang.String} fieldClass 
         * @param {java.lang.String} fieldName 
         */
        public addField(modifier: java.lang.String,fieldClass: java.lang.String,fieldName: java.lang.String): com.blocklynukkit.loader.other.control.JClass;
        /**
         * 
         * @param {java.lang.Object[]} args 
         */
        public  newInstance(...args: java.lang.Object[]): java.lang.Object;
        /**
         * 
         */
        public finish(): com.blocklynukkit.loader.other.control.JClass;
        /**
         * 
         * @param {java.lang.String} modifier 
         * @param {java.lang.String} returnClass 
         * @param {java.lang.String} methodName 
         * @param {java.lang.String} proxyFunction 
         * @param {java.lang.String[]} argumentClasses 
         */
        public  addMethod(modifier: java.lang.String,returnClass: java.lang.String,methodName: java.lang.String,proxyFunction: java.lang.String,...argumentClasses: java.lang.String[]): com.blocklynukkit.loader.other.control.JClass;
    }
}
declare namespace cn.nukkit.item{
     class ItemLeggingsLeather extends cn.nukkit.item.ItemColorArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isLeggings(): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment.trident{
     class EnchantmentTridentLoyalty extends cn.nukkit.item.enchantment.trident.EnchantmentTrident{
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.entity.passive{
    abstract class EntityAnimal extends cn.nukkit.entity.EntityCreature{
        /**
         * 
         */
        public isBaby(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreedingItem(item: cn.nukkit.item.Item): boolean;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityExpBottle extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public dropXp(): void;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        protected addHitEffect(): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
    }
}
declare namespace cn.nukkit.block{
     class BlockEndRod extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockIron extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsNetherBrick extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerEditBookEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        action: cn.nukkit.network.protocol.BookEditPacket.Action;
        /**  */
        newBook: cn.nukkit.item.Item;
        /**  */
        oldBook: cn.nukkit.item.Item;
        /**
         * 
         */
        public getNewBook(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} book 
         */
        public setNewBook(book: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getOldBook(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getAction(): cn.nukkit.network.protocol.BookEditPacket.Action;
    }
}
declare namespace java.util{
    abstract class List extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract add(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.Object} arg1 
         */
        public abstract add(arg0: int,arg1: java.lang.Object): void;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public abstract subList(arg0: int,arg1: int): java.util.List;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.Object} arg1 
         */
        public abstract set(arg0: int,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         */
        public spliterator(): java.util.Spliterator;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract containsAll(arg0: java.util.Collection): boolean;
        /**
         * 
         */
        public abstract clear(): void;
        /**
         * 
         */
        public abstract isEmpty(): boolean;
        /**
         * 
         * @param {java.util.Comparator} arg0 
         */
        public sort(arg0: java.util.Comparator): void;
        /**
         * 
         * @param {java.util.function.UnaryOperator} arg0 
         */
        public replaceAll(arg0: java.util.function.UnaryOperator): void;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract remove(arg0: int): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract remove(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract lastIndexOf(arg0: java.lang.Object): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract contains(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public abstract iterator(): java.util.Iterator;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract removeAll(arg0: java.util.Collection): boolean;
        /**
         * 
         */
        public abstract size(): int;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract addAll(arg0: java.util.Collection): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {java.util.Collection} arg1 
         */
        public abstract addAll(arg0: int,arg1: java.util.Collection): boolean;
        /**
         * 
         */
        public abstract hashCode(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract get(arg0: int): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public abstract toArray(): java.lang.Object[];
        /**
         * 
         * @param {java.lang.Object[]} arg0 
         */
        public abstract toArray(arg0: java.lang.Object[]): java.lang.Object[];
        /**
         * 
         * @param {int} arg0 
         */
        public abstract listIterator(arg0: int): java.util.ListIterator;
        /**
         * 
         */
        public abstract listIterator(): java.util.ListIterator;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract indexOf(arg0: java.lang.Object): int;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract retainAll(arg0: java.util.Collection): boolean;
    }
}
declare namespace cn.nukkit.command.defaults{
     class StatusCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**  */
        UPTIME_FORMAT: java.lang.String;
        /**
         * 
         * @param {long} uptime 
         */
        private static formatUptime(uptime: long): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockSponge extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        SPONGE_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        NAMES: java.lang.String[];
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        WET: int;
        /**  */
        DRY: int;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        private performWaterAbsorb(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityShulkerBox extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        inventory: cn.nukkit.inventory.ShulkerBoxInventory;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public hasName(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {int} index 
         */
        public getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         * @param {int} index 
         */
        protected getSlotIndex(index: int): int;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.BaseInventory;
        /**
         * 
         */
        public getRealInventory(): cn.nukkit.inventory.ShulkerBoxInventory;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(index: int,item: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockRedstoneComparator extends cn.nukkit.block.BlockRedstoneDiode{
        /**  */
        OUTPUT_SUBTRACT: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        OUTPUT_LIT: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         */
        public updateState(): void;
        /**
         * 
         */
        protected getRedstoneSignal(): int;
        /**
         * 
         */
        protected getUnpowered(): cn.nukkit.block.BlockRedstoneComparator;
        /**
         * 
         */
        protected  getUnpowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        protected getDelay(): int;
        /**
         * 
         */
        protected  getPowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        protected getPowered(): cn.nukkit.block.BlockRedstoneComparator;
        /**
         * 
         */
        private onChange(): void;
        /**
         * 
         */
        protected shouldBePowered(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        private calculateOutput(): int;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        protected calculateInputStrength(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMode(): cn.nukkit.block.BlockRedstoneComparator.Mode;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.command.defaults{
     class BanListCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.vehicle{
     class VehicleUpdateEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.level.biome.impl.mesa{
     class MesaBryceBiome extends cn.nukkit.level.biome.impl.mesa.MesaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected minHill(): float;
        /**
         * 
         */
        protected getMoundFrequency(): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemShovelWood extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ServerSettingsResponsePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        formId: int;
        /**  */
        data: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordStal extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.nbt.stream{
     class NBTInputStream extends java.lang.Object{
        /**  */
        stream: java.io.DataInputStream;
        /**  */
        endianness: java.nio.ByteOrder;
        /**  */
        network: boolean;
        /**
         * 
         */
        public getEndianness(): java.nio.ByteOrder;
        /**
         * 
         */
        public available(): int;
        /**
         * 
         */
        public readLine(): java.lang.String;
        /**
         * 
         */
        public readChar(): char;
        /**
         * 
         * @param {int} n 
         */
        public skipBytes(n: int): int;
        /**
         * 
         */
        public readUTF(): java.lang.String;
        /**
         * 
         */
        public readLong(): long;
        /**
         * 
         */
        public readShort(): short;
        /**
         * 
         * @param {byte[]} b 
         * @param {int} off 
         * @param {int} len 
         */
        public readFully(b: byte[],off: int,len: int): void;
        /**
         * 
         * @param {byte[]} b 
         */
        public readFully(b: byte[]): void;
        /**
         * 
         */
        public readDouble(): double;
        /**
         * 
         */
        public isNetwork(): boolean;
        /**
         * 
         */
        public readFloat(): float;
        /**
         * 
         */
        public readBoolean(): boolean;
        /**
         * 
         */
        public readInt(): int;
        /**
         * 
         */
        public readByte(): byte;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public readUnsignedByte(): int;
        /**
         * 
         */
        public readUnsignedShort(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class ItemBreakParticle extends cn.nukkit.level.particle.Particle{
        /**  */
        data: int;
        /**
         * 
         */
        public encode(): cn.nukkit.network.protocol.DataPacket[];
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityHopper extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        temporalVector: cn.nukkit.math.BlockVector3;
        /**  */
        transferCooldown: int;
        /**  */
        disabled: boolean;
        /**  */
        pickupArea: cn.nukkit.math.AxisAlignedBB;
        /**  */
        inventory: cn.nukkit.inventory.HopperInventory;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public onBreak(): void;
        /**
         * 
         */
        public hasName(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {boolean} disabled 
         */
        public setDisabled(disabled: boolean): void;
        /**
         * 
         * @param {int} index 
         */
        public getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public isObservable(): boolean;
        /**
         * 
         */
        public pickupItems(): boolean;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         * @param {int} index 
         */
        protected getSlotIndex(index: int): int;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public pullItems(): boolean;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public isDisabled(): boolean;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.HopperInventory;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public isOnTransferCooldown(): boolean;
        /**
         * 
         */
        public onUpdate(): boolean;
        /**
         * 
         * @param {int} transferCooldown 
         */
        public setTransferCooldown(transferCooldown: int): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(index: int,item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public pushItems(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockAir extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public canBePlaced(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
    }
}
declare namespace cn.nukkit.level.biome.impl.savanna{
     class SavannaPlateauMBiome extends cn.nukkit.level.biome.impl.savanna.SavannaPlateauBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public doesOverhang(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemNetherBrick extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.utils{
     class LevelException extends cn.nukkit.utils.ServerException{
    }
}
declare namespace cn.nukkit.item{
     class ItemCarrotGolden extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.item{
     class ItemLeggingsGold extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isLeggings(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockSeaLantern extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class ColdTaigaMBiome extends cn.nukkit.level.biome.impl.taiga.ColdTaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public doesOverhang(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedLightBlue extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockWeightedPressurePlateHeavy extends cn.nukkit.block.BlockPressurePlateBase{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getMaxWeight(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        protected computeRedstoneStrength(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemBed extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockSlabWood extends cn.nukkit.block.BlockSlab{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.block.BlockSlab} slab 
         */
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getSlabName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        public setWoodType(type: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class NetworkStackLatencyPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        unknownBool: boolean;
        /**  */
        timestamp: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item.enchantment.trident{
    abstract class EnchantmentTrident extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class ColdTaigaHillsBiome extends cn.nukkit.level.biome.impl.taiga.ColdTaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityItem extends cn.nukkit.entity.Entity{
        /**  */
        owner: java.lang.String;
        /**  */
        pickupDelay: int;
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        NETWORK_ID: int;
        /**  */
        thrower: java.lang.String;
        /**  */
        DATA_SOURCE_ID: int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getOwner(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} owner 
         */
        public setOwner(owner: java.lang.String): void;
        /**
         * 
         */
        public getThrower(): java.lang.String;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {int} seconds 
         */
        public setOnFire(seconds: int): void;
        /**
         * 
         */
        public getDrag(): float;
        /**
         * 
         * @param {java.lang.String} thrower 
         */
        public setThrower(thrower: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public getGravity(): float;
        /**
         * 
         */
        protected getBaseOffset(): float;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {int} pickupDelay 
         */
        public setPickupDelay(pickupDelay: int): void;
        /**
         * 
         */
        public canCollide(): boolean;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        public getPickupDelay(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public doesTriggerPressurePlate(): boolean;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemBeetrootSoup extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.block{
     class BlockWood2 extends cn.nukkit.block.BlockWood{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        ACACIA: int;
        /**  */
        NEW_LOG_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        DARK_OAK: int;
        /**
         * 
         */
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} woodType 
         */
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.extremehills{
     class StoneBeachBiome extends cn.nukkit.level.biome.type.CoveredBiome{
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundDepth(y: int): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} y 
         */
        public getGroundBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceDepth(y: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneComparatorPowered extends cn.nukkit.block.BlockRedstoneComparator{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected getPowered(): cn.nukkit.block.BlockRedstoneComparator;
        /**
         * 
         */
        protected  getPowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.math{
     class SimpleAxisAlignedBB extends java.lang.Object{
        /**  */
        minY: double;
        /**  */
        minX: double;
        /**  */
        maxZ: double;
        /**  */
        maxY: double;
        /**  */
        maxX: double;
        /**  */
        minZ: double;
        /**
         * 
         * @param {double} minY 
         */
        public setMinY(minY: double): void;
        /**
         * 
         * @param {double} minX 
         */
        public setMinX(minX: double): void;
        /**
         * 
         * @param {double} minZ 
         */
        public setMinZ(minZ: double): void;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         * @param {double} maxZ 
         */
        public setMaxZ(maxZ: double): void;
        /**
         * 
         */
        public clone(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {double} maxY 
         */
        public setMaxY(maxY: double): void;
        /**
         * 
         * @param {double} maxX 
         */
        public setMaxX(maxX: double): void;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public getMinY(): double;
    }
}
declare namespace cn.nukkit.block{
     class BlockSandstone extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        CHISELED: int;
        /**  */
        SAND_STONE_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        SMOOTH: int;
        /**  */
        NORMAL: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getSandstoneType(): cn.nukkit.blockproperty.value.SandStoneType;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.SandStoneType} sandStoneType 
         */
        public setSandstoneType(sandStoneType: cn.nukkit.blockproperty.value.SandStoneType): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.command{
    abstract class CommandMap extends java.lang.Object{
        /**
         * 
         */
        public abstract clearCommands(): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} cmdLine 
         */
        public abstract dispatch(sender: cn.nukkit.command.CommandSender,cmdLine: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public abstract getCommand(name: java.lang.String): cn.nukkit.command.Command;
        /**
         * 
         * @param {java.lang.Object} object 
         */
        public abstract registerSimpleCommands(object: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.String} fallbackPrefix 
         * @param {java.util.List} commands 
         */
        public abstract registerAll(fallbackPrefix: java.lang.String,commands: java.util.List): void;
        /**
         * 
         * @param {java.lang.String} fallbackPrefix 
         * @param {cn.nukkit.command.Command} command 
         * @param {java.lang.String} label 
         */
        public abstract register(fallbackPrefix: java.lang.String,command: cn.nukkit.command.Command,label: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} fallbackPrefix 
         * @param {cn.nukkit.command.Command} command 
         */
        public abstract register(fallbackPrefix: java.lang.String,command: cn.nukkit.command.Command): boolean;
    }
}
declare namespace javax.script{
    abstract class ScriptEngine extends java.lang.Object{
        /**  */
        LANGUAGE: java.lang.String;
        /**  */
        ENGINE: java.lang.String;
        /**  */
        ENGINE_VERSION: java.lang.String;
        /**  */
        LANGUAGE_VERSION: java.lang.String;
        /**  */
        FILENAME: java.lang.String;
        /**  */
        ARGV: java.lang.String;
        /**  */
        NAME: java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {javax.script.ScriptContext} arg1 
         */
        public abstract eval(arg0: java.lang.String,arg1: javax.script.ScriptContext): java.lang.Object;
        /**
         * 
         * @param {java.io.Reader} arg0 
         */
        public abstract eval(arg0: java.io.Reader): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {javax.script.Bindings} arg1 
         */
        public abstract eval(arg0: java.lang.String,arg1: javax.script.Bindings): java.lang.Object;
        /**
         * 
         * @param {java.io.Reader} arg0 
         * @param {javax.script.Bindings} arg1 
         */
        public abstract eval(arg0: java.io.Reader,arg1: javax.script.Bindings): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public abstract eval(arg0: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.io.Reader} arg0 
         * @param {javax.script.ScriptContext} arg1 
         */
        public abstract eval(arg0: java.io.Reader,arg1: javax.script.ScriptContext): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public abstract get(arg0: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getBindings(arg0: int): javax.script.Bindings;
        /**
         * 
         * @param {javax.script.ScriptContext} arg0 
         */
        public abstract setContext(arg0: javax.script.ScriptContext): void;
        /**
         * 
         * @param {javax.script.Bindings} arg0 
         * @param {int} arg1 
         */
        public abstract setBindings(arg0: javax.script.Bindings,arg1: int): void;
        /**
         * 
         */
        public abstract getFactory(): javax.script.ScriptEngineFactory;
        /**
         * 
         */
        public abstract createBindings(): javax.script.Bindings;
        /**
         * 
         */
        public abstract getContext(): javax.script.ScriptContext;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.Object} arg1 
         */
        public abstract put(arg0: java.lang.String,arg1: java.lang.Object): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemFirework extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public clearExplosions(): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        private spawnFirework(level: cn.nukkit.level.Level,pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.ItemFirework.FireworkExplosion} explosion 
         */
        public addExplosion(explosion: cn.nukkit.item.ItemFirework.FireworkExplosion): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetTitlePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        xuid: java.lang.String;
        /**  */
        TYPE_SUBTITLE: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        TYPE_ACTION_BAR: int;
        /**  */
        platformOnlineId: java.lang.String;
        /**  */
        type: int;
        /**  */
        fadeInTime: int;
        /**  */
        stayTime: int;
        /**  */
        TYPE_CLEAR: int;
        /**  */
        TYPE_RESET: int;
        /**  */
        text: java.lang.String;
        /**  */
        TITLE_ACTIONS: cn.nukkit.network.protocol.SetTitlePacket.TitleAction[];
        /**  */
        TYPE_TITLE: int;
        /**  */
        TYPE_ANIMATION_TIMES: int;
        /**  */
        fadeOutTime: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public getFadeInTime(): int;
        /**
         * 
         * @param {int} fadeOutTime 
         */
        public setFadeOutTime(fadeOutTime: int): void;
        /**
         * 
         */
        public getText(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} xuid 
         */
        public setXuid(xuid: java.lang.String): void;
        /**
         * 
         */
        public getXuid(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public getPlatformOnlineId(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.network.protocol.SetTitlePacket.TitleAction} type 
         */
        public setTitleAction(type: cn.nukkit.network.protocol.SetTitlePacket.TitleAction): void;
        /**
         * 
         * @param {int} stayTime 
         */
        public setStayTime(stayTime: int): void;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         */
        public getFadeOutTime(): int;
        /**
         * 
         */
        public getStayTime(): int;
        /**
         * 
         * @param {int} fadeInTime 
         */
        public setFadeInTime(fadeInTime: int): void;
        /**
         * 
         */
        public getTitleAction(): cn.nukkit.network.protocol.SetTitlePacket.TitleAction;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} platformOnlineId 
         */
        public setPlatformOnlineId(platformOnlineId: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} text 
         */
        public setText(text: java.lang.String): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetHealthPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        health: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockGlassPane extends cn.nukkit.block.BlockThin{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemBread extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.level.format.anvil{
     class Chunk extends cn.nukkit.level.format.generic.BaseChunk{
        /**  */
        terrainPopulated: boolean;
        /**  */
        terrainGenerated: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        inhabitedTime: long;
        /**
         * 
         */
        public isPopulated(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockLight(x: int,y: int,z: int): int;
        /**
         * 
         */
        public getNBT(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public compress(): boolean;
        /**
         * 
         */
        public toBinary(): byte[];
        /**
         * 
         * @param {byte[]} data 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         */
        public static fromBinary(data: byte[],provider: cn.nukkit.level.format.LevelProvider): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         * @param {byte[]} data 
         */
        public static fromBinary(data: byte[]): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         * @param {boolean} value 
         */
        public setPopulated(value: boolean): void;
        /**
         * 
         */
        public setPopulated(): void;
        /**
         * 
         * @param {byte[]} data 
         */
        public static fromFastBinary(data: byte[]): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         * @param {byte[]} data 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         */
        public static fromFastBinary(data: byte[],provider: cn.nukkit.level.format.LevelProvider): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         */
        public isGenerated(): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public setGenerated(value: boolean): void;
        /**
         * 
         */
        public setGenerated(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         */
        public clone(): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         */
        public  clone(): cn.nukkit.level.format.generic.BaseChunk;
        /**
         * 
         */
        public  clone(): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public toFastBinary(): byte[];
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public static getEmptyChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         */
        public static getEmptyChunk(chunkX: int,chunkZ: int,provider: cn.nukkit.level.format.LevelProvider): cn.nukkit.level.format.anvil.Chunk;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class QQGroupMessageEvent extends cn.nukkit.event.Event{
        /**  */
        fromQQ: java.lang.String;
        /**  */
        selfQQ: java.lang.String;
        /**  */
        fromGroup: java.lang.String;
        /**  */
        message: java.lang.String;
        /**
         * 
         */
        public getFromQQ(): java.lang.String;
        /**
         * 
         */
        public getSelfQQ(): java.lang.String;
        /**
         * 
         */
        public getFromGroup(): java.lang.String;
        /**
         * 
         */
        public getMessage(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemAxeStone extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityLevelChangeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        originLevel: cn.nukkit.level.Level;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        targetLevel: cn.nukkit.level.Level;
        /**
         * 
         */
        public getTarget(): cn.nukkit.level.Level;
        /**
         * 
         */
        public getOrigin(): cn.nukkit.level.Level;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.level{
    abstract class ChunkLoader extends java.lang.Object{
        /**  */
        EMPTY_ARRAY: cn.nukkit.level.ChunkLoader[];
        /**
         * 
         */
        public abstract getLevel(): cn.nukkit.level.Level;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract onChunkLoaded(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         */
        public abstract getX(): double;
        /**
         * 
         */
        public abstract getPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public abstract getZ(): double;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract onChunkPopulated(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract onChunkUnloaded(chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         */
        public abstract getLoaderId(): int;
        /**
         * 
         */
        public abstract isLoaderActive(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} block 
         */
        public abstract onBlockChanged(block: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract onChunkChanged(chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class JungleTreePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ResourcePackDataInfoPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        sha256: byte[];
        /**  */
        NETWORK_ID: byte;
        /**  */
        chunkCount: int;
        /**  */
        TYPE_RESOURCE: int;
        /**  */
        TYPE_BEHAVIOR: int;
        /**  */
        TYPE_COUNT: int;
        /**  */
        type: int;
        /**  */
        TYPE_INVALID: int;
        /**  */
        TYPE_COPY_PROTECTED: int;
        /**  */
        compressedPackSize: long;
        /**  */
        packId: java.util.UUID;
        /**  */
        TYPE_SKINS: int;
        /**  */
        premium: boolean;
        /**  */
        TYPE_WORLD_TEMPLATE: int;
        /**  */
        TYPE_CACHED: int;
        /**  */
        TYPE_PERSONA_PIECE: int;
        /**  */
        TYPE_ADDON: int;
        /**  */
        maxChunkSize: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item.enchantment.loot{
    abstract class EnchantmentLoot extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.command.defaults{
     class DebugPasteCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        USER_AGENT: java.lang.String;
        /**  */
        ENDPOINT: java.lang.String;
        /**
         * 
         * @param {java.lang.String} line 
         */
        private static lambda$uploadLast$3(line: java.lang.String): boolean;
        /**
         * 
         * @param {java.nio.file.Path} file 
         */
        private static lambda$uploadLast$2(file: java.nio.file.Path): java.lang.Long;
        /**
         * 
         * @param {java.nio.file.Path} x$0 
         */
        private static lambda$uploadLast$1(x$0: java.nio.file.Path): boolean;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} arg0 
         * @param {java.nio.file.Path} arg1 
         */
        static access$400(arg0: cn.nukkit.command.CommandSender,arg1: java.nio.file.Path): void;
        /**
         * 
         */
        static access$300(): org.apache.logging.log4j.Logger;
        /**
         * 
         * @param {java.lang.String[]} arg0 
         */
        static access$200(arg0: java.lang.String[]): java.lang.String;
        /**
         * 
         * @param {java.nio.file.Path} file 
         */
        private static filterValidPastes(file: java.nio.file.Path): boolean;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.nio.file.Path} zipPath 
         */
        private static upload(sender: cn.nukkit.command.CommandSender,zipPath: java.nio.file.Path): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} arg0 
         */
        static access$100(arg0: cn.nukkit.command.CommandSender): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} arg0 
         */
        static access$000(arg0: cn.nukkit.command.CommandSender): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         */
        private static clear(sender: cn.nukkit.command.CommandSender): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         */
        private static uploadLast(sender: cn.nukkit.command.CommandSender): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
        /**
         * 
         * @param {java.lang.String[]} command 
         */
        private static  eval(...command: java.lang.String[]): java.lang.String;
        /**
         * 
         * @param {java.util.concurrent.atomic.AtomicInteger} count 
         * @param {java.nio.file.Path} file 
         */
        private static lambda$clear$0(count: java.util.concurrent.atomic.AtomicInteger,file: java.nio.file.Path): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockWallSign extends cn.nukkit.block.BlockSignPost{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getSignDirection(): cn.nukkit.math.CompassRoseDirection;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.math.CompassRoseDirection} direction 
         */
        public setSignDirection(direction: cn.nukkit.math.CompassRoseDirection): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        protected getPostId(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getWallId(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockPumpkinLit extends cn.nukkit.block.BlockPumpkin{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockObsidianGlowing extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentVanishingCurse extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemDiamond extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerBucketFillEvent extends cn.nukkit.event.player.PlayerBucketEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getBucket(): cn.nukkit.item.Item;
        /**
         * 
         */
        public  getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public  setItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public  getBlockClicked(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerToggleSprintEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        isSprinting: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isSprinting(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemQuartz extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.network.protocol{
     class SpawnParticleEffectPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        identifier: java.lang.String;
        /**  */
        dimensionId: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        uniqueEntityId: long;
        /**  */
        position: cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockWaterLily extends cn.nukkit.block.BlockFlowable{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockTransparentMeta extends cn.nukkit.block.BlockMeta{
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class FakeSlotChangeEvent extends cn.nukkit.event.Event{
        /**  */
        parent: com.nukkitx.fakeinventories.inventory.FakeSlotChangeEvent;
        /**
         * 
         */
        public getParent(): com.nukkitx.fakeinventories.inventory.FakeSlotChangeEvent;
        /**
         * 
         */
        public isCancelled(): boolean;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         * @param {boolean} value 
         */
        public setCancelled(value: boolean): void;
        /**
         * 
         */
        public setCancelled(): void;
        /**
         * 
         */
        public getAction(): cn.nukkit.inventory.transaction.action.SlotChangeAction;
        /**
         * 
         */
        public getInventory(): com.nukkitx.fakeinventories.inventory.FakeInventory;
    }
}
declare namespace cn.nukkit.command.defaults{
     class SayCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceGateSpruce extends cn.nukkit.block.BlockFenceGate{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.utils{
     class ServerException extends java.lang.RuntimeException{
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordCat extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace com.blocklynukkit.loader.other.net.websocket{
     class WsClient extends org.java_websocket.client.WebSocketClient{
        /**  */
        __self: com.blocklynukkit.loader.other.net.websocket.WsClient;
        /**  */
        openCallback: java.lang.String;
        /**  */
        messageStringCallback: java.lang.String;
        /**  */
        messageDataCallback: java.lang.String;
        /**  */
        serverUrl: java.lang.String;
        /**  */
        closeCallback: java.lang.String;
        /**  */
        workingThread: java.lang.Thread;
        /**
         * 
         * @param {int} code 
         * @param {java.lang.String} reason 
         * @param {boolean} remote 
         */
        public onClose(code: int,reason: java.lang.String,remote: boolean): void;
        /**
         * 
         * @param {java.lang.Exception} ex 
         */
        public onError(ex: java.lang.Exception): void;
        /**
         * 
         * @param {org.java_websocket.handshake.ServerHandshake} handshakeData 
         */
        public onOpen(handshakeData: org.java_websocket.handshake.ServerHandshake): void;
        /**
         * 
         * @param {java.nio.ByteBuffer} message 
         */
        public onMessage(message: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public onMessage(message: java.lang.String): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemEndCrystal extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorOre extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        replaceId: int;
        /**  */
        oreTypes: cn.nukkit.level.generator.object.ore.OreType[];
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {cn.nukkit.level.generator.object.ore.OreType[]} oreTypes 
         */
        public setOreTypes(oreTypes: cn.nukkit.level.generator.object.ore.OreType[]): void;
    }
}
declare namespace cn.nukkit.entity{
     class EntityHuman extends cn.nukkit.entity.EntityHumanType{
        /**  */
        rawUUID: byte[];
        /**  */
        DATA_PLAYER_FLAGS: int;
        /**  */
        DATA_PLAYER_FLAG_DEAD: int;
        /**  */
        skin: cn.nukkit.entity.data.Skin;
        /**  */
        DATA_PLAYER_FLAG_SLEEP: int;
        /**  */
        DATA_PLAYER_BED_POSITION: int;
        /**  */
        DATA_PLAYER_BUTTON_TEXT: int;
        /**  */
        uuid: java.util.UUID;
        /**
         * 
         */
        public getRawUniqueId(): byte[];
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {java.lang.String} s 
         */
        private static lambda$saveNBT$1(s: java.lang.String): cn.nukkit.nbt.tag.StringTag;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public despawnFrom(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getEyeHeight(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.StringTag} stringTag 
         */
        private static lambda$initEntity$0(stringTag: cn.nukkit.nbt.tag.StringTag): java.lang.String;
        /**
         * 
         */
        public getUniqueId(): java.util.UUID;
        /**
         * 
         * @param {cn.nukkit.entity.data.Skin} skin 
         */
        public setSkin(skin: cn.nukkit.entity.data.Skin): void;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {double} headYaw 
         */
        public addMovement(x: double,y: double,z: double,yaw: double,pitch: double,headYaw: double): void;
        /**
         * 
         */
        public getSwimmingHeight(): float;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {boolean} animate 
         */
        protected onBlock(entity: cn.nukkit.entity.Entity,animate: boolean): void;
        /**
         * 
         */
        public getSkin(): cn.nukkit.entity.data.Skin;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        protected getBaseOffset(): float;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityMotionEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        motion: cn.nukkit.math.Vector3;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getMotion(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getVector(): cn.nukkit.math.Vector3;
    }
}
declare namespace cn.nukkit.item.enchantment.damage{
     class EnchantmentDamageSmite extends cn.nukkit.item.enchantment.damage.EnchantmentDamage{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getDamageBonus(entity: cn.nukkit.entity.Entity): double;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.utils{
    abstract class PlayerDataSerializer extends java.lang.Object{
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.UUID} uuid 
         */
        public abstract read(name: java.lang.String,uuid: java.util.UUID): java.util.Optional;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.UUID} uuid 
         */
        public abstract write(name: java.lang.String,uuid: java.util.UUID): java.io.OutputStream;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AvailableCommandsPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        ARG_TYPE_TARGET: int;
        /**  */
        softEnums: java.util.Map;
        /**  */
        ARG_TYPE_VALUE: int;
        /**  */
        ARG_FLAG_ENUM: int;
        /**  */
        ARG_TYPE_RAWTEXT: int;
        /**  */
        ARG_TYPE_WILDCARD_INT: int;
        /**  */
        WRITE_INT: java.util.function.ObjIntConsumer;
        /**  */
        ARG_TYPE_FILE_PATH: int;
        /**  */
        commands: java.util.Map;
        /**  */
        WRITE_SHORT: java.util.function.ObjIntConsumer;
        /**  */
        ARG_TYPE_MESSAGE: int;
        /**  */
        ARG_TYPE_POSITION: int;
        /**  */
        ARG_TYPE_JSON: int;
        /**  */
        ARG_TYPE_WILDCARD_TARGET: int;
        /**  */
        ARG_TYPE_COMMAND: int;
        /**  */
        ARG_TYPE_BLOCK_POSITION: int;
        /**  */
        ARG_TYPE_STRING: int;
        /**  */
        ARG_FLAG_SOFT_ENUM: int;
        /**  */
        WRITE_BYTE: java.util.function.ObjIntConsumer;
        /**  */
        ARG_TYPE_FLOAT: int;
        /**  */
        ARG_TYPE_INT: int;
        /**  */
        ARG_TYPE_OPERATOR: int;
        /**  */
        ARG_FLAG_VALID: int;
        /**  */
        ARG_FLAG_POSTFIX: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} s 
         * @param {int} v 
         */
        private static lambda$static$0(s: cn.nukkit.utils.BinaryStream,v: int): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         * @param {java.util.List} enumValues 
         * @param {java.util.function.ObjIntConsumer} indexWriter 
         * @param {cn.nukkit.command.data.CommandEnum} cmdEnum 
         */
        private lambda$encode$2(enumValues: java.util.List,indexWriter: java.util.function.ObjIntConsumer,cmdEnum: cn.nukkit.command.data.CommandEnum): void;
        /**
         * 
         * @param {java.util.LinkedHashSet} enumsSet 
         * @param {java.util.LinkedHashSet} enumValuesSet 
         * @param {java.util.LinkedHashSet} postFixesSet 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.command.data.CommandDataVersions} data 
         */
        private static lambda$encode$1(enumsSet: java.util.LinkedHashSet,enumValuesSet: java.util.LinkedHashSet,postFixesSet: java.util.LinkedHashSet,name: java.lang.String,data: cn.nukkit.command.data.CommandDataVersions): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.List} values 
         */
        private lambda$encode$4(name: java.lang.String,values: java.util.List): void;
        /**
         * 
         * @param {java.util.List} enums 
         * @param {java.util.List} postFixes 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.command.data.CommandDataVersions} cmdData 
         */
        private lambda$encode$3(enums: java.util.List,postFixes: java.util.List,name: java.lang.String,cmdData: cn.nukkit.command.data.CommandDataVersions): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class PortalParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntitySquid extends cn.nukkit.entity.passive.EntityWaterAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class GameRulesChangedPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        gameRules: cn.nukkit.level.GameRules;
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemFlint extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.biome{
     class EnumBiome extends java.lang.Enum{
        /**  */
        BEACH: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SAVANNA: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SUNFLOWER_PLAINS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MEGA_TAIGA: cn.nukkit.level.biome.EnumBiome;
        /**  */
        FROZEN_OCEAN: cn.nukkit.level.biome.EnumBiome;
        /**  */
        BIRCH_FOREST: cn.nukkit.level.biome.EnumBiome;
        /**  */
        COLD_TAIGA: cn.nukkit.level.biome.EnumBiome;
        /**  */
        FLOWER_FOREST: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SAVANNA_PLATEAU_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        EXTREME_HILLS_EDGE: cn.nukkit.level.biome.EnumBiome;
        /**  */
        id: int;
        /**  */
        HELL: cn.nukkit.level.biome.EnumBiome;
        /**  */
        COLD_BEACH: cn.nukkit.level.biome.EnumBiome;
        /**  */
        $VALUES: cn.nukkit.level.biome.EnumBiome[];
        /**  */
        MEGA_SPRUCE_TAIGA: cn.nukkit.level.biome.EnumBiome;
        /**  */
        BIRCH_FOREST_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MUSHROOM_ISLAND_SHORE: cn.nukkit.level.biome.EnumBiome;
        /**  */
        JUNGLE: cn.nukkit.level.biome.EnumBiome;
        /**  */
        OCEAN: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SWAMPLAND_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        FROZEN_RIVER: cn.nukkit.level.biome.EnumBiome;
        /**  */
        STONE_BEACH: cn.nukkit.level.biome.EnumBiome;
        /**  */
        EXTREME_HILLS_PLUS_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        ROOFED_FOREST_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MEGA_TAIGA_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        EXTREME_HILLS_PLUS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        biome: cn.nukkit.level.biome.Biome;
        /**  */
        PLAINS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        TAIGA_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SAVANNA_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MESA_PLATEAU_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SAVANNA_PLATEAU: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MESA_PLATEAU_F: cn.nukkit.level.biome.EnumBiome;
        /**  */
        JUNGLE_EDGE: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MESA: cn.nukkit.level.biome.EnumBiome;
        /**  */
        RIVER: cn.nukkit.level.biome.EnumBiome;
        /**  */
        BIRCH_FOREST_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        DESERT_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MUSHROOM_ISLAND: cn.nukkit.level.biome.EnumBiome;
        /**  */
        TAIGA_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        ICE_PLAINS_SPIKES: cn.nukkit.level.biome.EnumBiome;
        /**  */
        EXTREME_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MESA_PLATEAU_F_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MESA_PLATEAU: cn.nukkit.level.biome.EnumBiome;
        /**  */
        BIRCH_FOREST_HILLS_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        EXTREME_HILLS_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        JUNGLE_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        DEEP_OCEAN: cn.nukkit.level.biome.EnumBiome;
        /**  */
        TAIGA: cn.nukkit.level.biome.EnumBiome;
        /**  */
        COLD_TAIGA_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        DESERT: cn.nukkit.level.biome.EnumBiome;
        /**  */
        FOREST: cn.nukkit.level.biome.EnumBiome;
        /**  */
        FOREST_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        ICE_PLAINS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        JUNGLE_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        COLD_TAIGA_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        JUNGLE_EDGE_M: cn.nukkit.level.biome.EnumBiome;
        /**  */
        MESA_BRYCE: cn.nukkit.level.biome.EnumBiome;
        /**  */
        SWAMP: cn.nukkit.level.biome.EnumBiome;
        /**  */
        DESERT_HILLS: cn.nukkit.level.biome.EnumBiome;
        /**  */
        ROOFED_FOREST: cn.nukkit.level.biome.EnumBiome;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.level.biome.EnumBiome;
        /**
         * 
         */
        public static values(): cn.nukkit.level.biome.EnumBiome[];
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getBiome(name: java.lang.String): cn.nukkit.level.biome.Biome;
        /**
         * 
         * @param {int} id 
         */
        public static getBiome(id: int): cn.nukkit.level.biome.Biome;
    }
}
declare namespace cn.nukkit.item{
     class ItemPumpkinPie extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemDurable extends java.lang.Object{
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerMouseOverEntityEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        entity: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.event.entity{
     class CreatureSpawnEvent extends cn.nukkit.event.Event{
        /**  */
        entityNetworkId: int;
        /**  */
        reason: cn.nukkit.event.entity.CreatureSpawnEvent.SpawnReason;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        compoundTag: cn.nukkit.nbt.tag.CompoundTag;
        /**  */
        position: cn.nukkit.level.Position;
        /**
         * 
         */
        public getPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public getCompoundTag(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getReason(): cn.nukkit.event.entity.CreatureSpawnEvent.SpawnReason;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getEntityNetworkId(): int;
    }
}
declare namespace cn.nukkit.inventory{
     class FurnaceRecipe extends java.lang.Object{
        /**  */
        output: cn.nukkit.item.Item;
        /**  */
        ingredient: cn.nukkit.item.Item;
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.RecipeType;
        /**
         * 
         */
        public getResult(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingManager} manager 
         */
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void;
        /**
         * 
         */
        public getInput(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setInput(item: cn.nukkit.item.Item): void;
    }
}
declare namespace com.blocklynukkit.loader.other.Entities{
     class FloatingItemManager extends java.lang.Object{
        /**  */
        random: java.util.Random;
        /**  */
        displayMap: java.util.HashMap;
        /**
         * 
         * @param {cn.nukkit.event.level.LevelUnloadEvent} event 
         */
        public onLevelDelete(event: cn.nukkit.event.level.LevelUnloadEvent): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         * @param {cn.nukkit.item.Item} item 
         */
        public removeFloatingItem(pos: cn.nukkit.level.Position,item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {java.util.Map.Entry} BN 
         */
        public forceAddFloatingItem(player: cn.nukkit.Player,BN: java.util.Map.Entry): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         * @param {cn.nukkit.item.Item} item 
         */
        public addFloatingItem(pos: cn.nukkit.level.Position,item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {java.util.Map.Entry} bn 
         */
        public forceRemoveFloatingItem(player: cn.nukkit.Player,bn: java.util.Map.Entry): void;
        /**
         * 
         * @param {cn.nukkit.event.level.LevelUnloadEvent} event 
         * @param {java.util.Map.Entry} entryLongEntry 
         */
        private static lambda$onLevelDelete$0(event: cn.nukkit.event.level.LevelUnloadEvent,entryLongEntry: java.util.Map.Entry): boolean;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerJoinEvent} event 
         */
        public playerJoin(event: cn.nukkit.event.player.PlayerJoinEvent): void;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerTeleportEvent} event 
         */
        public playerTeleport(event: cn.nukkit.event.player.PlayerTeleportEvent): void;
    }
}
declare namespace com.blocklynukkit.loader.script.window.windowCallbacks{
    abstract class WindowCallback extends java.lang.Object{
        /**  */
        acceptClose: boolean;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 
         */
        public abstract call(event: cn.nukkit.event.player.PlayerFormRespondedEvent): void;
        /**
         * 
         * @param {boolean} acceptClose 
         */
        public setAcceptClose(acceptClose: boolean): void;
        /**
         * 
         */
        public isAcceptClose(): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ContainerClosePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        wasServerInitiated: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        windowId: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemPickaxeDiamond extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockPlanks extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        SPRUCE: int;
        /**  */
        BIRCH: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        JUNGLE: int;
        /**  */
        ACACIA: int;
        /**  */
        OAK: int;
        /**  */
        DARK_OAK: int;
        /**
         * 
         */
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        public setWoodType(type: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockNetherrack extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemScrapNetherite extends cn.nukkit.item.Item{
        /**
         * 
         */
        public isLavaResistant(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreCoal extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerDropItemEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        drop: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedBrown extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentFireAspect extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getAttackSideEffects(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public doPostAttack(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.event.server{
    abstract class ServerEvent extends cn.nukkit.event.Event{
    }
}
declare namespace cn.nukkit.block{
     class BlockDoublePlant extends cn.nukkit.block.BlockFlowable{
        /**  */
        LILAC: int;
        /**  */
        PEONY: int;
        /**  */
        TALL_GRASS: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        SUNFLOWER: int;
        /**  */
        TOP_HALF_BITMASK: int;
        /**  */
        DOUBLE_PLANT_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        LARGE_FERN: int;
        /**  */
        ROSE_BUSH: int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         * @param {boolean} topHalf 
         */
        public setTopHalf(topHalf: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public isTopHalf(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getDoublePlantType(): cn.nukkit.blockproperty.value.DoublePlantType;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.DoublePlantType} type 
         */
        public setDoublePlantType(type: cn.nukkit.blockproperty.value.DoublePlantType): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} support 
         */
        private isSupportValid(support: cn.nukkit.block.Block): boolean;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityChest extends cn.nukkit.blockentity.BlockEntitySpawnableContainer{
        /**  */
        doubleInventory: cn.nukkit.inventory.DoubleChestInventory;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public onBreak(): void;
        /**
         * 
         */
        public hasName(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityChest} chest 
         */
        public createPair(chest: cn.nukkit.blockentity.BlockEntityChest): void;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         */
        public getPair(): cn.nukkit.blockentity.BlockEntityChest;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public isPaired(): boolean;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public unpair(): boolean;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.BaseInventory;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityChest} chest 
         */
        public pairWith(chest: cn.nukkit.blockentity.BlockEntityChest): boolean;
        /**
         * 
         */
        public getRealInventory(): cn.nukkit.inventory.ChestInventory;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        protected checkPairing(): void;
    }
}
declare namespace cn.nukkit.event.entity{
     class ProjectileHitEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        movingObjectPosition: cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         */
        public getMovingObjectPosition(): cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.level.MovingObjectPosition} movingObjectPosition 
         */
        public setMovingObjectPosition(movingObjectPosition: cn.nukkit.level.MovingObjectPosition): void;
    }
}
declare namespace cn.nukkit.level.generator.noise.vanilla.f{
     class NoiseGeneratorPerlinF extends java.lang.Object{
        /**  */
        noiseLevels: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorSimplexF[];
        /**  */
        levels: int;
        /**
         * 
         * @param {float} p_151601_1_ 
         * @param {float} p_151601_3_ 
         */
        public getValue(p_151601_1_: float,p_151601_3_: float): float;
        /**
         * 
         * @param {float[]} p_151600_1_ 
         * @param {float} p_151600_2_ 
         * @param {float} p_151600_4_ 
         * @param {int} p_151600_6_ 
         * @param {int} p_151600_7_ 
         * @param {float} p_151600_8_ 
         * @param {float} p_151600_10_ 
         * @param {float} p_151600_12_ 
         * @param {float} p_151600_14_ 
         */
        public getRegion(p_151600_1_: float[],p_151600_2_: float,p_151600_4_: float,p_151600_6_: int,p_151600_7_: int,p_151600_8_: float,p_151600_10_: float,p_151600_12_: float,p_151600_14_: float): float[];
        /**
         * 
         * @param {float[]} p_151599_1_ 
         * @param {float} p_151599_2_ 
         * @param {float} p_151599_4_ 
         * @param {int} p_151599_6_ 
         * @param {int} p_151599_7_ 
         * @param {float} p_151599_8_ 
         * @param {float} p_151599_10_ 
         * @param {float} p_151599_12_ 
         */
        public getRegion(p_151599_1_: float[],p_151599_2_: float,p_151599_4_: float,p_151599_6_: int,p_151599_7_: int,p_151599_8_: float,p_151599_10_: float,p_151599_12_: float): float[];
    }
}
declare namespace cn.nukkit.math{
    abstract class AxisAlignedBB extends java.lang.Object{
        /**  */
        EMPTY_ARRAY: cn.nukkit.math.AxisAlignedBB[];
        /**
         * 
         * @param {double} minY 
         */
        public setMinY(minY: double): void;
        /**
         * 
         * @param {double} minX 
         */
        public setMinX(minX: double): void;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {double} x 
         */
        public calculateXOffset(bb: cn.nukkit.math.AxisAlignedBB,x: double): double;
        /**
         * 
         * @param {double} minZ 
         */
        public setMinZ(minZ: double): void;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {double} z 
         */
        public calculateZOffset(bb: cn.nukkit.math.AxisAlignedBB,z: double): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public isVectorInside(vector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public isVectorInYZ(vector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public getOffsetBoundingBox(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public getOffsetBoundingBox(face: cn.nukkit.math.BlockFace,x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public addCoord(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public grow(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos1 
         * @param {cn.nukkit.math.Vector3} pos2 
         */
        public calculateIntercept(pos1: cn.nukkit.math.Vector3,pos2: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public offset(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public intersectsWith(bb: cn.nukkit.math.AxisAlignedBB): boolean;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public shrink(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB.BBConsumer} action 
         */
        public forEach(action: cn.nukkit.math.AxisAlignedBB.BBConsumer): void;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public setBB(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public contract(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public abstract getMaxX(): double;
        /**
         * 
         */
        public abstract getMaxY(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public isVectorInXZ(vector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public isVectorInXY(vector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {double} minX 
         * @param {double} minY 
         * @param {double} minZ 
         * @param {double} maxX 
         * @param {double} maxY 
         * @param {double} maxZ 
         */
        public setBounds(minX: double,minY: double,minZ: double,maxX: double,maxY: double,maxZ: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getAverageEdgeLength(): double;
        /**
         * 
         */
        public abstract getMaxZ(): double;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {double} y 
         */
        public calculateYOffset(bb: cn.nukkit.math.AxisAlignedBB,y: double): double;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public expand(x: double,y: double,z: double): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {double} maxZ 
         */
        public setMaxZ(maxZ: double): void;
        /**
         * 
         */
        public abstract clone(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {double} maxY 
         */
        public setMaxY(maxY: double): void;
        /**
         * 
         * @param {double} maxX 
         */
        public setMaxX(maxX: double): void;
        /**
         * 
         */
        public abstract getMinZ(): double;
        /**
         * 
         */
        public abstract getMinX(): double;
        /**
         * 
         */
        public abstract getMinY(): double;
    }
}
declare namespace cn.nukkit.item{
     class ItemEnderPearl extends cn.nukkit.item.ProjectileItem{
        /**
         * 
         */
        public getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getThrowForce(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.entity.Entity} projectile 
         */
        protected correctProjectile(player: cn.nukkit.Player,projectile: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.network.query{
     class QueryHandler extends java.lang.Object{
        /**  */
        lastToken: byte[];
        /**  */
        server: cn.nukkit.Server;
        /**  */
        shortData: byte[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        STATISTICS: byte;
        /**  */
        longData: byte[];
        /**  */
        HANDSHAKE: byte;
        /**  */
        timeout: long;
        /**  */
        token: byte[];
        /**
         * 
         */
        public regenerateInfo(): void;
        /**
         * 
         * @param {java.net.InetSocketAddress} address 
         * @param {io.netty.buffer.ByteBuf} packet 
         */
        public handle(address: java.net.InetSocketAddress,packet: io.netty.buffer.ByteBuf): void;
        /**
         * 
         * @param {java.lang.String} token 
         * @param {java.net.InetAddress} address 
         */
        public static getTokenString(token: java.lang.String,address: java.net.InetAddress): byte[];
        /**
         * 
         * @param {byte[]} token 
         * @param {java.net.InetAddress} address 
         */
        public static getTokenString(token: byte[],address: java.net.InetAddress): byte[];
        /**
         * 
         */
        public regenerateToken(): void;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerToggleSwimEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        isSwimming: boolean;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isSwimming(): boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.level.biome.impl.mesa{
     class MesaPlateauBiome extends cn.nukkit.level.biome.impl.mesa.MesaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace com.blocklynukkit.loader.other.data{
     class LocalStorage extends java.lang.Object{
        /**  */
        pluginName: java.lang.String;
        /**  */
        savePath: java.lang.String;
        /**  */
        changes: java.util.Set;
        /**  */
        self: com.blocklynukkit.loader.other.data.LocalStorage;
        /**  */
        storage: java.util.Map;
        /**  */
        dir: java.io.File;
        /**
         * 
         */
        private lambda$new$0(): void;
        /**
         * 移除键值对
         * @param {java.lang.String} key 键
         */
        public removeItem(key: java.lang.String): void;
        /**
         * 缓存指定的键
         * @param {java.lang.String} key 键
         */
        public cache(key: java.lang.String): java.lang.String;
        /**
         * 将所有的键缓存起来
         */
        public cacheAll(): void;
        /**
         * 强制保存所有键值对到硬盘，bn本身会每3秒自动保存
         */
        public save(): void;
        /**
         * 获取键对应的值
         * @param {java.lang.String} key 键
         */
        public getItem(key: java.lang.String): java.lang.String;
        /**
         * 获取所有的键
         */
        public getKeys(): java.lang.String[];
        /**
         * 设置键值对
         * @param {java.lang.String} key 键
         * @param {java.lang.String} item 值
         */
        public setItem(key: java.lang.String,item: java.lang.String): void;
        /**
         * 初始化所有的键
         */
        private initKeys(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemNetherStar extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item{
     class ItemHelmetIron extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.nbt.stream{
     class NBTOutputStream extends java.lang.Object{
        /**  */
        stream: java.io.DataOutputStream;
        /**  */
        endianness: java.nio.ByteOrder;
        /**  */
        network: boolean;
        /**
         * 
         * @param {int} v 
         */
        public writeInt(v: int): void;
        /**
         * 
         * @param {int} v 
         */
        public writeByte(v: int): void;
        /**
         * 
         */
        public getEndianness(): java.nio.ByteOrder;
        /**
         * 
         * @param {float} v 
         */
        public writeFloat(v: float): void;
        /**
         * 
         * @param {int} v 
         */
        public writeChar(v: int): void;
        /**
         * 
         * @param {long} v 
         */
        public writeLong(v: long): void;
        /**
         * 
         * @param {java.lang.String} s 
         */
        public writeBytes(s: java.lang.String): void;
        /**
         * 
         */
        public isNetwork(): boolean;
        /**
         * 
         * @param {java.lang.String} s 
         */
        public writeUTF(s: java.lang.String): void;
        /**
         * 
         * @param {int} v 
         */
        public writeShort(v: int): void;
        /**
         * 
         * @param {java.lang.String} s 
         */
        public writeChars(s: java.lang.String): void;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public write(bytes: byte[]): void;
        /**
         * 
         * @param {int} b 
         */
        public write(b: int): void;
        /**
         * 
         * @param {byte[]} b 
         * @param {int} off 
         * @param {int} len 
         */
        public write(b: byte[],off: int,len: int): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {boolean} v 
         */
        public writeBoolean(v: boolean): void;
        /**
         * 
         * @param {double} v 
         */
        public writeDouble(v: double): void;
    }
}
declare namespace cn.nukkit.plugin{
     class PluginManager extends java.lang.Object{
        /**  */
        server: cn.nukkit.Server;
        /**  */
        defaultPerms: java.util.Map;
        /**  */
        defaultPermsOp: java.util.Map;
        /**  */
        fileAssociations: java.util.Map;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        defSubs: java.util.Set;
        /**  */
        plugins: java.util.Map;
        /**  */
        permissions: java.util.Map;
        /**  */
        defSubsOp: java.util.Set;
        /**  */
        permSubs: java.util.Map;
        /**  */
        commandMap: cn.nukkit.command.SimpleCommandMap;
        /**
         * 
         * @param {java.lang.String} permission 
         * @param {cn.nukkit.permission.Permissible} permissible 
         */
        public subscribeToPermission(permission: java.lang.String,permissible: cn.nukkit.permission.Permissible): void;
        /**
         * 
         * @param {boolean} op 
         */
        public getDefaultPermissions(op: boolean): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public addPermission(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public recalculatePermissionDefaults(permission: cn.nukkit.permission.Permission): void;
        /**
         * 
         * @param {java.io.File} dictionary 
         */
        public loadPlugins(dictionary: java.io.File): java.util.Map;
        /**
         * 
         * @param {java.lang.String} dictionary 
         * @param {java.util.List} newLoaders 
         */
        public loadPlugins(dictionary: java.lang.String,newLoaders: java.util.List): java.util.Map;
        /**
         * 
         * @param {java.io.File} dictionary 
         * @param {java.util.List} newLoaders 
         */
        public loadPlugins(dictionary: java.io.File,newLoaders: java.util.List): java.util.Map;
        /**
         * 
         * @param {java.io.File} dictionary 
         * @param {java.util.List} newLoaders 
         * @param {boolean} includeDir 
         */
        public loadPlugins(dictionary: java.io.File,newLoaders: java.util.List,includeDir: boolean): java.util.Map;
        /**
         * 
         * @param {java.lang.String} dictionary 
         */
        public loadPlugins(dictionary: java.lang.String): java.util.Map;
        /**
         * 
         * @param {java.util.Map} loadedPlugins 
         * @param {java.lang.String} dependency 
         */
        private lambda$loadPlugins$1(loadedPlugins: java.util.Map,dependency: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.Class} event 
         * @param {cn.nukkit.event.Listener} listener 
         * @param {cn.nukkit.event.EventPriority} priority 
         * @param {cn.nukkit.plugin.EventExecutor} executor 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {boolean} ignoreCancelled 
         */
        public registerEvent(event: java.lang.Class,listener: cn.nukkit.event.Listener,priority: cn.nukkit.event.EventPriority,executor: cn.nukkit.plugin.EventExecutor,plugin: cn.nukkit.plugin.Plugin,ignoreCancelled: boolean): void;
        /**
         * 
         * @param {java.lang.Class} event 
         * @param {cn.nukkit.event.Listener} listener 
         * @param {cn.nukkit.event.EventPriority} priority 
         * @param {cn.nukkit.plugin.EventExecutor} executor 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public registerEvent(event: java.lang.Class,listener: cn.nukkit.event.Listener,priority: cn.nukkit.event.EventPriority,executor: cn.nukkit.plugin.EventExecutor,plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {cn.nukkit.plugin.PluginLoader} loader 
         * @param {java.io.File} dir 
         * @param {java.lang.String} name 
         */
        private static lambda$loadPlugins$0(loader: cn.nukkit.plugin.PluginLoader,dir: java.io.File,name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.Class} type 
         */
        private getEventListeners(type: java.lang.Class): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {boolean} op 
         */
        public getDefaultPermSubscriptions(op: boolean): java.util.Set;
        /**
         * 
         */
        public getPlugins(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.event.Listener} listener 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public registerEvents(listener: cn.nukkit.event.Listener,plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {boolean} op 
         * @param {cn.nukkit.permission.Permissible} permissible 
         */
        public subscribeToDefaultPerms(op: boolean,permissible: cn.nukkit.permission.Permissible): void;
        /**
         * 
         */
        public disablePlugins(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getPermission(name: java.lang.String): cn.nukkit.permission.Permission;
        /**
         * 
         * @param {cn.nukkit.event.Event} event 
         */
        public callEvent(event: cn.nukkit.event.Event): void;
        /**
         * 
         * @param {boolean} op 
         * @param {cn.nukkit.permission.Permissible} permissible 
         */
        public unsubscribeFromDefaultPerms(op: boolean,permissible: cn.nukkit.permission.Permissible): void;
        /**
         * 
         */
        public getPermissions(): java.util.Map;
        /**
         * 
         */
        public clearPlugins(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public removePermission(name: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public removePermission(permission: cn.nukkit.permission.Permission): void;
        /**
         * 
         * @param {java.lang.String} path 
         * @param {java.util.Map} loaders 
         */
        public loadPlugin(path: java.lang.String,loaders: java.util.Map): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {java.io.File} file 
         * @param {java.util.Map} loaders 
         */
        public loadPlugin(file: java.io.File,loaders: java.util.Map): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {java.io.File} file 
         */
        public loadPlugin(file: java.io.File): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {java.lang.String} path 
         */
        public loadPlugin(path: java.lang.String): cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public loadPowerNukkitPlugins(): void;
        /**
         * 
         * @param {java.lang.Class} loaderClass 
         */
        public registerInterface(loaderClass: java.lang.Class): boolean;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public isPluginEnabled(plugin: cn.nukkit.plugin.Plugin): boolean;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public disablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getPlugin(name: java.lang.String): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {boolean} op 
         */
        private dirtyPermissibles(op: boolean): void;
        /**
         * 
         * @param {java.lang.String} permission 
         * @param {cn.nukkit.permission.Permissible} permissible 
         */
        public unsubscribeFromPermission(permission: java.lang.String,permissible: cn.nukkit.permission.Permissible): void;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        private calculatePermissionDefault(permission: cn.nukkit.permission.Permission): void;
        /**
         * 
         * @param {java.lang.String} permission 
         */
        public getPermissionSubscriptions(permission: java.lang.String): java.util.Set;
        /**
         * 
         * @param {java.lang.Class} clazz 
         */
        private getRegistrationClass(clazz: java.lang.Class): java.lang.Class;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        protected parseYamlCommands(plugin: cn.nukkit.plugin.Plugin): java.util.List;
    }
}
declare namespace cn.nukkit.permission{
    abstract class ServerOperator extends java.lang.Object{
        /**
         * 
         * @param {boolean} value 
         */
        public abstract setOp(value: boolean): void;
        /**
         * 
         */
        public abstract isOp(): boolean;
    }
}
declare namespace cn.nukkit.command.defaults{
     class SaveCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment.trident{
     class EnchantmentTridentRiptide extends cn.nukkit.item.enchantment.trident.EnchantmentTrident{
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityVex extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockWaterStill extends cn.nukkit.block.BlockWater{
        /**
         * 
         * @param {int} meta 
         */
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityAgeable extends java.lang.Object{
        /**
         * 
         */
        public abstract isBaby(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemSnowball extends cn.nukkit.item.ProjectileItem{
        /**
         * 
         */
        public getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getThrowForce(): float;
    }
}
declare namespace cn.nukkit{
    abstract class InterruptibleThread extends java.lang.Object{
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityMooshroom extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemChestplateDiamond extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace java.util{
     class Date extends java.lang.Object{
        /**  */
        serialVersionUID: long;
        /**  */
        cdate: sun.util.calendar.BaseCalendar.Date;
        /**  */
        ttb: int[];
        /**  */
        wtb: java.lang.String[];
        /**  */
        jcal: sun.util.calendar.BaseCalendar;
        /**  */
        fastTime: long;
        /**  */
        gcal: sun.util.calendar.BaseCalendar;
        /**  */
        defaultCenturyStart: int;
        /**
         * 
         */
        private  getTimeImpl(): long;
        /**
         * 
         * @param {java.util.Date} arg0 
         */
        public before(arg0: java.util.Date): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         * @param {int} arg2 
         * @param {int} arg3 
         * @param {int} arg4 
         * @param {int} arg5 
         */
        public static UTC(arg0: int,arg1: int,arg2: int,arg3: int,arg4: int,arg5: int): long;
        /**
         * 
         */
        public getTime(): long;
        /**
         * 
         */
        private static   getJulianCalendar(): sun.util.calendar.BaseCalendar;
        /**
         * 
         * @param {java.util.Date} arg0 
         */
        public compareTo(arg0: java.util.Date): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  compareTo(arg0: java.lang.Object): int;
        /**
         * 
         * @param {long} arg0 
         */
        private static  getCalendarSystem(arg0: long): sun.util.calendar.BaseCalendar;
        /**
         * 
         * @param {int} arg0 
         */
        private static  getCalendarSystem(arg0: int): sun.util.calendar.BaseCalendar;
        /**
         * 
         * @param {sun.util.calendar.BaseCalendar.Date} arg0 
         */
        private static  getCalendarSystem(arg0: sun.util.calendar.BaseCalendar.Date): sun.util.calendar.BaseCalendar;
        /**
         * 
         */
        public getHours(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public setHours(arg0: int): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public setSeconds(arg0: int): void;
        /**
         * 
         * @param {sun.util.calendar.BaseCalendar.Date} arg0 
         */
        private  normalize(arg0: sun.util.calendar.BaseCalendar.Date): sun.util.calendar.BaseCalendar.Date;
        /**
         * 
         */
        private  normalize(): sun.util.calendar.BaseCalendar.Date;
        /**
         * 
         * @param {java.time.Instant} arg0 
         */
        public static from(arg0: java.time.Instant): java.util.Date;
        /**
         * 
         */
        public getDate(): int;
        /**
         * 
         * @param {java.util.Date} arg0 
         */
        public after(arg0: java.util.Date): boolean;
        /**
         * 
         */
        public getMonth(): int;
        /**
         * 
         * @param {long} arg0 
         */
        public setTime(arg0: long): void;
        /**
         * 
         * @param {int} arg0 
         */
        public setMonth(arg0: int): void;
        /**
         * 
         * @param {java.lang.StringBuilder} arg0 
         * @param {java.lang.String} arg1 
         */
        private static  convertToAbbr(arg0: java.lang.StringBuilder,arg1: java.lang.String): java.lang.StringBuilder;
        /**
         * 
         */
        private  getCalendarDate(): sun.util.calendar.BaseCalendar.Date;
        /**
         * 
         * @param {java.util.Date} arg0 
         */
        static  getMillisOf(arg0: java.util.Date): long;
        /**
         * 
         * @param {java.io.ObjectOutputStream} arg0 
         */
        private writeObject(arg0: java.io.ObjectOutputStream): void;
        /**
         * 
         * @param {int} arg0 
         */
        public setMinutes(arg0: int): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static parse(arg0: java.lang.String): long;
        /**
         * 
         */
        public toInstant(): java.time.Instant;
        /**
         * 
         * @param {int} arg0 
         */
        public setYear(arg0: int): void;
        /**
         * 
         */
        public getDay(): int;
        /**
         * 
         * @param {java.io.ObjectInputStream} arg0 
         */
        private readObject(arg0: java.io.ObjectInputStream): void;
        /**
         * 
         */
        public getMinutes(): int;
        /**
         * 
         */
        public toGMTString(): java.lang.String;
        /**
         * 
         */
        public getSeconds(): int;
        /**
         * 
         */
        public getTimezoneOffset(): int;
        /**
         * 
         */
        public getYear(): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public clone(): java.lang.Object;
        /**
         * 
         * @param {int} arg0 
         */
        public setDate(arg0: int): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public toLocaleString(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockRail extends cn.nukkit.block.BlockFlowable{
        /**  */
        ACTIVE: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        ACTIVABLE_PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        UNCURVED_RAIL_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        canBePowered: boolean;
        /**  */
        CURVED_RAIL_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**
         * 
         * @param {java.util.Map} railsAround 
         * @param {cn.nukkit.block.BlockRail} r 
         */
        private static lambda$checkRailsConnected$6(railsAround: java.util.Map,r: cn.nukkit.block.BlockRail): boolean;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.block.BlockRail} r 
         */
        private static lambda$checkRailsConnected$7(r: cn.nukkit.block.BlockRail): cn.nukkit.block.BlockRail;
        /**
         * 
         */
        public recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isActive(): boolean;
        /**
         * 
         * @param {java.util.Map} result 
         * @param {cn.nukkit.math.BlockFace} f 
         * @param {cn.nukkit.block.Block} block 
         */
        private static lambda$null$4(result: java.util.Map,f: cn.nukkit.math.BlockFace,block: cn.nukkit.block.Block): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} f1 
         * @param {cn.nukkit.math.BlockFace} f2 
         */
        private lambda$place$1(f1: cn.nukkit.math.BlockFace,f2: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {java.util.List} faces 
         * @param {cn.nukkit.utils.Rail.Orientation} o 
         */
        private static lambda$place$0(faces: java.util.List,o: cn.nukkit.utils.Rail.Orientation): boolean;
        /**
         * 
         * @param {java.util.Map} result 
         * @param {cn.nukkit.math.BlockFace} f 
         */
        private lambda$checkRailsAround$5(result: java.util.Map,f: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getOrientation(): cn.nukkit.utils.Rail.Orientation;
        /**
         * 
         * @param {java.util.Collection} faces 
         */
        private checkRailsAround(faces: java.util.Collection): java.util.Map;
        /**
         * 
         */
        private checkRailsAroundAffected(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.block.Block} check 
         */
        private checkCanBePlace(check: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public canPowered(): boolean;
        /**
         * 
         */
        public isRailActive(): cn.nukkit.utils.OptionalBoolean;
        /**
         * 
         * @param {cn.nukkit.block.BlockRail} rail1 
         * @param {cn.nukkit.math.BlockFace} face1 
         * @param {cn.nukkit.block.BlockRail} rail2 
         * @param {cn.nukkit.math.BlockFace} face2 
         */
        private connect(rail1: cn.nukkit.block.BlockRail,face1: cn.nukkit.math.BlockFace,rail2: cn.nukkit.block.BlockRail,face2: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail.Orientation;
        /**
         * 
         * @param {cn.nukkit.block.BlockRail} other 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        private connect(other: cn.nukkit.block.BlockRail,face: cn.nukkit.math.BlockFace): cn.nukkit.utils.Rail.Orientation;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.utils.Rail.Orientation} o 
         */
        public setOrientation(o: cn.nukkit.utils.Rail.Orientation): void;
        /**
         * 
         * @param {boolean} active 
         */
        public setRailActive(active: boolean): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getRealMeta(): int;
        /**
         * 
         */
        protected checkRailsConnected(): java.util.Map;
        /**
         * 
         */
        public isAbstract(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.BlockRail} r 
         */
        private static lambda$checkRailsAroundAffected$2(r: cn.nukkit.block.BlockRail): boolean;
        /**
         * 
         * @param {cn.nukkit.block.BlockRail} r 
         */
        private static lambda$checkRailsAroundAffected$3(r: cn.nukkit.block.BlockRail): cn.nukkit.block.BlockRail;
        /**
         * 
         * @param {cn.nukkit.utils.Rail.Orientation} orientation 
         */
        public setRailDirection(orientation: cn.nukkit.utils.Rail.Orientation): void;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {boolean} active 
         */
        public setActive(active: boolean): void;
        /**
         * 
         */
        public  getRailDirection(): cn.nukkit.utils.Rail.Orientation;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace java.util{
     class Random extends java.lang.Object{
        /**  */
        seed: java.util.concurrent.atomic.AtomicLong;
        /**  */
        multiplier: long;
        /**  */
        BadRange: java.lang.String;
        /**  */
        addend: long;
        /**  */
        unsafe: sun.misc.Unsafe;
        /**  */
        BadSize: java.lang.String;
        /**  */
        serialPersistentFields: java.io.ObjectStreamField[];
        /**  */
        serialVersionUID: long;
        /**  */
        seedUniquifier: java.util.concurrent.atomic.AtomicLong;
        /**  */
        DOUBLE_UNIT: double;
        /**  */
        seedOffset: long;
        /**  */
        BadBound: java.lang.String;
        /**  */
        haveNextNextGaussian: boolean;
        /**  */
        nextNextGaussian: double;
        /**  */
        mask: long;
        /**
         * 
         * @param {int} arg0 
         */
        protected next(arg0: int): int;
        /**
         * 
         */
        public nextFloat(): float;
        /**
         * 
         * @param {long} arg0 
         */
        private resetSeed(arg0: long): void;
        /**
         * 
         * @param {java.io.ObjectOutputStream} arg0 
         */
        private  writeObject(arg0: java.io.ObjectOutputStream): void;
        /**
         * 
         */
        public nextInt(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public nextInt(arg0: int): int;
        /**
         * 
         */
        public nextLong(): long;
        /**
         * 
         */
        public nextDouble(): double;
        /**
         * 
         */
        public  nextGaussian(): double;
        /**
         * 
         * @param {java.io.ObjectInputStream} arg0 
         */
        private readObject(arg0: java.io.ObjectInputStream): void;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public nextBytes(arg0: byte[]): void;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
         internalNextLong(arg0: long,arg1: long): long;
        /**
         * 
         * @param {long} arg0 
         */
        public longs(arg0: long): java.util.stream.LongStream;
        /**
         * 
         */
        public longs(): java.util.stream.LongStream;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         * @param {long} arg2 
         */
        public longs(arg0: long,arg1: long,arg2: long): java.util.stream.LongStream;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public longs(arg0: long,arg1: long): java.util.stream.LongStream;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public doubles(arg0: double,arg1: double): java.util.stream.DoubleStream;
        /**
         * 
         * @param {long} arg0 
         * @param {double} arg1 
         * @param {double} arg2 
         */
        public doubles(arg0: long,arg1: double,arg2: double): java.util.stream.DoubleStream;
        /**
         * 
         * @param {long} arg0 
         */
        public doubles(arg0: long): java.util.stream.DoubleStream;
        /**
         * 
         */
        public doubles(): java.util.stream.DoubleStream;
        /**
         * 
         * @param {long} arg0 
         */
        private static initialScramble(arg0: long): long;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
         internalNextDouble(arg0: double,arg1: double): double;
        /**
         * 
         */
        private static seedUniquifier(): long;
        /**
         * 
         */
        public ints(): java.util.stream.IntStream;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public ints(arg0: int,arg1: int): java.util.stream.IntStream;
        /**
         * 
         * @param {long} arg0 
         */
        public ints(arg0: long): java.util.stream.IntStream;
        /**
         * 
         * @param {long} arg0 
         * @param {int} arg1 
         * @param {int} arg2 
         */
        public ints(arg0: long,arg1: int,arg2: int): java.util.stream.IntStream;
        /**
         * 
         */
        public nextBoolean(): boolean;
        /**
         * 
         * @param {long} arg0 
         */
        public  setSeed(arg0: long): void;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
         internalNextInt(arg0: int,arg1: int): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class LavaParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace java.lang{
    abstract class Runnable extends java.lang.Object{
        /**
         * 
         */
        public abstract run(): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.roofedforest{
     class RoofedForestBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.server{
     class RemoteServerCommandEvent extends cn.nukkit.event.server.ServerCommandEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.command.defaults{
     class WeatherCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockVine extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        VINE_DIRECTION_BITS: cn.nukkit.blockproperty.IntBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} meta 
         * @param {cn.nukkit.block.Block} source 
         */
        private putVineOnHorizontalFace(block: cn.nukkit.block.Block,meta: int,source: cn.nukkit.block.Block): void;
        /**
         * 
         */
        public canBeClimbed(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        private canSpread(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        private getFaces(): java.util.Set;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        private static getMetaFromFace(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} meta 
         * @param {cn.nukkit.block.Block} source 
         */
        private putVine(block: cn.nukkit.block.Block,meta: int,source: cn.nukkit.block.Block): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         * @param {java.util.Set} faces 
         */
        private static getMetaFromFaces(faces: java.util.Set): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceGateBirch extends cn.nukkit.block.BlockFenceGate{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class HugeExplodeParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.level.particle{
     class AngryVillagerParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
     class BlockPiston extends cn.nukkit.block.BlockPistonBase{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getPistonHeadBlockId(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.utils{
     class Watchdog extends java.lang.Thread{
        /**  */
        running: boolean;
        /**  */
        server: cn.nukkit.Server;
        /**  */
        responding: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        warnedAboutFinalizer: boolean;
        /**  */
        time: long;
        /**  */
        forcedFinalizer: java.lang.Thread;
        /**
         * 
         */
        private static lambda$checkFinalizer$0(): void;
        /**
         * 
         * @param {java.lang.management.ThreadInfo} thread 
         * @param {java.lang.StringBuilder} builder 
         */
        private static dumpThread(thread: java.lang.management.ThreadInfo,builder: java.lang.StringBuilder): void;
        /**
         * 
         */
        public run(): void;
        /**
         * 
         */
        public kill(): void;
        /**
         * 
         */
        private checkFinalizer(): void;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityBed extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        color: int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
    }
}
declare namespace cn.nukkit.level.particle{
     class DestroyBlockParticle extends cn.nukkit.level.particle.Particle{
        /**  */
        data: int;
        /**
         * 
         */
        public encode(): cn.nukkit.network.protocol.DataPacket[];
    }
}
declare namespace cn.nukkit.command.defaults{
     class TellCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.scheduler{
     class FileWriteTask extends cn.nukkit.scheduler.AsyncTask{
        /**  */
        file: java.io.File;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        contents: java.io.InputStream;
        /**
         * 
         */
        public onRun(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSalmonCooked extends cn.nukkit.item.ItemFish{
    }
}
declare namespace com.blocklynukkit.loader.other.Entities{
     class NoFallBlock extends cn.nukkit.entity.item.EntityFallingBlock{
        /**  */
        canplace: boolean;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        public getGravity(): float;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockDoor extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        DOOR_HINGE_BIT: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        DOOR_TOP_BIT: int;
        /**  */
        manualOverrides: java.util.List;
        /**  */
        DOOR_POWERED_BIT: int;
        /**  */
        DOOR_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        DOOR_OPEN_BIT: int;
        /**  */
        DOOR_HINGE: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        THICKNESS: double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} open 
         */
        public setOpen(player: cn.nukkit.Player,open: boolean): boolean;
        /**
         * 
         * @param {boolean} open 
         */
        public setOpen(open: boolean): void;
        /**
         * 
         */
        public getManualOverride(): boolean;
        /**
         * 
         */
        public playOpenSound(): void;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        private onRedstoneUpdate(): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         * @param {boolean} top 
         */
        public setTop(top: boolean): void;
        /**
         * 
         */
        public isRightHinged(): boolean;
        /**
         * 
         * @param {boolean} val 
         */
        public setManualOverride(val: boolean): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getFullDamage(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public toggle(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public playOpenCloseSound(): void;
        /**
         * 
         */
        public isGettingPower(): boolean;
        /**
         * 
         */
        public isOpen(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {boolean} rightHinged 
         */
        public setRightHinged(rightHinged: boolean): void;
        /**
         * 
         */
        public isTop(): boolean;
        /**
         * 
         * @param {int} meta 
         */
        public isTop(meta: int): boolean;
        /**
         * 
         */
        public playCloseSound(): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} pos 
         */
        private recalculateBoundingBoxWithPos(pos: cn.nukkit.math.BlockFace): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        private onNormalUpdate(): void;
    }
}
declare namespace com.blocklynukkit.loader.script.window.windowCallbacks{
     class CustomCallback extends com.blocklynukkit.loader.script.window.windowCallbacks.WindowCallback{
        /**  */
        defaultCallback: java.lang.String;
        /**  */
        actionCallbacks: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 
         */
        public call(event: cn.nukkit.event.player.PlayerFormRespondedEvent): void;
        /**
         * 
         */
        public hasDefaultCallback(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {java.lang.String} actionCallback 
         */
        public addActionCallback(index: int,actionCallback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} actionCallback 
         */
        public addActionCallback(actionCallback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} defaultCallback 
         */
        public setDefaultCallback(defaultCallback: java.lang.String): void;
    }
}
declare namespace cn.nukkit.plugin{
     class RegisteredListener extends java.lang.Object{
        /**  */
        plugin: cn.nukkit.plugin.Plugin;
        /**  */
        EMPTY_ARRAY: cn.nukkit.plugin.RegisteredListener[];
        /**  */
        executor: cn.nukkit.plugin.EventExecutor;
        /**  */
        ignoreCancelled: boolean;
        /**  */
        timing: co.aikar.timings.Timing;
        /**  */
        listener: cn.nukkit.event.Listener;
        /**  */
        priority: cn.nukkit.event.EventPriority;
        /**
         * 
         * @param {cn.nukkit.event.Event} event 
         */
        public callEvent(event: cn.nukkit.event.Event): void;
        /**
         * 
         */
        public isIgnoringCancelled(): boolean;
        /**
         * 
         */
        public getPlugin(): cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public getPriority(): cn.nukkit.event.EventPriority;
        /**
         * 
         */
        public getListener(): cn.nukkit.event.Listener;
    }
}
declare namespace cn.nukkit.command.defaults{
     class OpCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityPotion extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        NETWORK_ID: int;
        /**  */
        DATA_POTION_ID: int;
        /**  */
        potionId: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} collidedWith 
         */
        protected splash(collidedWith: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        protected getGravity(): float;
    }
}
declare namespace cn.nukkit.block{
     class BlockNoteblock extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getStrength(): int;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getInstrument(): cn.nukkit.block.BlockNoteblock.Instrument;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public increaseStrength(): void;
        /**
         * 
         */
        public emitSound(): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.event.player.PlayerInteractEvent.Action} action 
         */
        public onTouch(player: cn.nukkit.Player,action: cn.nukkit.event.player.PlayerInteractEvent.Action): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemIngotIron extends cn.nukkit.item.Item{
    }
}
declare namespace java.util{
     class UUID extends java.lang.Object{
        /**  */
        serialVersionUID: long;
        /**  */
        $assertionsDisabled: boolean;
        /**  */
        leastSigBits: long;
        /**  */
        mostSigBits: long;
        /**
         * 
         * @param {java.util.UUID} arg0 
         */
        public compareTo(arg0: java.util.UUID): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  compareTo(arg0: java.lang.Object): int;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public static nameUUIDFromBytes(arg0: byte[]): java.util.UUID;
        /**
         * 
         */
        public getLeastSignificantBits(): long;
        /**
         * 
         */
        public version(): int;
        /**
         * 
         */
        public node(): long;
        /**
         * 
         */
        public getMostSignificantBits(): long;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public variant(): int;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {long} arg0 
         * @param {int} arg1 
         */
        private static digits(arg0: long,arg1: int): java.lang.String;
        /**
         * 
         */
        public static randomUUID(): java.util.UUID;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static fromString(arg0: java.lang.String): java.util.UUID;
        /**
         * 
         */
        public clockSequence(): int;
        /**
         * 
         */
        public timestamp(): long;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityEnderman extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.projectile{
    abstract class EntityProjectile extends cn.nukkit.entity.Entity{
        /**  */
        closeOnCollide: boolean;
        /**  */
        DATA_SHOOTER_ID: int;
        /**  */
        hasAge: boolean;
        /**  */
        damage: double;
        /**  */
        shootingEntity: cn.nukkit.entity.Entity;
        /**  */
        hadCollision: boolean;
        /**
         * 
         */
        protected getDamage(): double;
        /**
         * 
         */
        public hasAge(): boolean;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} position 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {cn.nukkit.block.Block} collisionBlock 
         */
        protected onCollideWithBlock(position: cn.nukkit.level.Position,motion: cn.nukkit.math.Vector3,collisionBlock: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Position} position 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        protected onCollideWithBlock(position: cn.nukkit.level.Position,motion: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        protected getBaseDamage(): double;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        protected updateMotion(): void;
        /**
         * 
         */
        protected addHitEffect(): void;
        /**
         * 
         * @param {float} modifier 
         */
        public inaccurate(modifier: float): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public getResultDamage(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getResultDamage(entity: cn.nukkit.entity.Entity): int;
        /**
         * 
         */
        public updateRotation(): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        protected afterCollisionWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {boolean} hasAge 
         */
        public setAge(hasAge: boolean): void;
    }
}
declare namespace cn.nukkit.lang{
     class TranslationContainer extends cn.nukkit.lang.TextContainer{
        /**  */
        params: java.lang.String[];
        /**
         * 
         * @param {java.lang.String[]} params 
         */
        public setParameters(params: java.lang.String[]): void;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.lang.TranslationContainer;
        /**
         * 
         */
        public  clone(): cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public getParameters(): java.lang.String[];
        /**
         * 
         * @param {int} i 
         * @param {java.lang.String} str 
         */
        public setParameter(i: int,str: java.lang.String): void;
        /**
         * 
         * @param {int} i 
         */
        public getParameter(i: int): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockChest extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public getMinY(): double;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayStatusPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        PLAYER_SPAWN: int;
        /**  */
        LOGIN_FAILED_SERVER_FULL: int;
        /**  */
        LOGIN_FAILED_EDU_VANILLA: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        LOGIN_FAILED_INVALID_TENANT: int;
        /**  */
        LOGIN_FAILED_CLIENT: int;
        /**  */
        LOGIN_SUCCESS: int;
        /**  */
        LOGIN_FAILED_SERVER: int;
        /**  */
        LOGIN_FAILED_VANILLA_EDU: int;
        /**  */
        status: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockTorch extends cn.nukkit.block.BlockFlowable{
        /**  */
        TORCH_FACING_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.block.BlockTorch.TorchAttachment} face 
         */
        public setTorchAttachment(face: cn.nukkit.block.BlockTorch.TorchAttachment): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} meta 
         */
        public getBlockFace(meta: int): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        private findValidSupport(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getTorchAttachment(): cn.nukkit.block.BlockTorch.TorchAttachment;
    }
}
declare namespace cn.nukkit.command.defaults{
     class GamemodeCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockMossStone extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockFurnaceBurning extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.plugin.service{
     class RegisteredServiceProvider extends java.lang.Object{
        /**  */
        plugin: cn.nukkit.plugin.Plugin;
        /**  */
        provider: java.lang.Object;
        /**  */
        service: java.lang.Class;
        /**  */
        priority: cn.nukkit.plugin.service.ServicePriority;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} o 
         */
        public equals(o: java.lang.Object): boolean;
        /**
         * 
         */
        public getPlugin(): cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public getPriority(): cn.nukkit.plugin.service.ServicePriority;
        /**
         * 
         */
        public getProvider(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.plugin.service.RegisteredServiceProvider} other 
         */
        public compareTo(other: cn.nukkit.plugin.service.RegisteredServiceProvider): int;
        /**
         * 
         * @param {java.lang.Object} other 
         */
        public  compareTo(other: java.lang.Object): int;
        /**
         * 
         */
        public getService(): java.lang.Class;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityZombieHorse extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerMapInfoRequestEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getMap(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class ByteTag extends cn.nukkit.nbt.tag.NumberTag{
        /**  */
        data: int;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         * @param {java.lang.Integer} data 
         */
        public setData(data: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public  setData(data: java.lang.Number): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         */
        public parseValue(): java.lang.Integer;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public  getData(): java.lang.Number;
        /**
         * 
         */
        public getData(): java.lang.Integer;
    }
}
declare namespace cn.nukkit.block{
     class BlockMelon extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
    }
}
declare namespace cn.nukkit.event.inventory{
     class EnchantItemEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        newItem: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        oldItem: cn.nukkit.item.Item;
        /**  */
        xpCost: int;
        /**  */
        enchanter: cn.nukkit.Player;
        /**
         * 
         * @param {cn.nukkit.item.Item} newItem 
         */
        public setNewItem(newItem: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getOldItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.Player} enchanter 
         */
        public setEnchanter(enchanter: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} oldItem 
         */
        public setOldItem(oldItem: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getEnchanter(): cn.nukkit.Player;
        /**
         * 
         * @param {int} xpCost 
         */
        public setXpCost(xpCost: int): void;
        /**
         * 
         */
        public getXpCost(): int;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityInventoryChangeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        newItem: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        oldItem: cn.nukkit.item.Item;
        /**  */
        slot: int;
        /**
         * 
         */
        public getSlot(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} newItem 
         */
        public setNewItem(newItem: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getOldItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityCombustByBlockEvent extends cn.nukkit.event.entity.EntityCombustEvent{
        /**  */
        combuster: cn.nukkit.block.Block;
        /**
         * 
         */
        public getCombuster(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit{
     class Nukkit extends java.lang.Object{
        /**  */
        PATH: java.lang.String;
        /**  */
        GIT_COMMIT: java.lang.String;
        /**  */
        START_TIME: long;
        /**  */
        PLUGIN_PATH: java.lang.String;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        MINECRAFT_VERSION: java.lang.String;
        /**  */
        DATA_PATH: java.lang.String;
        /**  */
        API_VERSION: java.lang.String;
        /**  */
        shortTitle: boolean;
        /**  */
        CODENAME: java.lang.String;
        /**  */
        DEBUG: int;
        /**  */
        GIT_INFO: java.util.Properties;
        /**  */
        VERSION: java.lang.String;
        /**  */
        TITLE: boolean;
        /**  */
        MINECRAFT_VERSION_NETWORK: java.lang.String;
        /**  */
        ANSI: boolean;
        /**
         * 
         */
        private static getVersion(): java.lang.String;
        /**
         * 
         * @param {org.apache.logging.log4j.Level} level 
         */
        public static setLogLevel(level: org.apache.logging.log4j.Level): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} l 
         */
        private static lambda$null$2(l: cn.nukkit.level.Level): int;
        /**
         * 
         * @param {java.util.Map.Entry} entry 
         */
        private static lambda$null$3(entry: java.util.Map.Entry): java.util.AbstractMap.SimpleEntry;
        /**
         * 
         * @param {java.lang.String[]} args 
         */
        public static main(args: java.lang.String[]): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} l 
         */
        private static lambda$null$0(l: cn.nukkit.level.Level): int;
        /**
         * 
         */
        private static getGitInfo(): java.util.Properties;
        /**
         * 
         * @param {cn.nukkit.level.Level} l 
         */
        private static lambda$null$1(l: cn.nukkit.level.Level): int;
        /**
         * 
         * @param {java.util.concurrent.atomic.AtomicBoolean} disableSentry 
         * @param {io.sentry.SentryOptions} options 
         */
        private static lambda$main$5(disableSentry: java.util.concurrent.atomic.AtomicBoolean,options: io.sentry.SentryOptions): void;
        /**
         * 
         * @param {java.util.concurrent.atomic.AtomicBoolean} disableSentry 
         * @param {io.sentry.SentryEvent} event 
         * @param {java.lang.Object} hint 
         */
        private static lambda$null$4(disableSentry: java.util.concurrent.atomic.AtomicBoolean,event: io.sentry.SentryEvent,hint: java.lang.Object): io.sentry.SentryEvent;
        /**
         * 
         */
        public static getLogLevel(): org.apache.logging.log4j.Level;
        /**
         * 
         */
        private static getGitCommit(): java.lang.String;
        /**
         * 
         */
        private static requiresShortTitle(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreRedstone extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockLeaves2 extends cn.nukkit.block.BlockLeaves{
        /**  */
        NEW_LEAF_PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        ACACIA: int;
        /**  */
        NEW_LEAF_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        DARK_OAK: int;
        /**
         * 
         */
        public getType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        public setType(type: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        protected canDropApple(): boolean;
        /**
         * 
         */
        protected getSapling(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ContainerSetDataPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        PROPERTY_BREWING_STAND_BREW_TIME: int;
        /**  */
        PROPERTY_FURNACE_LIT_DURATION: int;
        /**  */
        PROPERTY_BREWING_STAND_FUEL_TOTAL: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        property: int;
        /**  */
        PROPERTY_FURNACE_LIT_TIME: int;
        /**  */
        PROPERTY_FURNACE_TICK_COUNT: int;
        /**  */
        PROPERTY_BREWING_STAND_FUEL_AMOUNT: int;
        /**  */
        PROPERTY_FURNACE_FUEL_AUX: int;
        /**  */
        value: int;
        /**  */
        windowId: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneLamp extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.utils{
     class Binary extends java.lang.Object{
        /**
         * 
         * @param {int} value 
         */
        public static unsignByte(value: int): int;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readSignedShort(bytes: byte[]): short;
        /**
         * 
         * @param {int} value 
         */
        public unsignShort(value: int): int;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLTriad(bytes: byte[]): int;
        /**
         * 
         * @param {byte} b 
         */
        public static readSignedByte(b: byte): int;
        /**
         * 
         * @param {byte[]} payload 
         */
        public static readMetadata(payload: byte[]): cn.nukkit.entity.data.EntityMetadata;
        /**
         * 
         * @param {int} value 
         */
        public static signInt(value: int): int;
        /**
         * 
         * @param {int} i 
         */
        public static writeLInt(i: int): byte[];
        /**
         * 
         * @param {int} s 
         */
        public static writeLShort(s: int): byte[];
        /**
         * 
         * @param {float} f 
         */
        public static writeFloat(f: float): byte[];
        /**
         * 
         * @param {byte[]} bytes1 
         * @param {byte[][]} bytes2 
         */
        public static  appendBytes(bytes1: byte[],...bytes2: byte[][]): byte[];
        /**
         * 
         * @param {byte} byte1 
         * @param {byte[][]} bytes2 
         */
        public static  appendBytes(byte1: byte,...bytes2: byte[][]): byte[];
        /**
         * 
         * @param {byte[][]} bytes 
         */
        public static appendBytes(bytes: byte[][]): byte[];
        /**
         * 
         * @param {long} v 
         */
        public static writeUnsignedVarInt(v: long): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLDouble(bytes: byte[]): double;
        /**
         * 
         * @param {boolean} b 
         */
        public static writeBool(b: boolean): byte;
        /**
         * 
         * @param {int} value 
         */
        public static signShort(value: int): int;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLShort(bytes: byte[]): int;
        /**
         * 
         * @param {byte[]} src 
         */
        public static bytesToHexString(src: byte[]): java.lang.String;
        /**
         * 
         * @param {byte[]} src 
         * @param {boolean} blank 
         */
        public static bytesToHexString(src: byte[],blank: boolean): java.lang.String;
        /**
         * 
         * @param {java.lang.String} hexString 
         */
        public static hexStringToBytes(hexString: java.lang.String): byte[];
        /**
         * 
         * @param {long} l 
         */
        public static writeLong(l: long): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readDouble(bytes: byte[]): double;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLLong(bytes: byte[]): long;
        /**
         * 
         * @param {int} value 
         */
        public static writeTriad(value: int): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         * @param {int} accuracy 
         */
        public static readFloat(bytes: byte[],accuracy: int): float;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readFloat(bytes: byte[]): float;
        /**
         * 
         * @param {byte[]} bytes 
         * @param {int} chunkSize 
         */
        public static splitBytes(bytes: byte[],chunkSize: int): byte[][];
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readUUID(bytes: byte[]): java.util.UUID;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readInt(bytes: byte[]): int;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readTriad(bytes: byte[]): int;
        /**
         * 
         * @param {long} l 
         */
        public static writeLLong(l: long): byte[];
        /**
         * 
         * @param {double} d 
         */
        public static writeDouble(d: double): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLInt(bytes: byte[]): int;
        /**
         * 
         * @param {int} i 
         */
        public static writeInt(i: int): byte[];
        /**
         * 
         * @param {byte} b 
         */
        public static writeByte(b: byte): byte;
        /**
         * 
         * @param {byte} b 
         */
        public static readBool(b: byte): boolean;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static reserveBytes(bytes: byte[]): byte[];
        /**
         * 
         * @param {int} value 
         */
        public static signByte(value: int): int;
        /**
         * 
         * @param {double} d 
         */
        public static writeLDouble(d: double): byte[];
        /**
         * 
         * @param {cn.nukkit.entity.data.EntityMetadata} metadata 
         */
        public static writeMetadata(metadata: cn.nukkit.entity.data.EntityMetadata): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readSignedLShort(bytes: byte[]): short;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLong(bytes: byte[]): long;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readLFloat(bytes: byte[]): float;
        /**
         * 
         * @param {byte[]} bytes 
         * @param {int} accuracy 
         */
        public static readLFloat(bytes: byte[],accuracy: int): float;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public static readShort(bytes: byte[]): int;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public static writeUUID(uuid: java.util.UUID): byte[];
        /**
         * 
         * @param {int} v 
         */
        public static writeVarInt(v: int): byte[];
        /**
         * 
         * @param {int} value 
         */
        public static writeLTriad(value: int): byte[];
        /**
         * 
         * @param {int} value 
         */
        public static unsignInt(value: int): int;
        /**
         * 
         * @param {int} s 
         */
        public static writeShort(s: int): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         * @param {int} start 
         */
        public static subBytes(bytes: byte[],start: int): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         * @param {int} start 
         * @param {int} length 
         */
        public static subBytes(bytes: byte[],start: int,length: int): byte[];
        /**
         * 
         * @param {float} f 
         */
        public static writeLFloat(f: float): byte[];
    }
}
declare namespace cn.nukkit.block{
     class BlockPressurePlateWood extends cn.nukkit.block.BlockPressurePlateBase{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        protected computeRedstoneStrength(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.inventory{
     class ShapedRecipe extends java.lang.Object{
        /**  */
        most: long;
        /**  */
        shape: java.lang.String[];
        /**  */
        primaryResult: cn.nukkit.item.Item;
        /**  */
        extraResults: java.util.List;
        /**  */
        least: long;
        /**  */
        ingredients: io.netty.util.collection.CharObjectHashMap;
        /**  */
        priority: int;
        /**  */
        ingredientsAggregate: java.util.List;
        /**  */
        recipeId: java.lang.String;
        /**
         * 
         * @param {java.util.StringJoiner} joiner 
         * @param {java.lang.Character} character 
         * @param {cn.nukkit.item.Item} item 
         */
        private static lambda$toString$0(joiner: java.util.StringJoiner,character: java.lang.Character,item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {cn.nukkit.item.Item} item 
         */
        public setIngredient(key: java.lang.String,item: cn.nukkit.item.Item): cn.nukkit.inventory.ShapedRecipe;
        /**
         * 
         * @param {char} key 
         * @param {cn.nukkit.item.Item} item 
         */
        public setIngredient(key: char,item: cn.nukkit.item.Item): cn.nukkit.inventory.ShapedRecipe;
        /**
         * 
         */
        public requiresCraftingTable(): boolean;
        /**
         * 
         */
        public getIngredientsAggregate(): java.util.List;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingManager} manager 
         */
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void;
        /**
         * 
         */
        public getShape(): java.lang.String[];
        /**
         * 
         */
        public getId(): java.util.UUID;
        /**
         * 
         */
        public getIngredientList(): java.util.List;
        /**
         * 
         */
        public getWidth(): int;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {java.util.List} extraOutputList 
         */
        public matchItems(inputList: java.util.List,extraOutputList: java.util.List): boolean;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {java.util.List} extraOutputList 
         * @param {int} multiplier 
         */
        public matchItems(inputList: java.util.List,extraOutputList: java.util.List,multiplier: int): boolean;
        /**
         * 
         */
        public getExtraResults(): java.util.List;
        /**
         * 
         */
        public getHeight(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         */
        public getIngredient(x: int,y: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.RecipeType;
        /**
         * 
         */
        public getResult(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getPriority(): int;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public setId(uuid: java.util.UUID): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getAllResults(): java.util.List;
        /**
         * 
         */
        public getRecipeId(): java.lang.String;
        /**
         * 
         */
        public getIngredientMap(): java.util.Map;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryCloseEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        who: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntitySign extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        text: java.lang.String[];
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {java.lang.String[]} lines 
         */
        private static sanitizeText(lines: java.lang.String[]): void;
        /**
         * 
         */
        public getText(): java.lang.String[];
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {cn.nukkit.Player} player 
         */
        public updateCompoundTag(nbt: cn.nukkit.nbt.tag.CompoundTag,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {java.lang.String[]} lines 
         */
        public  setText(...lines: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.level{
    abstract class ChunkManager extends java.lang.Object{
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockStateAt(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public abstract setBlockStateAt(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         */
        public abstract getSeed(): long;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockDataAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockDataAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        public abstract setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public abstract setChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public abstract setBlockIdAt(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public abstract setBlockIdAt(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public abstract getChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {cn.nukkit.math.ChunkVector2} pos 
         */
        public getChunk(pos: cn.nukkit.math.ChunkVector2): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockAt(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public abstract setBlockAt(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         * @param {int} data 
         */
        public abstract setBlockAtLayer(x: int,y: int,z: int,layer: int,id: int,data: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,id: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public abstract setBlockDataAt(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public abstract setBlockDataAt(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockIdAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockIdAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockStateAt(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockStateAt(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public abstract setBlockFullIdAt(x: int,y: int,z: int,fullId: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public abstract setBlockFullIdAt(x: int,y: int,z: int,layer: int,fullId: int): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class BubbleParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.command.data{
     class CommandParamType extends java.lang.Enum{
        /**  */
        TARGET: cn.nukkit.command.data.CommandParamType;
        /**  */
        FLOAT: cn.nukkit.command.data.CommandParamType;
        /**  */
        WILDCARD_INT: cn.nukkit.command.data.CommandParamType;
        /**  */
        JSON: cn.nukkit.command.data.CommandParamType;
        /**  */
        TEXT: cn.nukkit.command.data.CommandParamType;
        /**  */
        VALUE: cn.nukkit.command.data.CommandParamType;
        /**  */
        FILE_PATH: cn.nukkit.command.data.CommandParamType;
        /**  */
        INT: cn.nukkit.command.data.CommandParamType;
        /**  */
        RAWTEXT: cn.nukkit.command.data.CommandParamType;
        /**  */
        POSITION: cn.nukkit.command.data.CommandParamType;
        /**  */
        MESSAGE: cn.nukkit.command.data.CommandParamType;
        /**  */
        WILDCARD_TARGET: cn.nukkit.command.data.CommandParamType;
        /**  */
        OPERATOR: cn.nukkit.command.data.CommandParamType;
        /**  */
        STRING: cn.nukkit.command.data.CommandParamType;
        /**  */
        BLOCK_POSITION: cn.nukkit.command.data.CommandParamType;
        /**  */
        COMMAND: cn.nukkit.command.data.CommandParamType;
        /**  */
        id: int;
        /**  */
        $VALUES: cn.nukkit.command.data.CommandParamType[];
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.command.data.CommandParamType;
        /**
         * 
         */
        public static values(): cn.nukkit.command.data.CommandParamType[];
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityArthropod extends java.lang.Object{
    }
}
declare namespace cn.nukkit.network.protocol{
     class UpdateBlockPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        blockRuntimeId: int;
        /**  */
        FLAG_PRIORITY: int;
        /**  */
        dataLayer: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        FLAG_ALL: int;
        /**  */
        FLAG_NONE: int;
        /**  */
        flags: int;
        /**  */
        FLAG_NEIGHBORS: int;
        /**  */
        FLAG_NETWORK: int;
        /**  */
        FLAG_ALL_PRIORITY: int;
        /**  */
        FLAG_NOGRAPHIC: int;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.generator.object.tree{
     class NewJungleTree extends cn.nukkit.level.generator.object.tree.TreeGenerator{
        /**  */
        minTreeHeight: int;
        /**  */
        maxTreeHeight: int;
        /**  */
        metaWood: cn.nukkit.block.Block;
        /**  */
        metaLeaves: cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.BlockVector3} pos 
         * @param {int} meta 
         */
        private addVine(worldIn: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.BlockVector3,meta: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.BlockVector3} pos 
         * @param {int} meta 
         */
        private addHangingVine(worldIn: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.BlockVector3,meta: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.BlockVector3} v 
         */
        private isAirBlock(level: cn.nukkit.level.ChunkManager,v: cn.nukkit.math.BlockVector3): boolean;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {int} age 
         * @param {cn.nukkit.math.BlockVector3} pos 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        private placeCocoa(worldIn: cn.nukkit.level.ChunkManager,age: int,pos: cn.nukkit.math.BlockVector3,side: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {cn.nukkit.math.Vector3} vectorPosition 
         */
        public generate(worldIn: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,vectorPosition: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {int} age 
         * @param {int} side 
         */
        private getCocoaMeta(age: int,side: int): int;
    }
}
declare namespace cn.nukkit.event.level{
     class WeatherChangeEvent extends cn.nukkit.event.level.WeatherEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        to: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public toWeatherState(): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetTimePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        time: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.passive{
    abstract class EntityWaterAnimal extends cn.nukkit.entity.EntityCreature{
        /**
         * 
         */
        public isBaby(): boolean;
    }
}
declare namespace cn.nukkit.event.potion{
     class PotionApplyEvent extends cn.nukkit.event.potion.PotionEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        applyEffect: cn.nukkit.potion.Effect;
        /**  */
        entity: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getApplyEffect(): cn.nukkit.potion.Effect;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {cn.nukkit.potion.Effect} applyEffect 
         */
        public setApplyEffect(applyEffect: cn.nukkit.potion.Effect): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.beach{
     class BeachBiome extends cn.nukkit.level.biome.type.SandyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsJungle extends cn.nukkit.block.BlockStairsWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemPotionLingering extends cn.nukkit.item.ProjectileItem{
        /**
         * 
         */
        public getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getThrowForce(): float;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         */
        protected correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit{
    abstract class IPlayer extends java.lang.Object{
        /**
         * 
         */
        public abstract getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {boolean} value 
         */
        public abstract setBanned(value: boolean): void;
        /**
         * 
         */
        public abstract getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         */
        public abstract hasPlayedBefore(): boolean;
        /**
         * 
         */
        public abstract getFirstPlayed(): java.lang.Long;
        /**
         * 
         */
        public abstract getLastPlayed(): java.lang.Long;
        /**
         * 
         */
        public abstract isBanned(): boolean;
        /**
         * 
         */
        public abstract isOnline(): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public abstract setWhitelisted(value: boolean): void;
        /**
         * 
         */
        public abstract isWhitelisted(): boolean;
        /**
         * 
         */
        public abstract getUniqueId(): java.util.UUID;
    }
}
declare namespace cn.nukkit.utils{
     class PluginException extends cn.nukkit.utils.ServerException{
    }
}
declare namespace cn.nukkit.network.protocol{
     class HurtArmorPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        damage: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        cause: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerHotbarPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        selectHotbarSlot: boolean;
        /**  */
        selectedHotbarSlot: int;
        /**  */
        windowId: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityPrimedTNT extends cn.nukkit.entity.Entity{
        /**  */
        fuse: int;
        /**  */
        NETWORK_ID: int;
        /**  */
        source: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public canCollide(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public getSource(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public explode(): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
        /**
         * 
         */
        protected getBaseOffset(): float;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityBeacon extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        currentTick: long;
        /**  */
        POWER_LEVEL_MAX: int;
        /**
         * 
         */
        public getPowerLevel(): int;
        /**
         * 
         * @param {int} power 
         */
        public setSecondaryPower(power: int): void;
        /**
         * 
         */
        public getPrimaryPower(): int;
        /**
         * 
         */
        private hasSkyAccess(): boolean;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSecondaryPower(): int;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        private calculatePowerLevel(): int;
        /**
         * 
         * @param {int} power 
         */
        public setPrimaryPower(power: int): void;
        /**
         * 
         * @param {int} level 
         */
        public setPowerLevel(level: int): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         * @param {int} primary 
         * @param {int} powerLevel 
         */
        private static isPrimaryAllowed(primary: int,powerLevel: int): boolean;
        /**
         * 
         */
        public onUpdate(): boolean;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {cn.nukkit.Player} player 
         */
        public updateCompoundTag(nbt: cn.nukkit.nbt.tag.CompoundTag,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemBootsLeather extends cn.nukkit.item.ItemColorArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.command.defaults{
     class GiveCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockMycelium extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorBedrock extends cn.nukkit.level.generator.populator.type.Populator{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class UpdateTradePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        unknownVarInt1: int;
        /**  */
        offers: byte[];
        /**  */
        screen2: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        tradeTier: int;
        /**  */
        displayName: java.lang.String;
        /**  */
        trader: long;
        /**  */
        windowType: byte;
        /**  */
        isWilling: boolean;
        /**  */
        windowId: byte;
        /**  */
        player: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoubleSlabRedSandstone extends cn.nukkit.block.BlockDoubleSlabBase{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getSlabName(): java.lang.String;
        /**
         * 
         */
        public getSingleSlabId(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.StoneSlab2Type} type 
         */
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab2Type): void;
        /**
         * 
         */
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab2Type;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace window{
    /**
     * 获取新的自定义窗口构建器
     * @param {java.lang.String} title 标题
     */
    function getCustomWindowBuilder(title: java.lang.String): com.blocklynukkit.loader.script.window.Custom;
    /**
     * 获取设置了主题的swing窗口
     * @param {java.lang.String} title 窗口标题
     * @param {int} width 宽(像素)
     * @param {int} height 高(像素)
     * @param {java.lang.String} iconPath 图标图片路径，png/jpg格式
     */
    function getStyledSwingWindow(title: java.lang.String,width: int,height: int,iconPath: java.lang.String): javax.swing.JFrame;
    /**
     * 更新所有玩家的计分板内容
     * @param {java.lang.String} title 计分板标题
     * @param {java.lang.String} text 计分板内容，以;分割多行
     */
    function updateAllScoreBoard(title: java.lang.String,text: java.lang.String): void;
    /**
     * 获取玩家屏幕最上方boss血条的长度
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getLengthOfPlayerBossBar(player: cn.nukkit.Player): double;
    /**
     * 获取玩家指定id的boss血条的长度
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {long} id 血条id
     */
    function getLengthOfPlayerBossBar(player: cn.nukkit.Player,id: long): double;
    /**
     * 设置tips的静态变量
     * @param {java.lang.String} varname 变量名
     * @param {java.lang.String} toReplace 替换内容
     */
    function makeTipsStatic(varname: java.lang.String,toReplace: java.lang.String): void;
    /**
     * 设置玩家暂停屏幕看到的玩家列表的玩家
     * @param {java.lang.String} list 玩家名，以;分割
     */
    function setPauseScreenList(list: java.lang.String): void;
    /**
     * 获取新的对话框构建器
     * @param {java.lang.String} title 标题
     * @param {java.lang.String} context 文字
     */
    function getModalWindowBuilder(title: java.lang.String,context: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
    /**
     * 更新单个玩家的计分板内容
     * @param {java.lang.String} title 计分板标题
     * @param {java.lang.String} text 计分板内容，以;分割多行
     * @param {cn.nukkit.Player} p 要更新计分板内容的玩家
     */
    function updateOneScoreBoard(title: java.lang.String,text: java.lang.String,p: cn.nukkit.Player): void;
    /**
     * 设置玩家的boss血条，返回此次设置的所有血条的id
     * @param {cn.nukkit.Player} player 要设置玩家血条的id
     * @param {java.lang.String} text 血量内容，以;分割多个血条
     * @param {float} len 血条长度0~1
     */
    function setPlayerBossBar(player: cn.nukkit.Player,text: java.lang.String,len: float): long[];
    /**
     * 让指定玩家的屏幕上开始播放终末之诗
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function startEndPoem(player: cn.nukkit.Player): void;
    /**
     * 从玩家操作窗口事件获取对话框被点击按钮的索引
     * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 玩家操作窗口事件
     */
    function getEventResponseIndex(event: cn.nukkit.event.player.PlayerFormRespondedEvent): int;
    /**
     * 获取新的简单窗口构建器
     * @param {java.lang.String} title 标题
     * @param {java.lang.String} context 文字
     */
    function getSimpleWindowBuilder(title: java.lang.String,context: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
    /**
     * 从玩家操作窗口事件获取高级窗口被操作元素的内容
     * @param {cn.nukkit.event.player.PlayerSettingsRespondedEvent} event 玩家操作服务器设置事件
     * @param {int} id 元素索引
     * @param {java.lang.String} mode 元素种类，可为input/toggle/dropdown/slider/stepslider
     */
    function getEventCustomVar(event: cn.nukkit.event.player.PlayerSettingsRespondedEvent,id: int,mode: java.lang.String): java.lang.String;
    /**
     * 从玩家操作窗口事件获取高级窗口被操作元素的内容
     * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 玩家操作窗口事件
     * @param {int} id 元素索引
     * @param {java.lang.String} mode 元素种类，可为input/toggle/dropdown/slider/stepslider
     */
    function getEventCustomVar(event: cn.nukkit.event.player.PlayerFormRespondedEvent,id: int,mode: java.lang.String): java.lang.String;
    /**
     * 从玩家操作窗口事件获取对话框被点击按钮的文字
     * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 玩家操作窗口事件
     */
    function getEventResponseModal(event: cn.nukkit.event.player.PlayerFormRespondedEvent): java.lang.String;
    /**
     * 设置swing GUI框架的主题
     * @param {java.lang.String} style 主题，可以为Darcula/Intellij/Metal/Motif/Multi/Nimbus/OS
     */
    function setSwingStyle(style: java.lang.String): void;
    /**
     * 强制清除玩家的所有打开的物品栏和对话框窗口
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function forceClearWindow(player: cn.nukkit.Player): void;
    /**
     * 从玩家操作窗口事件获取简单窗口被点击按钮的文字
     * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 玩家操作窗口事件
     */
    function getEventResponseText(event: cn.nukkit.event.player.PlayerFormRespondedEvent): java.lang.String;
    /**
     * 向玩家发送指定玩家的xbox信息对话框
     * @param {cn.nukkit.Player} from 内容来源
     * @param {cn.nukkit.Player} to 被发送的玩家
     */
    function sendPlayerXboxInfo(from: cn.nukkit.Player,to: cn.nukkit.Player): void;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 根据id清除玩家的指定boss血条
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {long} id 血条id
     */
    function removePlayerBossBar(player: cn.nukkit.Player,id: long): void;
    /**
     * 清除玩家的所有boss血条
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function removePlayerBossBar(player: cn.nukkit.Player): void;
    /**
     * 设置tips的动态变量
     * @param {java.lang.String} varname 变量名
     * @param {java.lang.String} provider 回调函数，参数(cn.nukkit.Player要求提供变量的玩家)，返回值将用作变量的替换内容
     */
    function makeTipsVar(varname: java.lang.String,provider: Fun1<cn.nukkit.Player>): void;
    /**
     * 设置玩家名下计分板内容
     * @param {cn.nukkit.Player} player 玩家
     * @param {java.lang.String} str 内容
     */
    function setBelowName(player: cn.nukkit.Player,str: java.lang.String): void;
    /**
     * 获取玩家屏幕最上方boss血条的文字
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getTextOfPlayerBossBar(player: cn.nukkit.Player): java.lang.String;
    /**
     * 获取玩家指定id的boss血条的长度
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {long} id 血条id
     */
    function getTextOfPlayerBossBar(player: cn.nukkit.Player,id: long): java.lang.String;
}
declare namespace cn.nukkit.scheduler{
     class TaskHandler extends java.lang.Object{
        /**  */
        period: int;
        /**  */
        task: java.lang.Runnable;
        /**  */
        delay: int;
        /**  */
        lastRunTick: int;
        /**  */
        nextRunTick: int;
        /**  */
        plugin: cn.nukkit.plugin.Plugin;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        asynchronous: boolean;
        /**  */
        timing: co.aikar.timings.Timing;
        /**  */
        cancelled: boolean;
        /**  */
        taskId: int;
        /**
         * 
         */
        public cancel(): void;
        /**
         * 
         */
        public getTaskId(): int;
        /**
         * 
         * @param {int} nextRunTick 
         */
        public setNextRunTick(nextRunTick: int): void;
        /**
         * 
         */
        public isDelayed(): boolean;
        /**
         * 
         */
        public isCancelled(): boolean;
        /**
         * 
         */
        public getDelay(): int;
        /**
         * 
         */
        public getTaskName(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public run(currentTick: int): void;
        /**
         * 
         * @param {int} period 
         */
        public setPeriod(period: int): void;
        /**
         * 
         */
        public getPeriod(): int;
        /**
         * 
         */
        public remove(): void;
        /**
         * 
         */
        public isAsynchronous(): boolean;
        /**
         * 
         */
        public isRepeating(): boolean;
        /**
         * 
         */
        public getNextRunTick(): int;
        /**
         * 
         */
        public getPlugin(): cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public getLastRunTick(): int;
        /**
         * 
         * @param {int} delay 
         */
        public setDelay(delay: int): void;
        /**
         * 
         * @param {int} lastRunTick 
         */
        public setLastRunTick(lastRunTick: int): void;
        /**
         * 
         */
        public getTask(): java.lang.Runnable;
    }
}
declare namespace cn.nukkit.command.defaults{
     class TimeCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.potion{
     class Effect extends java.lang.Object{
        /**  */
        SLOWNESS: int;
        /**  */
        INVISIBILITY: int;
        /**  */
        SLOW_FALLING: int;
        /**  */
        color: int;
        /**  */
        bad: boolean;
        /**  */
        FATIGUE: int;
        /**  */
        DAMAGE_RESISTANCE: int;
        /**  */
        show: boolean;
        /**  */
        BAD_OMEN: int;
        /**  */
        ambient: boolean;
        /**  */
        WEAKNESS: int;
        /**  */
        INSTANT_DAMAGE: int;
        /**  */
        JUMP: int;
        /**  */
        MINING_FATIGUE: int;
        /**  */
        SPEED: int;
        /**  */
        duration: int;
        /**  */
        WITHER: int;
        /**  */
        FIRE_RESISTANCE: int;
        /**  */
        WATER_BREATHING: int;
        /**  */
        ABSORPTION: int;
        /**  */
        id: int;
        /**  */
        HUNGER: int;
        /**  */
        HARMING: int;
        /**  */
        SWIFTNESS: int;
        /**  */
        FATAL_POISON: int;
        /**  */
        REGENERATION: int;
        /**  */
        VILLAGE_HERO: int;
        /**  */
        STRENGTH: int;
        /**  */
        HEALING: int;
        /**  */
        BLINDNESS: int;
        /**  */
        LEVITATION: int;
        /**  */
        effects: cn.nukkit.potion.Effect[];
        /**  */
        CONDUIT_POWER: int;
        /**  */
        COUNDIT_POWER: int;
        /**  */
        CONFUSION: int;
        /**  */
        JUMP_BOOST: int;
        /**  */
        POISON: int;
        /**  */
        NAUSEA: int;
        /**  */
        RESISTANCE: int;
        /**  */
        HEALTH_BOOST: int;
        /**  */
        name: java.lang.String;
        /**  */
        amplifier: int;
        /**  */
        NIGHT_VISION: int;
        /**  */
        INSTANT_HEALTH: int;
        /**  */
        HASTE: int;
        /**  */
        SATURATION: int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public add(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {boolean} visible 
         */
        public setVisible(visible: boolean): cn.nukkit.potion.Effect;
        /**
         * 
         * @param {int} ticks 
         */
        public setDuration(ticks: int): cn.nukkit.potion.Effect;
        /**
         * 
         */
        public static init(): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getAmplifier(): int;
        /**
         * 
         * @param {int} amplifier 
         */
        public setAmplifier(amplifier: int): cn.nukkit.potion.Effect;
        /**
         * 
         * @param {boolean} ambient 
         */
        public setAmbient(ambient: boolean): cn.nukkit.potion.Effect;
        /**
         * 
         */
        public isBad(): boolean;
        /**
         * 
         */
        public getColor(): int[];
        /**
         * 
         */
        public canTick(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public applyEffect(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isAmbient(): boolean;
        /**
         * 
         */
        public isVisible(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public remove(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} r 
         * @param {int} g 
         * @param {int} b 
         */
        public setColor(r: int,g: int,b: int): void;
        /**
         * 
         */
        public getDuration(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getEffectByName(name: java.lang.String): cn.nukkit.potion.Effect;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.potion.Effect;
        /**
         * 
         * @param {int} id 
         */
        public static getEffect(id: int): cn.nukkit.potion.Effect;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoubleSlabStone extends cn.nukkit.block.BlockDoubleSlabBase{
        /**  */
        SANDSTONE: int;
        /**  */
        WOODEN: int;
        /**  */
        COBBLESTONE: int;
        /**  */
        BRICK: int;
        /**  */
        NETHER_BRICK: int;
        /**  */
        STONE: int;
        /**  */
        STONE_BRICK: int;
        /**  */
        QUARTZ: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getSlabName(): java.lang.String;
        /**
         * 
         */
        public getSingleSlabId(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.StoneSlab1Type} type 
         */
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab1Type): void;
        /**
         * 
         */
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab1Type;
    }
}
declare namespace cn.nukkit.resourcepacks{
    abstract class AbstractResourcePack extends java.lang.Object{
        /**  */
        manifest: com.google.gson.JsonObject;
        /**  */
        id: java.util.UUID;
        /**
         * 
         */
        public getPackId(): java.util.UUID;
        /**
         * 
         */
        public getPackVersion(): java.lang.String;
        /**
         * 
         */
        public getPackName(): java.lang.String;
        /**
         * 
         */
        protected verifyManifest(): boolean;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockPressurePlateBase extends cn.nukkit.block.BlockFlowable{
        /**  */
        onPitch: float;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        offPitch: float;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getRedstonePower(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        protected playOffSound(): void;
        /**
         * 
         */
        protected abstract computeRedstoneStrength(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} oldStrength 
         */
        protected updateState(oldStrength: int): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isActivated(): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         * @param {int} power 
         */
        public setRedstonePower(power: int): void;
        /**
         * 
         */
        protected playOnSound(): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public getMinY(): double;
    }
}
declare namespace cn.nukkit.network.protocol{
     class TakeItemEntityPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        entityId: long;
        /**  */
        target: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityOcelot extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreedingItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemHelmetChain extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerPreLoginEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        kickMessage: java.lang.String;
        /**
         * 
         * @param {java.lang.String} kickMessage 
         */
        public setKickMessage(kickMessage: java.lang.String): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getKickMessage(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class RuntimeItemMapping extends java.lang.Object{
        /**  */
        legacyNetworkMap: it.unimi.dsi.fastutil.ints.Int2IntMap;
        /**  */
        namespaceNetworkMap: java.util.Map;
        /**  */
        networkLegacyMap: it.unimi.dsi.fastutil.ints.Int2IntMap;
        /**  */
        networkNamespaceMap: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**  */
        itemDataPalette: byte[];
        /**
         * 
         * @param {java.util.Map.Entry} e 
         */
        private static lambda$new$0(e: java.util.Map.Entry): java.util.AbstractMap.SimpleEntry;
        /**
         * 
         * @param {java.lang.String} namespaceId 
         * @param {int} amount 
         */
        public getItemByNamespaceId(namespaceId: java.lang.String,amount: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.lang.String} namespaceId 
         */
        private static lambda$getItemByNamespaceId$1(namespaceId: java.lang.String): java.lang.IllegalArgumentException;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getNetworkFullId(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {int} networkId 
         */
        public getNamespacedIdByNetworkId(networkId: int): java.lang.String;
        /**
         * 
         */
        public getItemDataPalette(): byte[];
        /**
         * 
         * @param {int} networkId 
         */
        public getLegacyFullId(networkId: int): int;
        /**
         * 
         * @param {java.lang.String} namespaceId 
         */
        public getNetworkIdByNamespaceId(namespaceId: java.lang.String): java.util.OptionalInt;
    }
}
declare namespace cn.nukkit.item{
     class ItemFishCooked extends cn.nukkit.item.ItemFish{
    }
}
declare namespace com.blocklynukkit.loader.other.net.http{
     class HttpRequestEntry extends java.lang.Object{
        /**  */
        path: java.lang.String;
        /**  */
        protocol: java.lang.String;
        /**  */
        method: java.lang.String;
        /**  */
        requestUrl: java.lang.String;
        /**  */
        parameter: java.lang.String;
        /**  */
        header: java.lang.String;
        /**  */
        fromAddress: java.lang.String;
        /**  */
        exchange: com.sun.net.httpserver.HttpExchange;
        /**  */
        requestRawUrl: java.lang.String;
        /**
         * 
         */
        public getRequestUrl(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} fromAddress 
         */
        public setFromAddress(fromAddress: java.lang.String): void;
        /**
         * 
         */
        public getRequestRawUrl(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} protocol 
         */
        public setProtocol(protocol: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} path 
         */
        public setPath(path: java.lang.String): void;
        /**
         * 
         */
        public getProtocol(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} requestRawUrl 
         */
        public setRequestRawUrl(requestRawUrl: java.lang.String): void;
        /**
         * 
         */
        public getMethod(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} header 
         */
        public setHeader(header: java.lang.String): void;
        /**
         * 
         */
        public getHeader(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.String} value 
         */
        public addResponseHeaderEntry(name: java.lang.String,value: java.lang.String): void;
        /**
         * 
         */
        public addDefaultResponseHeader(): void;
        /**
         * 
         * @param {java.lang.String} charSet 
         */
        public addDefaultResponseHeader(charSet: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} method 
         */
        public setMethod(method: java.lang.String): void;
        /**
         * 
         */
        public getFromAddress(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} header 
         */
        public addResponseHeader(header: java.lang.String): void;
        /**
         * 
         * @param {int} statusCode 
         * @param {byte[]} content 
         */
        public response(statusCode: int,content: byte[]): boolean;
        /**
         * 
         * @param {int} statusCode 
         * @param {java.lang.String} content 
         * @param {java.lang.String} charSet 
         */
        public response(statusCode: int,content: java.lang.String,charSet: java.lang.String): boolean;
        /**
         * 
         * @param {int} statusCode 
         * @param {java.lang.String} content 
         */
        public response(statusCode: int,content: java.lang.String): boolean;
        /**
         * 
         */
        public getPath(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} parameter 
         */
        public setParameter(parameter: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} requestUrl 
         */
        public setRequestUrl(requestUrl: java.lang.String): void;
        /**
         * 
         */
        public getParameter(): java.lang.String;
    }
}
declare namespace cn.nukkit.inventory{
     class BigCraftingGrid extends cn.nukkit.inventory.CraftingGrid{
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.InventoryType;
    }
}
declare namespace cn.nukkit.level.format.anvil.util{
     class NibbleArray extends java.lang.Object{
        /**  */
        data: byte[];
        /**
         * 
         * @param {int} index 
         * @param {byte} value 
         */
        public set(index: int,value: byte): void;
        /**
         * 
         * @param {int} index 
         */
        public get(index: int): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.level.format.anvil.util.NibbleArray;
        /**
         * 
         * @param {byte} value 
         */
        public fill(value: byte): void;
        /**
         * 
         */
        public getData(): byte[];
        /**
         * 
         * @param {byte[]} bytes 
         */
        public copyFrom(bytes: byte[]): void;
        /**
         * 
         * @param {cn.nukkit.level.format.anvil.util.NibbleArray} array 
         */
        public copyFrom(array: cn.nukkit.level.format.anvil.util.NibbleArray): void;
    }
}
declare namespace cn.nukkit.event.block{
    abstract class BlockEvent extends cn.nukkit.event.Event{
        /**  */
        block: cn.nukkit.block.Block;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityChicken extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreedingItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentWaterWalker extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedBlack extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.level{
    abstract class LevelEvent extends cn.nukkit.event.Event{
        /**  */
        level: cn.nukkit.level.Level;
        /**
         * 
         */
        public getLevel(): cn.nukkit.level.Level;
    }
}
declare namespace cn.nukkit.block{
     class BlockMushroomRed extends cn.nukkit.block.BlockMushroom{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected getType(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class HeartParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
     class BlockCocoa extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        ALL: cn.nukkit.math.AxisAlignedBB[];
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        NORTH: cn.nukkit.math.AxisAlignedBB[];
        /**  */
        WEST: cn.nukkit.math.AxisAlignedBB[];
        /**  */
        SOUTH: cn.nukkit.math.AxisAlignedBB[];
        /**  */
        EAST: cn.nukkit.math.AxisAlignedBB[];
        /**  */
        AGE: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public grow(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getGrowthStage(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        private getRelativeBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getMinY(): double;
    }
}
declare namespace cn.nukkit.item{
     class ItemFlintSteel extends cn.nukkit.item.ItemTool{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         */
        private damageItem(player: cn.nukkit.Player,block: cn.nukkit.block.Block): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockBookshelf extends cn.nukkit.block.BlockSolidMeta{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockEnderChest extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        viewers: java.util.Set;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockEntity(): cn.nukkit.blockentity.BlockEntityEnderChest;
        /**
         * 
         */
        public  getBlockEntity(): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getViewers(): java.util.Set;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         */
        public getMinX(): double;
    }
}
declare namespace cn.nukkit.item{
     class ItemSwordGold extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityPistonArm extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        MOVE_STEP: float;
        /**  */
        attachedBlocks: java.util.List;
        /**  */
        powered: boolean;
        /**  */
        sticky: boolean;
        /**  */
        progress: float;
        /**  */
        facing: cn.nukkit.math.BlockFace;
        /**  */
        finished: boolean;
        /**  */
        lastProgress: float;
        /**  */
        state: int;
        /**  */
        extending: boolean;
        /**  */
        newState: int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.BlockFace} moveDirection 
         */
         moveEntity(entity: cn.nukkit.entity.Entity,moveDirection: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        private moveCollidedEntities(): void;
        /**
         * 
         * @param {boolean} extending 
         * @param {java.util.List} attachedBlocks 
         */
        public move(extending: boolean,attachedBlocks: java.util.List): void;
        /**
         * 
         * @param {float} progress 
         */
        private getExtendedProgress(progress: float): float;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        private getAttachedBlocks(): cn.nukkit.nbt.tag.ListTag;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public onUpdate(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedYellow extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemMinecartHopper extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockLavaStill extends cn.nukkit.block.BlockLava{
        /**
         * 
         * @param {int} meta 
         */
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemClownfish extends cn.nukkit.item.ItemFish{
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockID extends java.lang.Object{
        /**  */
        POWERED_COMPARATOR: int;
        /**  */
        WOODEN_DOOR_BLOCK: int;
        /**  */
        STRUCTURE_VOID: int;
        /**  */
        INFO_UPDATE2: int;
        /**  */
        JUNGLE_DOOR_BLOCK: int;
        /**  */
        GREEN_GLAZED_TERRACOTTA: int;
        /**  */
        STONECUTTER: int;
        /**  */
        JUNGLE_PRESSURE_PLATE: int;
        /**  */
        POLISHED_BLACKSTONE_PRESSURE_PLATE: int;
        /**  */
        TRAPPED_CHEST: int;
        /**  */
        STONE_SLAB4: int;
        /**  */
        SLAB: int;
        /**  */
        STONE_BRICK_STAIRS: int;
        /**  */
        WATER: int;
        /**  */
        MELON_STEM: int;
        /**  */
        REEDS: int;
        /**  */
        CAKE_BLOCK: int;
        /**  */
        BAMBOO_SAPLING: int;
        /**  */
        DARK_PRISMARINE_STAIRS: int;
        /**  */
        STRIPPED_BIRCH_LOG: int;
        /**  */
        TWISTING_VINES: int;
        /**  */
        POTATO_BLOCK: int;
        /**  */
        FENCE_GATE_SPRUCE: int;
        /**  */
        LAPIS_BLOCK: int;
        /**  */
        JUNGLE_BUTTON: int;
        /**  */
        FENCE_GATE_BIRCH: int;
        /**  */
        SPRUCE_WOOD_STAIRS: int;
        /**  */
        BROWN_MUSHROOM_BLOCK: int;
        /**  */
        STAINED_GLASS: int;
        /**  */
        TURTLE_EGG: int;
        /**  */
        SUGARCANE_BLOCK: int;
        /**  */
        MAGENTA_GLAZED_TERRACOTTA: int;
        /**  */
        COBBLESTONE: int;
        /**  */
        FENCE_GATE: int;
        /**  */
        BIRCH_WOODEN_STAIRS: int;
        /**  */
        END_BRICK_STAIRS: int;
        /**  */
        DARKOAK_STANDING_SIGN: int;
        /**  */
        DOUBLE_WOODEN_SLAB: int;
        /**  */
        GILDED_BLACKSTONE: int;
        /**  */
        UNLIT_REDSTONE_TORCH: int;
        /**  */
        WOODEN_PRESSURE_PLATE: int;
        /**  */
        UNPOWERED_COMPARATOR: int;
        /**  */
        WHITE_GLAZED_TERRACOTTA: int;
        /**  */
        DARKOAK_WALL_SIGN: int;
        /**  */
        CARROT_BLOCK: int;
        /**  */
        STAINED_HARDENED_CLAY: int;
        /**  */
        POLISHED_ANDESITE_STAIRS: int;
        /**  */
        EMERALD_BLOCK: int;
        /**  */
        RED_NETHER_BRICK: int;
        /**  */
        PRISMARINE_STAIRS: int;
        /**  */
        NETHER_REACTOR: int;
        /**  */
        CRAFTING_TABLE: int;
        /**  */
        ACACIA_WOODEN_STAIRS: int;
        /**  */
        CORAL_BLOCK: int;
        /**  */
        STONE_SLAB3: int;
        /**  */
        LIGHT_BLUE_GLAZED_TERRACOTTA: int;
        /**  */
        STANDING_BANNER: int;
        /**  */
        BLOCK_NETHER_WART_BLOCK: int;
        /**  */
        BLUE_ICE: int;
        /**  */
        LIT_BLAST_FURNACE: int;
        /**  */
        SCAFFOLDING: int;
        /**  */
        CHAIN_BLOCK: int;
        /**  */
        POLISHED_BLACKSTONE_BUTTON: int;
        /**  */
        SPRUCE_WALL_SIGN: int;
        /**  */
        BIRCH_WOOD_STAIRS: int;
        /**  */
        WARPED_SLAB: int;
        /**  */
        CRIMSON_SLAB: int;
        /**  */
        RESPAWN_ANCHOR: int;
        /**  */
        STILL_WATER: int;
        /**  */
        JUNGLE_WALL_SIGN: int;
        /**  */
        CRIMSON_HYPHAE: int;
        /**  */
        JUKEBOX: int;
        /**  */
        ENCHANT_TABLE: int;
        /**  */
        DARK_OAK_BUTTON: int;
        /**  */
        STRIPPED_WARPED_HYPHAE: int;
        /**  */
        WOODEN_SLABS: int;
        /**  */
        STRIPPED_JUNGLE_LOG: int;
        /**  */
        ANCIENT_DERBRIS: int;
        /**  */
        WARPED_STAIRS: int;
        /**  */
        GOLD_BLOCK: int;
        /**  */
        CRIMSON_PLANKS: int;
        /**  */
        HOPPER_BLOCK: int;
        /**  */
        DARK_OAK_PRESSURE_PLATE: int;
        /**  */
        SPRUCE_PRESSURE_PLATE: int;
        /**  */
        HEAVY_WEIGHTED_PRESSURE_PLATE: int;
        /**  */
        ALLOW: int;
        /**  */
        SAND: int;
        /**  */
        SAPLING: int;
        /**  */
        MELON_BLOCK: int;
        /**  */
        CLAY_BLOCK: int;
        /**  */
        CORAL_FAN: int;
        /**  */
        WARPED_HYPHAE: int;
        /**  */
        LECTERN: int;
        /**  */
        WOOD_SLAB: int;
        /**  */
        CRIMSON_FENCE_GATE: int;
        /**  */
        SNOW_LAYER: int;
        /**  */
        LIT_PUMPKIN: int;
        /**  */
        COBBLESTONE_STAIRS: int;
        /**  */
        CRYING_OBSIDIAN: int;
        /**  */
        DETECTOR_RAIL: int;
        /**  */
        STRIPPED_WARPED_STEM: int;
        /**  */
        BEACON: int;
        /**  */
        TERRACOTTA: int;
        /**  */
        HONEYCOMB_BLOCK: int;
        /**  */
        REDSTONE_WIRE: int;
        /**  */
        COBWEB: int;
        /**  */
        DARK_OAK_WALL_SIGN: int;
        /**  */
        GLOWSTONE: int;
        /**  */
        PISTON_HEAD_STICKY: int;
        /**  */
        END_GATEWAY: int;
        /**  */
        MONSTER_SPAWNER: int;
        /**  */
        GLASS_PANE: int;
        /**  */
        DIAMOND_ORE: int;
        /**  */
        PURPLE_GLAZED_TERRACOTTA: int;
        /**  */
        IRON_BARS: int;
        /**  */
        SPONGE: int;
        /**  */
        WARPED_WALL_SIGN: int;
        /**  */
        STONE: int;
        /**  */
        STRIPPED_SPRUCE_LOG: int;
        /**  */
        LIT_SMOKER: int;
        /**  */
        CHORUS_PLANT: int;
        /**  */
        BLACKSTONE_STAIRS: int;
        /**  */
        LEAVES: int;
        /**  */
        BIRCH_STANDING_SIGN: int;
        /**  */
        ANDESITE_STAIRS: int;
        /**  */
        LIT_REDSTONE_LAMP: int;
        /**  */
        ORANGE_GLAZED_TERRACOTTA: int;
        /**  */
        BRICKS: int;
        /**  */
        PISTON_HEAD: int;
        /**  */
        CRIMSON_WALL_SIGN: int;
        /**  */
        TNT: int;
        /**  */
        STRUCTURE_BLOCK: int;
        /**  */
        TRUNK2: int;
        /**  */
        BELL: int;
        /**  */
        ENCHANTING_TABLE: int;
        /**  */
        STAINED_GLASS_PANE: int;
        /**  */
        BLACKSTONE_SLAB: int;
        /**  */
        STRIPPED_ACACIA_LOG: int;
        /**  */
        WOODEN_PLANKS: int;
        /**  */
        BRICKS_BLOCK: int;
        /**  */
        INVISIBLE_BEDROCK: int;
        /**  */
        SOUL_FIRE: int;
        /**  */
        AIR: int;
        /**  */
        GRANITE_STAIRS: int;
        /**  */
        BEE_NEST: int;
        /**  */
        DOUBLE_WOOD_SLABS: int;
        /**  */
        CHEST: int;
        /**  */
        GRASS_PATH: int;
        /**  */
        VINES: int;
        /**  */
        WOOD_STAIRS: int;
        /**  */
        LILY_PAD: int;
        /**  */
        SOUL_LANTERN: int;
        /**  */
        POLISHED_BLACKSTONE_BRICKS: int;
        /**  */
        CONCRETE_POWDER: int;
        /**  */
        PURPUR_STAIRS: int;
        /**  */
        LADDER: int;
        /**  */
        RED_MUSHROOM_BLOCK: int;
        /**  */
        BASALT: int;
        /**  */
        FLOWER_POT_BLOCK: int;
        /**  */
        TRUNK: int;
        /**  */
        TALL_GRASS: int;
        /**  */
        DEAD_BUSH: int;
        /**  */
        COCOA_BLOCK: int;
        /**  */
        CHORUS_FLOWER: int;
        /**  */
        BLACK_GLAZED_TERRACOTTA: int;
        /**  */
        CRIMSON_DOOR_BLOCK: int;
        /**  */
        JUNGLE_WOODEN_STAIRS: int;
        /**  */
        SPRUCE_DOOR_BLOCK: int;
        /**  */
        BARRIER: int;
        /**  */
        ROSE: int;
        /**  */
        WARPED_FENCE_GATE: int;
        /**  */
        GLOWING_REDSTONE_ORE: int;
        /**  */
        CONCRETE: int;
        /**  */
        WARPED_ROOTS: int;
        /**  */
        DOUBLE_RED_SANDSTONE_SLAB: int;
        /**  */
        FARMLAND: int;
        /**  */
        CHISELED_NETHER_BRICKS: int;
        /**  */
        COAL_BLOCK: int;
        /**  */
        WATER_LILY: int;
        /**  */
        ENCHANTMENT_TABLE: int;
        /**  */
        ACACIA_TRAPDOOR: int;
        /**  */
        CRIMSON_STEM: int;
        /**  */
        JIGSAW: int;
        /**  */
        CRIMSON_STANDING_SIGN: int;
        /**  */
        PURPUR_BLOCK: int;
        /**  */
        WARPED_TRAPDOOR: int;
        /**  */
        FURNACE: int;
        /**  */
        WOODEN_PLANK: int;
        /**  */
        JACK_O_LANTERN: int;
        /**  */
        BIRCH_PRESSURE_PLATE: int;
        /**  */
        REDSTONE_BLOCK: int;
        /**  */
        GRASS: int;
        /**  */
        MOSSY_STONE: int;
        /**  */
        CHISELED_POLISHED_BLACKSTONE: int;
        /**  */
        FLOWER: int;
        /**  */
        QUARTZ_BLOCK: int;
        /**  */
        SNOW: int;
        /**  */
        DIRT: int;
        /**  */
        WEEPING_VINES: int;
        /**  */
        MONSTER_EGG: int;
        /**  */
        BONE_BLOCK: int;
        /**  */
        LOG2: int;
        /**  */
        DAYLIGHT_DETECTOR: int;
        /**  */
        WARPED_FENCE: int;
        /**  */
        ACACIA_STANDING_SIGN: int;
        /**  */
        GRINDSTONE: int;
        /**  */
        POWERED_RAIL: int;
        /**  */
        PISTON_EXTENSION: int;
        /**  */
        OBSERVER: int;
        /**  */
        LIT_REDSTONE_ORE: int;
        /**  */
        SPRUCE_TRAPDOOR: int;
        /**  */
        BLAST_FURNACE: int;
        /**  */
        OBSIDIAN: int;
        /**  */
        RED_SANDSTONE_SLAB: int;
        /**  */
        BREWING_BLOCK: int;
        /**  */
        WALL_SIGN: int;
        /**  */
        LIME_GLAZED_TERRACOTTA: int;
        /**  */
        CARTOGRAPHY_TABLE: int;
        /**  */
        SEAGRASS: int;
        /**  */
        SAPLINGS: int;
        /**  */
        WITHER_ROSE: int;
        /**  */
        PISTON: int;
        /**  */
        NETHER_BRICK_BLOCK: int;
        /**  */
        END_PORTAL_FRAME: int;
        /**  */
        OAK_WOODEN_STAIRS: int;
        /**  */
        OAK_WOOD_STAIRS: int;
        /**  */
        LEAVE2: int;
        /**  */
        FENCE_GATE_OAK: int;
        /**  */
        MYCELIUM: int;
        /**  */
        RED_SANDSTONE: int;
        /**  */
        DARK_OAK_DOOR_BLOCK: int;
        /**  */
        STONE_SLAB: int;
        /**  */
        NETHER_BRICKS_STAIRS: int;
        /**  */
        SWEET_BERRY_BUSH: int;
        /**  */
        BUSH: int;
        /**  */
        SNOW_BLOCK: int;
        /**  */
        CRIMSON_FENCE: int;
        /**  */
        ACACIA_DOOR_BLOCK: int;
        /**  */
        WARPED_STANDING_SIGN: int;
        /**  */
        NETHER_BRICK_FENCE: int;
        /**  */
        BORDER_BLOCK: int;
        /**  */
        LAVA_CAULDRON: int;
        /**  */
        BROWN_MUSHROOM: int;
        /**  */
        STONE_BRICKS: int;
        /**  */
        SANDSTONE_STAIRS: int;
        /**  */
        ITEM_FRAME_BLOCK: int;
        /**  */
        POLISHED_BLACKSTONE_SLAB: int;
        /**  */
        NETHERITE_BLOCK: int;
        /**  */
        ACACIA_PRESSURE_PLATE: int;
        /**  */
        POLISHED_GRANITE_STAIRS: int;
        /**  */
        SMOOTH_SANDSTONE_STAIRS: int;
        /**  */
        WALL_BANNER: int;
        /**  */
        DENY: int;
        /**  */
        FIRE: int;
        /**  */
        COBBLE_WALL: int;
        /**  */
        QUARTZ_STAIRS: int;
        /**  */
        DRIED_KELP_BLOCK: int;
        /**  */
        DOOR_BLOCK: int;
        /**  */
        REDSTONE_TORCH: int;
        /**  */
        CACTUS: int;
        /**  */
        STICKY_PISTON: int;
        /**  */
        DOUBLE_WOOD_SLAB: int;
        /**  */
        CRIMSON_ROOTS: int;
        /**  */
        PUMPKIN: int;
        /**  */
        NETHER_WART_BLOCK: int;
        /**  */
        COBBLESTONE_WALL: int;
        /**  */
        FENCE_GATE_JUNGLE: int;
        /**  */
        CRIMSON_NYLIUM: int;
        /**  */
        SLIME_BLOCK: int;
        /**  */
        RED_MUSHROOM: int;
        /**  */
        DROPPER: int;
        /**  */
        UNDYED_SHULKER_BOX: int;
        /**  */
        JUNGLE_STANDING_SIGN: int;
        /**  */
        MOSSY_STONE_BRICK_STAIRS: int;
        /**  */
        STAINED_TERRACOTTA: int;
        /**  */
        DOUBLE_SLAB: int;
        /**  */
        SMOOTH_RED_SANDSTONE_STAIRS: int;
        /**  */
        IRON_TRAPDOOR: int;
        /**  */
        STONECUTTER_BLOCK: int;
        /**  */
        POLISHED_DIORITE_STAIRS: int;
        /**  */
        REDSTONE_ORE: int;
        /**  */
        WARPED_PRESSURE_PLATE: int;
        /**  */
        STRIPPED_CRIMSON_HYPHAE: int;
        /**  */
        STONE_BRICK: int;
        /**  */
        CRIMSON_FUNGUS: int;
        /**  */
        ACACIA_BUTTON: int;
        /**  */
        SIGN_POST: int;
        /**  */
        EMERALD_ORE: int;
        /**  */
        CRIMSON_PRESSURE_PLATE: int;
        /**  */
        COAL_ORE: int;
        /**  */
        MAGMA: int;
        /**  */
        POLISHED_BLACKSTONE_STAIRS: int;
        /**  */
        MOB_SPAWNER: int;
        /**  */
        NETHERREACTOR: int;
        /**  */
        ICE: int;
        /**  */
        SPRUCE_BUTTON: int;
        /**  */
        COBBLE_STAIRS: int;
        /**  */
        GOLD_ORE: int;
        /**  */
        POLISHED_BLACKSTONE: int;
        /**  */
        BEETROOT_BLOCK: int;
        /**  */
        PLANKS: int;
        /**  */
        TARGET: int;
        /**  */
        RED_SANDSTONE_STAIRS: int;
        /**  */
        LOOM: int;
        /**  */
        WOOD: int;
        /**  */
        CORAL_FAN_HANG: int;
        /**  */
        BIRCH_WALL_SIGN: int;
        /**  */
        NETHER_SPROUTS_BLOCK: int;
        /**  */
        DARK_OAK_WOODEN_STAIRS: int;
        /**  */
        BLUE_GLAZED_TERRACOTTA: int;
        /**  */
        DIORITE_STAIRS: int;
        /**  */
        BLACKSTONE_WALL: int;
        /**  */
        BRICK_STAIRS: int;
        /**  */
        END_PORTAL: int;
        /**  */
        WHEAT_BLOCK: int;
        /**  */
        HARDENED_CLAY: int;
        /**  */
        WOOL: int;
        /**  */
        MOSSY_COBBLESTONE_STAIRS: int;
        /**  */
        DARK_OAK_TRAPDOOR: int;
        /**  */
        BAMBOO: int;
        /**  */
        WORKBENCH: int;
        /**  */
        GLASS_PANEL: int;
        /**  */
        CONDUIT: int;
        /**  */
        STICKYPISTONARMCOLLISION: int;
        /**  */
        IRON_DOOR_BLOCK: int;
        /**  */
        MOVING_BLOCK: int;
        /**  */
        PINK_GLAZED_TERRACOTTA: int;
        /**  */
        DANDELION: int;
        /**  */
        PRISMARINE: int;
        /**  */
        INFO_UPDATE: int;
        /**  */
        WARPED_BUTTON: int;
        /**  */
        COCOA: int;
        /**  */
        RED_GLAZED_TERRACOTTA: int;
        /**  */
        ICE_FROSTED: int;
        /**  */
        CORAL_FAN_DEAD: int;
        /**  */
        DIAMOND_BLOCK: int;
        /**  */
        WARPED_STEM: int;
        /**  */
        LEAVES2: int;
        /**  */
        LAVA: int;
        /**  */
        FENCE_GATE_DARK_OAK: int;
        /**  */
        CARPET: int;
        /**  */
        PLANK: int;
        /**  */
        BREWING_STAND_BLOCK: int;
        /**  */
        END_STONE: int;
        /**  */
        GRAVEL: int;
        /**  */
        SEA_LANTERN: int;
        /**  */
        LANTERN: int;
        /**  */
        LAPIS_ORE: int;
        /**  */
        SMOOTH_STONE: int;
        /**  */
        LEAVE: int;
        /**  */
        SMOKER: int;
        /**  */
        DISPENSER: int;
        /**  */
        DOUBLE_SLABS: int;
        /**  */
        COBBLE: int;
        /**  */
        TRIPWIRE: int;
        /**  */
        SMITHING_TABLE: int;
        /**  */
        IRON_ORE: int;
        /**  */
        DAYLIGHT_DETECTOR_INVERTED: int;
        /**  */
        POLISHED_BLACKSTONE_BRICK_SLAB: int;
        /**  */
        NETHERRACK: int;
        /**  */
        CRIMSON_TRAPDOOR: int;
        /**  */
        WARPED_DOUBLE_SLAB: int;
        /**  */
        DRAGON_EGG: int;
        /**  */
        SANDSTONE: int;
        /**  */
        DOUBLE_PLANT: int;
        /**  */
        CRIMSON_STAIRS: int;
        /**  */
        SILVER_GLAZED_TERRACOTTA: int;
        /**  */
        GLOWING_OBSIDIAN: int;
        /**  */
        ANVIL: int;
        /**  */
        SPRUCE_WOODEN_STAIRS: int;
        /**  */
        RED_FLOWER: int;
        /**  */
        TORCH: int;
        /**  */
        WOODEN_SLAB: int;
        /**  */
        ENDER_CHEST: int;
        /**  */
        WOODEN_BUTTON: int;
        /**  */
        CONCRETEPOWDER: int;
        /**  */
        BOOKSHELF: int;
        /**  */
        SMOOTH_QUARTZ_STAIRS: int;
        /**  */
        WOOD_BARK: int;
        /**  */
        LOG: int;
        /**  */
        LEVER: int;
        /**  */
        STONE_PRESSURE_PLATE: int;
        /**  */
        POLISHED_BLACKSTONE_BRICK_STAIRS: int;
        /**  */
        POWERED_REPEATER: int;
        /**  */
        NETHER_GOLD_ORE: int;
        /**  */
        QUARTZ_BRICKS: int;
        /**  */
        GLOWSTONE_BLOCK: int;
        /**  */
        STRIPPED_OAK_LOG: int;
        /**  */
        END_ROD: int;
        /**  */
        WARPED_PLANKS: int;
        /**  */
        HONEY_BLOCK: int;
        /**  */
        QUARTZ_ORE: int;
        /**  */
        BIRCH_TRAPDOOR: int;
        /**  */
        COMPOSTER: int;
        /**  */
        DOUBLE_STONE_SLAB3: int;
        /**  */
        DOUBLE_STONE_SLAB4: int;
        /**  */
        TRAPDOOR: int;
        /**  */
        GLASS: int;
        /**  */
        BED_BLOCK: int;
        /**  */
        WOOD_DOOR_BLOCK: int;
        /**  */
        HAY_BALE: int;
        /**  */
        CORAL_FAN_HANG3: int;
        /**  */
        CRIMSON_BUTTON: int;
        /**  */
        IRON_BLOCK: int;
        /**  */
        CORAL_FAN_HANG2: int;
        /**  */
        REDSTONE_LAMP: int;
        /**  */
        SOUL_SAND: int;
        /**  */
        POLISHED_BLACKSTONE_BRICK_WALL: int;
        /**  */
        PUMPKIN_STEM: int;
        /**  */
        BIRCH_BUTTON: int;
        /**  */
        SOUL_CAMPFIRE_BLOCK: int;
        /**  */
        POPPY: int;
        /**  */
        LIGHT_WEIGHTED_PRESSURE_PLATE: int;
        /**  */
        LIGHT_BLOCK: int;
        /**  */
        TRIPWIRE_HOOK: int;
        /**  */
        PACKED_ICE: int;
        /**  */
        SOUL_SOIL: int;
        /**  */
        END_BRICKS: int;
        /**  */
        SOUL_TORCH: int;
        /**  */
        UNPOWERED_REPEATER: int;
        /**  */
        BLACKSTONE_DOUBLE_SLAB: int;
        /**  */
        VINE: int;
        /**  */
        BUBBLE_COLUMN: int;
        /**  */
        CAMPFIRE_BLOCK: int;
        /**  */
        ACACIA_WALL_SIGN: int;
        /**  */
        STONE_WALL: int;
        /**  */
        JUNGLE_WOOD_STAIRS: int;
        /**  */
        PODZOL: int;
        /**  */
        WARPED_WART_BLOCK: int;
        /**  */
        SKULL_BLOCK: int;
        /**  */
        POLISHED_BLACKSTONE_WALL: int;
        /**  */
        WARPED_NYLIUM: int;
        /**  */
        STRIPPED_CRIMSON_STEM: int;
        /**  */
        POLISHED_BLACKSTONE_DOUBLE_SLAB: int;
        /**  */
        BURNING_FURNACE: int;
        /**  */
        DARK_OAK_WOOD_STAIRS: int;
        /**  */
        BLACKSTONE: int;
        /**  */
        GRAY_GLAZED_TERRACOTTA: int;
        /**  */
        BLOCK_KELP: int;
        /**  */
        POLISHED_BASALT: int;
        /**  */
        WARPED_FUNGUS: int;
        /**  */
        RAIL: int;
        /**  */
        NETHER_PORTAL: int;
        /**  */
        BEDROCK: int;
        /**  */
        SHULKER_BOX: int;
        /**  */
        SHROOMLIGHT: int;
        /**  */
        ACACIA_WOOD_STAIRS: int;
        /**  */
        BIRCH_DOOR_BLOCK: int;
        /**  */
        CYAN_GLAZED_TERRACOTTA: int;
        /**  */
        CARVED_PUMPKIN: int;
        /**  */
        STRIPPED_DARK_OAK_LOG: int;
        /**  */
        CORAL: int;
        /**  */
        IRON_BAR: int;
        /**  */
        WOOD2: int;
        /**  */
        WARPED_DOOR_BLOCK: int;
        /**  */
        WOOD_SLABS: int;
        /**  */
        CRACKED_POLISHED_BLACKSTONE_BRICKS: int;
        /**  */
        CRIMSON_DOUBLE_SLAB: int;
        /**  */
        STONE_BUTTON: int;
        /**  */
        NORMAL_STONE_STAIRS: int;
        /**  */
        CRACKED_NETHER_BRICKS: int;
        /**  */
        PRISMARINE_BRICKS_STAIRS: int;
        /**  */
        SPRUCE_STANDING_SIGN: int;
        /**  */
        DARK_OAK_STANDING_SIGN: int;
        /**  */
        STILL_LAVA: int;
        /**  */
        BEEHIVE: int;
        /**  */
        DOUBLE_WOODEN_SLABS: int;
        /**  */
        NOTEBLOCK: int;
        /**  */
        NETHER_BRICKS: int;
        /**  */
        WOODEN_STAIRS: int;
        /**  */
        FLETCHING_TABLE: int;
        /**  */
        FENCE: int;
        /**  */
        FENCE_GATE_ACACIA: int;
        /**  */
        SLABS: int;
        /**  */
        LODESTONE: int;
        /**  */
        SEA_PICKLE: int;
        /**  */
        LIT_FURNACE: int;
        /**  */
        CAULDRON_BLOCK: int;
        /**  */
        DOUBLE_STONE_SLAB: int;
        /**  */
        JUNGLE_TRAPDOOR: int;
        /**  */
        MOSS_STONE: int;
        /**  */
        ACTIVATOR_RAIL: int;
        /**  */
        RED_NETHER_BRICK_STAIRS: int;
        /**  */
        BROWN_GLAZED_TERRACOTTA: int;
        /**  */
        BARREL: int;
        /**  */
        YELLOW_GLAZED_TERRACOTTA: int;
        /**  */
        POLISHED_BLACKSTONE_BRICK_DOUBLE_SLAB: int;
    }
}
declare namespace cn.nukkit.entity.data{
     class Skin extends java.lang.Object{
        /**  */
        playFabId: java.lang.String;
        /**  */
        capeData: cn.nukkit.utils.SerializedImage;
        /**  */
        PIXEL_SIZE: int;
        /**  */
        animationData: java.lang.String;
        /**  */
        skinColor: java.lang.String;
        /**  */
        fullSkinId: java.lang.String;
        /**  */
        armSize: java.lang.String;
        /**  */
        premium: boolean;
        /**  */
        GEOMETRY_CUSTOM: java.lang.String;
        /**  */
        geometryData: java.lang.String;
        /**  */
        animations: java.util.List;
        /**  */
        DOUBLE_SKIN_SIZE: int;
        /**  */
        tintColors: java.util.List;
        /**  */
        GEOMETRY_CUSTOM_SLIM: java.lang.String;
        /**  */
        capeOnClassic: boolean;
        /**  */
        persona: boolean;
        /**  */
        SKIN_128_128_SIZE: int;
        /**  */
        skinResourcePatch: java.lang.String;
        /**  */
        SKIN_128_64_SIZE: int;
        /**  */
        skinId: java.lang.String;
        /**  */
        personaPieces: java.util.List;
        /**  */
        capeId: java.lang.String;
        /**  */
        trusted: boolean;
        /**  */
        skinData: cn.nukkit.utils.SerializedImage;
        /**  */
        SINGLE_SKIN_SIZE: int;
        /**
         * 
         * @param {java.lang.String} skinColor 
         */
        public setSkinColor(skinColor: java.lang.String): void;
        /**
         * 
         * @param {java.awt.image.BufferedImage} image 
         */
        private static parseBufferedImage(image: java.awt.image.BufferedImage): cn.nukkit.utils.SerializedImage;
        /**
         * 
         * @param {java.lang.String} playFabId 
         */
        public setPlayFabId(playFabId: java.lang.String): void;
        /**
         * 
         * @param {byte[]} skinData 
         */
        public setSkinData(skinData: byte[]): void;
        /**
         * 
         * @param {java.awt.image.BufferedImage} image 
         */
        public setSkinData(image: java.awt.image.BufferedImage): void;
        /**
         * 
         * @param {cn.nukkit.utils.SerializedImage} skinData 
         */
        public setSkinData(skinData: cn.nukkit.utils.SerializedImage): void;
        /**
         * 
         */
        public getSkinId(): java.lang.String;
        /**
         * 
         */
        public getSkinResourcePatch(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} animationData 
         */
        public setAnimationData(animationData: java.lang.String): void;
        /**
         * 
         */
        public getTintColors(): java.util.List;
        /**
         * 
         * @param {java.lang.String} armSize 
         */
        public setArmSize(armSize: java.lang.String): void;
        /**
         * 
         */
        private isValidResourcePatch(): boolean;
        /**
         * 
         */
        public getCapeId(): java.lang.String;
        /**
         * 
         * @param {boolean} premium 
         */
        public setPremium(premium: boolean): void;
        /**
         * 
         * @param {java.lang.String} capeId 
         */
        public setCapeId(capeId: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} skinResourcePatch 
         */
        public setSkinResourcePatch(skinResourcePatch: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} geometryData 
         */
        public setGeometryData(geometryData: java.lang.String): void;
        /**
         * 
         */
        public getPersonaPieces(): java.util.List;
        /**
         * 
         * @param {java.lang.String} geometryName 
         */
        private static convertLegacyGeometryName(geometryName: java.lang.String): java.lang.String;
        /**
         * 
         */
        public getAnimations(): java.util.List;
        /**
         * 
         */
        public isTrusted(): boolean;
        /**
         * 
         */
        private isValidSkin(): boolean;
        /**
         * 
         */
        public getSkinColor(): java.lang.String;
        /**
         * 
         */
        public getPlayFabId(): java.lang.String;
        /**
         * 
         */
        public isPersona(): boolean;
        /**
         * 
         * @param {java.lang.String} skinId 
         */
        public setSkinId(skinId: java.lang.String): void;
        /**
         * 
         * @param {boolean} persona 
         */
        public setPersona(persona: boolean): void;
        /**
         * 
         */
        public isValid(): boolean;
        /**
         * 
         */
        public getSkinData(): cn.nukkit.utils.SerializedImage;
        /**
         * 
         */
        public getCapeData(): cn.nukkit.utils.SerializedImage;
        /**
         * 
         * @param {boolean} capeOnClassic 
         */
        public setCapeOnClassic(capeOnClassic: boolean): void;
        /**
         * 
         */
        public isCapeOnClassic(): boolean;
        /**
         * 
         * @param {cn.nukkit.utils.SerializedImage} capeData 
         */
        public setCapeData(capeData: cn.nukkit.utils.SerializedImage): void;
        /**
         * 
         * @param {byte[]} capeData 
         */
        public setCapeData(capeData: byte[]): void;
        /**
         * 
         * @param {java.awt.image.BufferedImage} image 
         */
        public setCapeData(image: java.awt.image.BufferedImage): void;
        /**
         * 
         */
        public getGeometryData(): java.lang.String;
        /**
         * 
         */
        public getAnimationData(): java.lang.String;
        /**
         * 
         * @param {boolean} trusted 
         */
        public setTrusted(trusted: boolean): void;
        /**
         * 
         * @param {java.lang.String} geometryName 
         */
        public setGeometryName(geometryName: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public generateSkinId(name: java.lang.String): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public isPremium(): boolean;
        /**
         * 
         */
        public getFullSkinId(): java.lang.String;
        /**
         * 
         */
        public getArmSize(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemPufferfish extends cn.nukkit.item.ItemFish{
    }
}
declare namespace cn.nukkit.network.protocol{
     class InteractPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        ACTION_MOUSEOVER: int;
        /**  */
        ACTION_VEHICLE_EXIT: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        ACTION_OPEN_INVENTORY: int;
        /**  */
        action: int;
        /**  */
        target: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSugar extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityVehicleExitEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        vehicle: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getVehicle(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.entity.mob{
    abstract class EntityMob extends cn.nukkit.entity.EntityCreature{
    }
}
declare namespace cn.nukkit.block{
     class BlockNetherBrick extends cn.nukkit.block.BlockBricksNether{
    }
}
declare namespace cn.nukkit.network.protocol{
     class ChunkRadiusUpdatedPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        radius: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.biome.type{
    abstract class CoveredBiome extends cn.nukkit.level.biome.Biome{
        /**  */
        STATE_STONE: cn.nukkit.blockstate.BlockState;
        /**  */
        useNewRakNetSurface: java.lang.Boolean;
        /**  */
        useNewRakNetCover: java.lang.Boolean;
        /**  */
        useNewRakNetGroundBlock: java.lang.Boolean;
        /**  */
        useNewRakNetSurfaceDepth: java.lang.Boolean;
        /**  */
        useNewRakNetGroundDepth: java.lang.Boolean;
        /**  */
        synchronizeCover: java.lang.Object;
        /**
         * 
         * @param {java.lang.Boolean} val 
         */
        private lambda$useNewRakNetSurface$8(val: java.lang.Boolean): void;
        /**
         * 
         */
        private lambda$useNewRakNetSurfaceDepth$3(): void;
        /**
         * 
         */
        private lambda$useNewRakNetSurfaceDepth$4(): java.lang.Boolean;
        /**
         * 
         */
        private lambda$useNewRakNetSurface$6(): void;
        /**
         * 
         * @param {java.lang.Boolean} val 
         */
        private lambda$useNewRakNetSurfaceDepth$5(val: java.lang.Boolean): void;
        /**
         * 
         */
        protected useNewRakNetGroundDepth(): boolean;
        /**
         * 
         */
        private lambda$useNewRakNetSurface$7(): java.lang.Boolean;
        /**
         * 
         * @param {java.lang.Boolean} val 
         */
        private lambda$useNewRakNetCover$2(val: java.lang.Boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public doCover(x: int,z: int,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getCoverId(x: int,z: int): int;
        /**
         * 
         */
        private lambda$useNewRakNetCover$0(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public preCover(x: int,z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getCoverState(x: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        private lambda$useNewRakNetCover$1(): java.lang.Boolean;
        /**
         * 
         * @param {int} y 
         */
        public getGroundBlock(y: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceId(x: int,y: int,z: int): int;
        /**
         * 
         */
        public getCoverBlock(): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundMeta(y: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getStoneBlock(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getGroundDepth(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundDepth(y: int): int;
        /**
         * 
         */
        private useNewRakNetGround(): java.lang.Boolean;
        /**
         * 
         */
        protected useNewRakNetSurface(): boolean;
        /**
         * 
         * @param {java.lang.Boolean} val 
         */
        private useNewRakNetGround(val: java.lang.Boolean): void;
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceMeta(y: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getGroundState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceDepth(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceDepth(y: int): int;
        /**
         * 
         */
        private useNewRakNetGround(): void;
        /**
         * 
         */
        private useNewRakNetGroundDepth(): java.lang.Boolean;
        /**
         * 
         * @param {java.lang.Boolean} val 
         */
        private useNewRakNetGroundDepth(val: java.lang.Boolean): void;
        /**
         * 
         */
        protected useNewRakNetGround(): boolean;
        /**
         * 
         */
        private lambda$useNewRakNetGroundDepth$9(): void;
        /**
         * 
         * @param {java.lang.Runnable} method 
         * @param {java.util.function.Supplier} flagGetter 
         * @param {java.util.function.Consumer} flagSetter 
         */
        protected attemptToUseNewRakNet(method: java.lang.Runnable,flagGetter: java.util.function.Supplier,flagSetter: java.util.function.Consumer): boolean;
        /**
         * 
         */
        protected useNewRakNetCover(): boolean;
        /**
         * 
         */
        protected useNewRakNetSurfaceDepth(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getGroundId(x: int,y: int,z: int): int;
    }
}
declare namespace cn.nukkit.event.potion{
     class PotionCollideEvent extends cn.nukkit.event.potion.PotionEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        thrownPotion: cn.nukkit.entity.item.EntityPotion;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getThrownPotion(): cn.nukkit.entity.item.EntityPotion;
    }
}
declare namespace cn.nukkit.block{
     class BlockHayBale extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.item.randomitem{
     class Selector extends java.lang.Object{
        /**  */
        parent: cn.nukkit.item.randomitem.Selector;
        /**
         * 
         * @param {float[]} totalChance 
         * @param {java.lang.Float} f 
         */
        private static lambda$selectRandom$0(totalChance: float[],f: java.lang.Float): void;
        /**
         * 
         * @param {float[]} flag 
         * @param {float} resultChance 
         * @param {boolean[]} found 
         * @param {cn.nukkit.item.randomitem.Selector[]} temp 
         * @param {cn.nukkit.item.randomitem.Selector} o 
         * @param {java.lang.Float} f 
         */
        private static lambda$selectRandom$1(flag: float[],resultChance: float,found: boolean[],temp: cn.nukkit.item.randomitem.Selector[],o: cn.nukkit.item.randomitem.Selector,f: java.lang.Float): void;
        /**
         * 
         */
        public getParent(): cn.nukkit.item.randomitem.Selector;
        /**
         * 
         */
        public select(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.item.randomitem.Selector} parent 
         */
        public setParent(parent: cn.nukkit.item.randomitem.Selector): cn.nukkit.item.randomitem.Selector;
        /**
         * 
         * @param {java.util.Map} selectorChanceMap 
         */
        public static selectRandom(selectorChanceMap: java.util.Map): cn.nukkit.item.randomitem.Selector;
    }
}
declare namespace cn.nukkit.item{
     class ItemPorkchopCooked extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.level.biome.impl.forest{
     class ForestHillsBiome extends cn.nukkit.level.biome.impl.forest.ForestBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.level{
     class ThunderChangeEvent extends cn.nukkit.event.level.WeatherEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        to: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public toThunderState(): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment.protection{
     class EnchantmentProtectionExplosion extends cn.nukkit.item.enchantment.protection.EnchantmentProtection{
        /**
         * 
         */
        public getTypeModifier(): double;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} e 
         */
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float;
    }
}
declare namespace cn.nukkit.block{
     class BlockGrassPath extends cn.nukkit.block.BlockGrass{
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockBeetroot extends cn.nukkit.block.BlockCrops{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorWood extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.biome.impl.extremehills{
     class ExtremeHillsPlusMBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsMBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public doesOverhang(): boolean;
    }
}
declare namespace cn.nukkit.network{
    abstract class SourceInterface extends java.lang.Object{
        /**
         * 
         * @param {java.lang.String} name 
         */
        public abstract setName(name: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public abstract putPacket(player: cn.nukkit.Player,packet: cn.nukkit.network.protocol.DataPacket): java.lang.Integer;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {boolean} needACK 
         */
        public abstract putPacket(player: cn.nukkit.Player,packet: cn.nukkit.network.protocol.DataPacket,needACK: boolean): java.lang.Integer;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         * @param {boolean} needACK 
         * @param {boolean} immediate 
         */
        public abstract putPacket(player: cn.nukkit.Player,packet: cn.nukkit.network.protocol.DataPacket,needACK: boolean,immediate: boolean): java.lang.Integer;
        /**
         * 
         */
        public abstract process(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public abstract getNetworkLatency(player: cn.nukkit.Player): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {java.lang.String} reason 
         */
        public abstract close(player: cn.nukkit.Player,reason: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public abstract close(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public abstract shutdown(): void;
        /**
         * 
         */
        public abstract emergencyShutdown(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockFlower extends cn.nukkit.block.BlockFlowable{
        /**  */
        TYPE_ALLIUM: int;
        /**  */
        RED_FLOWER_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        TYPE_OXEYE_DAISY: int;
        /**  */
        TYPE_BLUE_ORCHID: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        TYPE_ORANGE_TULIP: int;
        /**  */
        TYPE_AZURE_BLUET: int;
        /**  */
        TYPE_RED_TULIP: int;
        /**  */
        TYPE_PINK_TULIP: int;
        /**  */
        TYPE_POPPY: int;
        /**  */
        TYPE_WHITE_TULIP: int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.SmallFlowerType} flowerType 
         */
        public setFlowerType(flowerType: cn.nukkit.blockproperty.value.SmallFlowerType): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public canPlantOn(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getFlowerType(): cn.nukkit.blockproperty.value.SmallFlowerType;
        /**
         * 
         */
        protected getUncommonFlower(): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.SmallFlowerType} acceptsOnly 
         * @param {cn.nukkit.blockproperty.value.SmallFlowerType} attemptedToSet 
         */
        protected setOnSingleFlowerType(acceptsOnly: cn.nukkit.blockproperty.value.SmallFlowerType,attemptedToSet: cn.nukkit.blockproperty.value.SmallFlowerType): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public static isSupportValid(block: cn.nukkit.block.Block): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class DebugInfoPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        data: java.lang.String;
        /**  */
        NETWORK_ID: byte;
        /**  */
        entityId: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemPickaxeIron extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneTorch extends cn.nukkit.block.BlockTorch{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public tickRate(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        private checkState(): boolean;
        /**
         * 
         */
        protected isPoweredFromSide(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.plugin.service{
    abstract class ServiceManager extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Class} service 
         * @param {java.lang.Object} provider 
         */
        public abstract cancel(service: java.lang.Class,provider: java.lang.Object): cn.nukkit.plugin.service.RegisteredServiceProvider;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public abstract cancel(plugin: cn.nukkit.plugin.Plugin): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         */
        public abstract isProvidedFor(service: java.lang.Class): boolean;
        /**
         * 
         */
        public abstract getKnownService(): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         */
        public abstract getProvider(service: java.lang.Class): cn.nukkit.plugin.service.RegisteredServiceProvider;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public abstract getRegistrations(plugin: cn.nukkit.plugin.Plugin): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         */
        public abstract getRegistrations(service: java.lang.Class): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         * @param {java.lang.Object} provider 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {cn.nukkit.plugin.service.ServicePriority} priority 
         */
        public abstract register(service: java.lang.Class,provider: java.lang.Object,plugin: cn.nukkit.plugin.Plugin,priority: cn.nukkit.plugin.service.ServicePriority): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemTrident extends cn.nukkit.item.ItemTool{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onRelease(player: cn.nukkit.Player,ticksUsed: int): boolean;
    }
}
declare namespace com.blocklynukkit.loader.other.inventoty{
     class HopperFakeInventory extends com.nukkitx.fakeinventories.inventory.FakeInventory{
        /**  */
        name: java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} pos 
         * @param {java.lang.String} name 
         */
        private static getNbt(pos: cn.nukkit.math.BlockVector3,name: java.lang.String): byte[];
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         * @param {cn.nukkit.math.BlockVector3} pos 
         */
        protected placeHopper(who: cn.nukkit.Player,pos: cn.nukkit.math.BlockVector3): void;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        protected onOpenBlock(who: cn.nukkit.Player): java.util.List;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityCombustEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        duration: int;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {int} duration 
         */
        public setDuration(duration: int): void;
        /**
         * 
         */
        public getDuration(): int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerGameModeChangeEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        newAdventureSettings: cn.nukkit.AdventureSettings;
        /**  */
        gamemode: int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.AdventureSettings} newAdventureSettings 
         */
        public setNewAdventureSettings(newAdventureSettings: cn.nukkit.AdventureSettings): void;
        /**
         * 
         */
        public getNewAdventureSettings(): cn.nukkit.AdventureSettings;
        /**
         * 
         */
        public getNewGamemode(): int;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class JungleBigTreePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.command{
    abstract class CommandSender extends java.lang.Object{
        /**
         * 
         */
        public abstract getServer(): cn.nukkit.Server;
        /**
         * 
         */
        public abstract isPlayer(): boolean;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         */
        public abstract sendMessage(message: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract sendMessage(message: java.lang.String): void;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorLilyPad extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockLava extends cn.nukkit.block.BlockLiquid{
        /**
         * 
         * @param {int} meta 
         */
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public tickRate(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public addVelocityToEntity(entity: cn.nukkit.entity.Entity,vector: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        protected checkForHarden(): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} newFlowDecay 
         */
        protected flowIntoBlock(block: cn.nukkit.block.Block,newFlowDecay: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected isSurroundingBlockFlammable(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getFlowDecayPerBlock(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.level.biome.impl{
     class HellBiome extends cn.nukkit.level.biome.Biome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isDry(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemAxeIron extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.inventory{
     class StartBrewEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        brewingStand: cn.nukkit.blockentity.BlockEntityBrewingStand;
        /**  */
        ingredient: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        potions: cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} index 
         */
        public getPotion(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getIngredient(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getBrewingStand(): cn.nukkit.blockentity.BlockEntityBrewingStand;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPotions(): cn.nukkit.item.Item[];
    }
}
declare namespace cn.nukkit.command{
     class SimpleCommandMap extends java.lang.Object{
        /**  */
        server: cn.nukkit.Server;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        knownCommands: java.util.Map;
        /**
         * 
         */
        public clearCommands(): void;
        /**
         * 
         */
        private setDefaultCommands(): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} cmdLine 
         */
        public dispatch(sender: cn.nukkit.command.CommandSender,cmdLine: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getCommand(name: java.lang.String): cn.nukkit.command.Command;
        /**
         * 
         * @param {java.lang.String} fallbackPrefix 
         * @param {java.util.List} commands 
         */
        public registerAll(fallbackPrefix: java.lang.String,commands: java.util.List): void;
        /**
         * 
         * @param {cn.nukkit.command.simple.Parameter} parameter 
         */
        private static lambda$null$0(parameter: cn.nukkit.command.simple.Parameter): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {int} x$0 
         */
        private static lambda$null$1(x$0: int): cn.nukkit.command.data.CommandParameter[];
        /**
         * 
         */
        public registerServerAliases(): void;
        /**
         * 
         */
        public getCommands(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.command.simple.Parameters} parameters 
         */
        private static lambda$registerSimpleCommands$2(parameters: cn.nukkit.command.simple.Parameters): cn.nukkit.command.data.CommandParameter[];
        /**
         * 
         * @param {cn.nukkit.command.Command} command 
         * @param {boolean} isAlias 
         * @param {java.lang.String} fallbackPrefix 
         * @param {java.lang.String} label 
         */
        private registerAlias(command: cn.nukkit.command.Command,isAlias: boolean,fallbackPrefix: java.lang.String,label: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.Object} object 
         */
        public registerSimpleCommands(object: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.String} cmdLine 
         */
        private parseArguments(cmdLine: java.lang.String): java.util.ArrayList;
        /**
         * 
         * @param {java.lang.String} fallbackPrefix 
         * @param {cn.nukkit.command.Command} command 
         * @param {java.lang.String} label 
         */
        public register(fallbackPrefix: java.lang.String,command: cn.nukkit.command.Command,label: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} fallbackPrefix 
         * @param {cn.nukkit.command.Command} command 
         */
        public register(fallbackPrefix: java.lang.String,command: cn.nukkit.command.Command): boolean;
    }
}
declare namespace cn.nukkit.entity.data{
     class Vector3fEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} data 
         */
        public setData(data: cn.nukkit.math.Vector3f): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): cn.nukkit.math.Vector3f;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreIron extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemPotatoPoisonous extends cn.nukkit.item.ItemPotato{
    }
}
declare namespace cn.nukkit.network.protocol{
     class LevelSoundEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        SOUND_HIT: int;
        /**  */
        SOUND_IMITATE_ILLUSION_ILLAGER: int;
        /**  */
        SOUND_ENDERCHEST_CLOSED: int;
        /**  */
        SOUND_RECORD_CHIRP: int;
        /**  */
        SOUND_MOB_WARNING_BABY: int;
        /**  */
        SOUND_CROSSBOW_LOADING_START: int;
        /**  */
        SOUND_TAKEOFF: int;
        /**  */
        SOUND_DEATH_MIN_VOLUME: int;
        /**  */
        SOUND_IMITATE_VEX: int;
        /**  */
        SOUND_BEACON_ACTIVATE: int;
        /**  */
        SOUND_GALLOP: int;
        /**  */
        SOUND_AMBIENT_TAME: int;
        /**  */
        SOUND_ARMOR_EQUIP_GENERIC: int;
        /**  */
        SOUND_LT_REACTION_FIREBALL: int;
        /**  */
        SOUND_DEATH_IN_WATER: int;
        /**  */
        SOUND_LAVA: int;
        /**  */
        SOUND_BLOCK_TURTLE_EGG_BREAK: int;
        /**  */
        SOUND_CROSSBOW_LOADING_MIDDLE: int;
        /**  */
        SOUND_PISTON_IN: int;
        /**  */
        SOUND_SPAWN: int;
        /**  */
        SOUND_PURR: int;
        /**  */
        SOUND_ARMOR_EQUIP_DIAMOND: int;
        /**  */
        SOUND_CHARGE: int;
        /**  */
        SOUND_LAUNCH: int;
        /**  */
        SOUND_BREATHE: int;
        /**  */
        SOUND_HAGGLE: int;
        /**  */
        SOUND_CHORUSGROW: int;
        /**  */
        SOUND_LAVA_POP: int;
        /**  */
        SOUND_IMITATE_SPIDER: int;
        /**  */
        SOUND_SWOOP: int;
        /**  */
        SOUND_CONDUIT_SHORT: int;
        /**  */
        SOUND_BLOCK_END_PORTAL_FRAME_FILL: int;
        /**  */
        SOUND_LEASHKNOT_BREAK: int;
        /**  */
        SOUND_GUARDIAN_FLOP: int;
        /**  */
        SOUND_STEP_BABY: int;
        /**  */
        SOUND_DEATH_MID_VOLUME: int;
        /**  */
        SOUND_IMITATE_SKELETON: int;
        /**  */
        SOUND_IMITATE_SLIME: int;
        /**  */
        SOUND_LT_REACTION_MISCEXPLOSION: int;
        /**  */
        SOUND_BUCKET_EMPTY_FISH: int;
        /**  */
        SOUND_CAMERA_TAKE_PICTURE: int;
        /**  */
        SOUND_BUBBLE_UPINSIDE: int;
        /**  */
        SOUND_GROWL: int;
        /**  */
        SOUND_CROSSBOW_SHOOT: int;
        /**  */
        SOUND_DEATH: int;
        /**  */
        SOUND_SNEEZE: int;
        /**  */
        SOUND_TWINKLE: int;
        /**  */
        SOUND_CROSSBOW_QUICK_CHARGE_END: int;
        /**  */
        SOUND_PISTON_OUT: int;
        /**  */
        SOUND_IMITATE_GHAST: int;
        /**  */
        SOUND_ITEM_TRIDENT_RIPTIDE_1: int;
        /**  */
        SOUND_ITEM_TRIDENT_RIPTIDE_2: int;
        /**  */
        SOUND_ITEM_TRIDENT_RIPTIDE_3: int;
        /**  */
        SOUND_IMITATE_CAVE_SPIDER: int;
        /**  */
        SOUND_BEACON_AMBIENT: int;
        /**  */
        SOUND_STEP: int;
        /**  */
        SOUND_CONVERT_TO_DROWNED: int;
        /**  */
        SOUND_CONDUIT_ACTIVATE: int;
        /**  */
        SOUND_SPLASH: int;
        /**  */
        SOUND_PLACE: int;
        /**  */
        SOUND_DRINK: int;
        /**  */
        SOUND_POWER_OFF: int;
        /**  */
        SOUND_ARMOR_EQUIP_GOLD: int;
        /**  */
        SOUND_SADDLE: int;
        /**  */
        SOUND_PREPARE_WOLOLO: int;
        /**  */
        SOUND_PLOP: int;
        /**  */
        SOUND_RECORD_CAT: int;
        /**  */
        SOUND_GLOWSTICK_USE: int;
        /**  */
        SOUND_BOW_HIT: int;
        /**  */
        SOUND_IMITATE_EVOCATION_ILLAGER: int;
        /**  */
        SOUND_LT_REACTION_MISCMYSTICAL2: int;
        /**  */
        SOUND_IMITATE_MAGMA_CUBE: int;
        /**  */
        SOUND_IMITATE_SILVERFISH: int;
        /**  */
        SOUND_BOW: int;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        SOUND_MOB_WARNING: int;
        /**  */
        z: float;
        /**  */
        SOUND_LARGE_BLAST: int;
        /**  */
        SOUND_IMITATE_ELDER_GUARDIAN: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        SOUND_RECORD_WARD: int;
        /**  */
        SOUND_PANT: int;
        /**  */
        SOUND_IMITATE_POLAR_BEAR: int;
        /**  */
        SOUND_CHEST_CLOSED: int;
        /**  */
        SOUND_FUSE: int;
        /**  */
        SOUND_CONDUIT_AMBIENT: int;
        /**  */
        SOUND_UNDEFINED: int;
        /**  */
        SOUND_FALL_BIG: int;
        /**  */
        SOUND_IGNITE: int;
        /**  */
        SOUND_STOP_RECORD: int;
        /**  */
        SOUND_PREPARE_ATTACK: int;
        /**  */
        SOUND_BORN: int;
        /**  */
        SOUND_BUCKET_EMPTY_WATER: int;
        /**  */
        SOUND_BOTTLE_DRAGONBREATH: int;
        /**  */
        SOUND_ATTACK_NODAMAGE: int;
        /**  */
        SOUND_LT_REACTION_BLEACH: int;
        /**  */
        SOUND_BUBBLE_DOWNINSIDE: int;
        /**  */
        SOUND_FIZZ: int;
        /**  */
        SOUND_BUCKET_EMPTY_LAVA: int;
        /**  */
        SOUND_BUCKET_FILL_FISH: int;
        /**  */
        SOUND_CONDUIT_DEACTIVATE: int;
        /**  */
        SOUND_BEACON_POWER: int;
        /**  */
        SOUND_RECORD_MELLOHI: int;
        /**  */
        SOUND_DEATH_BABY: int;
        /**  */
        SOUND_SHOOT: int;
        /**  */
        SOUND_CONDUIT_ATTACK: int;
        /**  */
        SOUND_ATTACK_STRONG: int;
        /**  */
        SOUND_PREPARE_SUMMON: int;
        /**  */
        SOUND_ENDERCHEST_OPEN: int;
        /**  */
        SOUND_BREAK: int;
        /**  */
        SOUND_ATTACK: int;
        /**  */
        SOUND_STARE: int;
        /**  */
        SOUND_POP: int;
        /**  */
        SOUND_RANDOM_ANVIL_USE: int;
        /**  */
        SOUND_SQUISH_SMALL: int;
        /**  */
        SOUND_SPARKLER_ACTIVE: int;
        /**  */
        SOUND_HAGGLE_IDLE: int;
        /**  */
        SOUND_RECORD_BLOCKS: int;
        /**  */
        SOUND_ATTACH: int;
        /**  */
        SOUND_IMITATE_STRAY: int;
        /**  */
        SOUND_EXTINGUISH_FIRE: int;
        /**  */
        SOUND_SHULKER_CLOSE: int;
        /**  */
        SOUND_AMBIENT_BABY: int;
        /**  */
        SOUND_BLOCK_TURTLE_EGG_HATCH: int;
        /**  */
        SOUND_DEFAULT: int;
        /**  */
        SOUND_LEASHKNOT_PLACE: int;
        /**  */
        SOUND_ARMOR: int;
        /**  */
        SOUND_CHORUSDEATH: int;
        /**  */
        entityIdentifier: java.lang.String;
        /**  */
        SOUND_RECORD_STAL: int;
        /**  */
        SOUND_ITEM_FIZZ: int;
        /**  */
        SOUND_ELDERGUARDIAN_CURSE: int;
        /**  */
        SOUND_ARMOR_EQUIP_ELYTRA: int;
        /**  */
        SOUND_SHULKERBOX_OPEN: int;
        /**  */
        SOUND_CROSSBOW_QUICK_CHARGE_MIDDLE: int;
        /**  */
        SOUND_FALL: int;
        /**  */
        SOUND_FLAP: int;
        /**  */
        SOUND_ITEM_USE_ON: int;
        /**  */
        SOUND_IMITATE_VINDICATION_ILLAGER: int;
        /**  */
        SOUND_IMITATE_ZOMBIE_VILLAGER: int;
        /**  */
        SOUND_IMITATE_WITCH: int;
        /**  */
        SOUND_LT_REACTION_MGSALT: int;
        /**  */
        SOUND_TELEPORT: int;
        /**  */
        SOUND_ITEM_TRIDENT_THUNDER: int;
        /**  */
        SOUND_BULLET_HIT: int;
        /**  */
        SOUND_NOTE: int;
        /**  */
        SOUND_LAND: int;
        /**  */
        extraData: int;
        /**  */
        SOUND_RECORD_13: int;
        /**  */
        SOUND_AMBIENT_AGGRESSIVE: int;
        /**  */
        SOUND_CROSSBOW_QUICK_CHARGE_START: int;
        /**  */
        SOUND_HAGGLE_NO: int;
        /**  */
        SOUND_CANT_BREED: int;
        /**  */
        SOUND_AMBIENT_WORRIED: int;
        /**  */
        SOUND_ITEM_TRIDENT_HIT_GROUND: int;
        /**  */
        SOUND_BREAK_BLOCK: int;
        /**  */
        SOUND_BUBBLE_POP: int;
        /**  */
        SOUND_PORTAL: int;
        /**  */
        SOUND_BURP: int;
        /**  */
        SOUND_CHEST_OPEN: int;
        /**  */
        SOUND_BOOST: int;
        /**  */
        SOUND_ICEBOMB_HIT: int;
        /**  */
        SOUND_HURT_BABY: int;
        /**  */
        SOUND_FLY: int;
        /**  */
        SOUND_IMITATE_ENDERMAN: int;
        /**  */
        SOUND_POTION_BREWED: int;
        /**  */
        SOUND_IMITATE_BLAZE: int;
        /**  */
        SOUND_SCARED: int;
        /**  */
        SOUND_RECORD_MALL: int;
        /**  */
        SOUND_MILK: int;
        /**  */
        SOUND_ADD_CHEST: int;
        /**  */
        SOUND_RECORD_FAR: int;
        /**  */
        SOUND_RECORD_PIGSTEP: int;
        /**  */
        SOUND_BUCKET_FILL_LAVA: int;
        /**  */
        SOUND_BUBBLE_UP: int;
        /**  */
        SOUND_FANG: int;
        /**  */
        SOUND_JUMP: int;
        /**  */
        SOUND_IMITATE_HUSK: int;
        /**  */
        SOUND_DETACH: int;
        /**  */
        SOUND_PRESNEEZE: int;
        /**  */
        SOUND_THROW: int;
        /**  */
        SOUND_RECORD_STRAD: int;
        /**  */
        SOUND_DENY: int;
        /**  */
        SOUND_ITEM_TRIDENT_HIT: int;
        /**  */
        SOUND_HURT: int;
        /**  */
        SOUND_IMITATE_ZOMBIE: int;
        /**  */
        SOUND_BLOCK_END_PORTAL_SPAWN: int;
        /**  */
        SOUND_BLOCK_TURTLE_EGG_ATTACK: int;
        /**  */
        SOUND_SHEAR: int;
        /**  */
        SOUND_FALL_SMALL: int;
        /**  */
        SOUND_EXPLODE: int;
        /**  */
        SOUND_ITEM_TRIDENT_THROW: int;
        /**  */
        SOUND_POWER_ON: int;
        /**  */
        isBabyMob: boolean;
        /**  */
        SOUND_GLASS: int;
        /**  */
        isGlobal: boolean;
        /**  */
        SOUND_PURREOW: int;
        /**  */
        SOUND_IMITATE_SHULKER: int;
        /**  */
        SOUND_LT_REACTION_MISCFIRE: int;
        /**  */
        SOUND_SQUISH_BIG: int;
        /**  */
        SOUND_BALLOONPOP: int;
        /**  */
        SOUND_LT_REACTION_ICEBOMB: int;
        /**  */
        SOUND_IMITATE_CREEPER: int;
        /**  */
        sound: int;
        /**  */
        SOUND_DROP_SLOT: int;
        /**  */
        SOUND_SHULKERBOX_CLOSED: int;
        /**  */
        SOUND_LT_REACTION_FIRE: int;
        /**  */
        SOUND_SHAKE: int;
        /**  */
        SOUND_ARMOR_EQUIP_LEATHER: int;
        /**  */
        SOUND_RECORD_WAIT: int;
        /**  */
        SOUND_PORTAL_TRAVEL: int;
        /**  */
        SOUND_CROSSBOW_LOADING_END: int;
        /**  */
        SOUND_WARN: int;
        /**  */
        SOUND_AMBIENT_IN_WATER: int;
        /**  */
        SOUND_SHULKER_OPEN: int;
        /**  */
        SOUND_HURT_IN_WATER: int;
        /**  */
        SOUND_SWIM: int;
        /**  */
        SOUND_DEATH_TO_ZOMBIE: int;
        /**  */
        SOUND_BLOCK_TURTLE_EGG_CRACK: int;
        /**  */
        SOUND_BUBBLE_DOWN: int;
        /**  */
        SOUND_BLOCK_SCAFFOLDING_CLIMB: int;
        /**  */
        SOUND_IMITATE_WITHER: int;
        /**  */
        SOUND_BUCKET_FILL_WATER: int;
        /**  */
        SOUND_IMITATE_WOLF: int;
        /**  */
        SOUND_BLAST: int;
        /**  */
        SOUND_IMITATE_WITHER_SKELETON: int;
        /**  */
        SOUND_WHINE: int;
        /**  */
        SOUND_LT_REACTION_PRODUCT: int;
        /**  */
        SOUND_TRIPOD: int;
        /**  */
        SOUND_REMEDY: int;
        /**  */
        SOUND_THORNS: int;
        /**  */
        SOUND_HAGGLE_YES: int;
        /**  */
        SOUND_FIRE: int;
        /**  */
        SOUND_IMITATE_ZOMBIE_PIGMAN: int;
        /**  */
        SOUND_CAST_SPELL: int;
        /**  */
        SOUND_MAD: int;
        /**  */
        SOUND_BLOCK_BAMBOO_SAPLING_PLACE: int;
        /**  */
        SOUND_HEAVY_STEP: int;
        /**  */
        SOUND_EAT: int;
        /**  */
        SOUND_ITEM_TRIDENT_RETURN: int;
        /**  */
        SOUND_LT_REACTION_EPASTE: int;
        /**  */
        SOUND_AMBIENT: int;
        /**  */
        SOUND_LT_REACTION_FERTILIZER: int;
        /**  */
        SOUND_THUNDER: int;
        /**  */
        SOUND_LEVELUP: int;
        /**  */
        SOUND_IMITATE_ENDER_DRAGON: int;
        /**  */
        SOUND_MOB_ARMOR_STAND_PLACE: int;
        /**  */
        SOUND_ELEMCONSTRUCT_OPEN: int;
        /**  */
        SOUND_ARMOR_EQUIP_CHAIN: int;
        /**  */
        SOUND_LT_REACTION_EPASTE2: int;
        /**  */
        SOUND_WATER: int;
        /**  */
        SOUND_BEACON_DEACTIVATE: int;
        /**  */
        SOUND_LT_REACTION_MISCMYSTICAL: int;
        /**  */
        SOUND_UNFECT: int;
        /**  */
        SOUND_RECORD_11: int;
        /**  */
        SOUND_ARMOR_EQUIP_IRON: int;
        /**  */
        SOUND_SPARKLER_USE: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.utils{
     class Utils extends java.lang.Object{
        /**  */
        random: java.util.SplittableRandom;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        EMPTY_INTEGERS: java.lang.Integer[];
        /**
         * 
         * @param {java.io.File} from 
         * @param {java.io.File} to 
         */
        public static copyFile(from: java.io.File,to: java.io.File): void;
        /**
         * 
         * @param {java.lang.Object[][]} array 
         */
        public static clone2dArray(array: java.lang.Object[][]): java.lang.Object[][];
        /**
         * 
         * @param {java.lang.Object} number 
         */
        public static toInt(number: java.lang.Object): int;
        /**
         * 
         * @param {byte} r 
         * @param {byte} g 
         * @param {byte} b 
         * @param {byte} a 
         */
        public static toRGB(r: byte,g: byte,b: byte,a: byte): long;
        /**
         * 
         * @param {java.lang.String} s 
         * @param {char} character 
         */
        public static rtrim(s: java.lang.String,character: char): java.lang.String;
        /**
         * 
         * @param {java.lang.Object[]} arrayToSplit 
         * @param {int} chunkSize 
         */
        public static splitArray(arrayToSplit: java.lang.Object[],chunkSize: int): java.lang.Object[][];
        /**
         * 
         */
        public static getAllThreadDumps(): java.lang.String;
        /**
         * 
         * @param {int} argb 
         */
        public static toABGR(argb: int): long;
        /**
         * 
         * @param {double} min 
         * @param {double} max 
         */
        public static rand(min: double,max: double): double;
        /**
         * 
         */
        public static rand(): boolean;
        /**
         * 
         * @param {int} min 
         * @param {int} max 
         */
        public static rand(min: int,max: int): int;
        /**
         * 
         * @param {java.lang.Throwable} e 
         */
        public static getExceptionMessage(e: java.lang.Throwable): java.lang.String;
        /**
         * 
         * @param {java.lang.String} str 
         */
        public static isInteger(str: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.Object[]} array 
         * @param {boolean} copy 
         */
        public static reverseArray(array: java.lang.Object[],copy: boolean): java.lang.Object[];
        /**
         * 
         * @param {java.lang.Object[]} data 
         */
        public static reverseArray(data: java.lang.Object[]): void;
        /**
         * 
         * @param {java.lang.String} s 
         */
        public static parseHexBinary(s: java.lang.String): byte[];
        /**
         * 
         * @param {byte[]} array 
         */
        public static isByteArrayEmpty(array: byte[]): boolean;
        /**
         * 
         * @param {java.io.File} currentFile 
         * @param {java.util.function.Consumer} operation 
         */
        public static safeWrite(currentFile: java.io.File,operation: java.util.function.Consumer): void;
        /**
         * 
         * @param {java.io.File} file 
         */
        public static readFile(file: java.io.File): java.lang.String;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public static readFile(filename: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.io.Reader} reader 
         */
        private static readFile(reader: java.io.Reader): java.lang.String;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         */
        public static readFile(inputStream: java.io.InputStream): java.lang.String;
        /**
         * 
         * @param {java.util.Map} map 
         * @param {java.lang.Class} clazz 
         * @param {java.lang.Object} key 
         */
        public static getOrCreate(map: java.util.Map,clazz: java.lang.Class,key: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.util.Map} map 
         * @param {java.lang.Object} key 
         */
        public static getOrCreate(map: java.util.Map,key: java.lang.Object): java.util.Map;
        /**
         * 
         * @param {char} ch 
         */
        private static hexToBin(ch: char): int;
        /**
         * 
         * @param {int} value 
         */
        public static dynamic(value: int): int;
        /**
         * 
         * @param {java.lang.Object} value 
         */
        public static dynamic(value: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.nio.file.Path} sourceFolderPath 
         * @param {java.nio.file.Path} zipPath 
         */
        public static zipFolder(sourceFolderPath: java.nio.file.Path,zipPath: java.nio.file.Path): void;
        /**
         * 
         * @param {java.lang.String} fileName 
         * @param {java.lang.String} content 
         */
        public static writeFile(fileName: java.lang.String,content: java.lang.String): void;
        /**
         * 
         * @param {java.io.File} file 
         * @param {java.io.InputStream} content 
         */
        public static writeFile(file: java.io.File,content: java.io.InputStream): void;
        /**
         * 
         * @param {java.lang.String} fileName 
         * @param {java.io.InputStream} content 
         */
        public static writeFile(fileName: java.lang.String,content: java.io.InputStream): void;
        /**
         * 
         * @param {java.io.File} file 
         * @param {java.lang.String} content 
         */
        public static writeFile(file: java.io.File,content: java.lang.String): void;
        /**
         * 
         * @param {byte[][]} params 
         */
        public static  dataToUUID(...params: byte[][]): java.util.UUID;
        /**
         * 
         * @param {java.lang.String[]} params 
         */
        public static  dataToUUID(...params: java.lang.String[]): java.util.UUID;
    }
}
declare namespace cn.nukkit.block{
     class BlockGlowstone extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.level.biome.impl.mesa{
     class MesaPlateauMBiome extends cn.nukkit.level.biome.impl.mesa.MesaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected minHill(): float;
        /**
         * 
         */
        protected getMoundFrequency(): float;
    }
}
declare namespace cn.nukkit.command.defaults{
    abstract class VanillaCommand extends cn.nukkit.command.Command{
    }
}
declare namespace cn.nukkit.block{
     class BlockCactus extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public getMinY(): double;
    }
}
declare namespace cn.nukkit.item{
     class ItemHelmetDiamond extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace java.io{
     class File extends java.lang.Object{
        /**  */
        filePath: java.nio.file.Path;
        /**  */
        pathSeparatorChar: char;
        /**  */
        $assertionsDisabled: boolean;
        /**  */
        PREFIX_LENGTH_OFFSET: long;
        /**  */
        fs: java.io.FileSystem;
        /**  */
        separator: java.lang.String;
        /**  */
        PATH_OFFSET: long;
        /**  */
        prefixLength: int;
        /**  */
        path: java.lang.String;
        /**  */
        serialVersionUID: long;
        /**  */
        pathSeparator: java.lang.String;
        /**  */
        separatorChar: char;
        /**  */
        UNSAFE: sun.misc.Unsafe;
        /**  */
        status: java.io.File.PathStatus;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getUsableSpace(): long;
        /**
         * 
         */
        public static listRoots(): java.io.File[];
        /**
         * 
         * @param {java.io.File} arg0 
         */
        public renameTo(arg0: java.io.File): boolean;
        /**
         * 
         */
        public canRead(): boolean;
        /**
         * 
         * @param {boolean} arg0 
         * @param {boolean} arg1 
         */
        public setExecutable(arg0: boolean,arg1: boolean): boolean;
        /**
         * 
         * @param {boolean} arg0 
         */
        public setExecutable(arg0: boolean): boolean;
        /**
         * 
         */
        public getCanonicalFile(): java.io.File;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  compareTo(arg0: java.lang.Object): int;
        /**
         * 
         * @param {java.io.File} arg0 
         */
        public compareTo(arg0: java.io.File): int;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {boolean} arg1 
         */
        private static slashify(arg0: java.lang.String,arg1: boolean): java.lang.String;
        /**
         * 
         */
        public delete(): boolean;
        /**
         * 
         * @param {boolean} arg0 
         * @param {boolean} arg1 
         */
        public setReadable(arg0: boolean,arg1: boolean): boolean;
        /**
         * 
         * @param {boolean} arg0 
         */
        public setReadable(arg0: boolean): boolean;
        /**
         * 
         */
        public getTotalSpace(): long;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         */
        public getParentFile(): java.io.File;
        /**
         * 
         */
        public getPath(): java.lang.String;
        /**
         * 
         */
        public getAbsoluteFile(): java.io.File;
        /**
         * 
         */
        public listFiles(): java.io.File[];
        /**
         * 
         * @param {java.io.FilenameFilter} arg0 
         */
        public listFiles(arg0: java.io.FilenameFilter): java.io.File[];
        /**
         * 
         * @param {java.io.FileFilter} arg0 
         */
        public listFiles(arg0: java.io.FileFilter): java.io.File[];
        /**
         * 
         */
        public mkdir(): boolean;
        /**
         * 
         */
        public deleteOnExit(): void;
        /**
         * 
         */
        public getCanonicalPath(): java.lang.String;
        /**
         * 
         */
        public getParent(): java.lang.String;
        /**
         * 
         */
        public canExecute(): boolean;
        /**
         * 
         */
        public toURL(): java.net.URL;
        /**
         * 
         * @param {boolean} arg0 
         * @param {boolean} arg1 
         */
        public setWritable(arg0: boolean,arg1: boolean): boolean;
        /**
         * 
         * @param {boolean} arg0 
         */
        public setWritable(arg0: boolean): boolean;
        /**
         * 
         */
        public isFile(): boolean;
        /**
         * 
         */
        public getAbsolutePath(): java.lang.String;
        /**
         * 
         * @param {java.io.ObjectOutputStream} arg0 
         */
        private  writeObject(arg0: java.io.ObjectOutputStream): void;
        /**
         * 
         */
        public toURI(): java.net.URI;
        /**
         * 
         */
        public length(): long;
        /**
         * 
         */
        public getFreeSpace(): long;
        /**
         * 
         */
        public canWrite(): boolean;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.String} arg1 
         * @param {java.io.File} arg2 
         */
        public static createTempFile(arg0: java.lang.String,arg1: java.lang.String,arg2: java.io.File): java.io.File;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.String} arg1 
         */
        public static createTempFile(arg0: java.lang.String,arg1: java.lang.String): java.io.File;
        /**
         * 
         */
        public list(): java.lang.String[];
        /**
         * 
         * @param {java.io.FilenameFilter} arg0 
         */
        public list(arg0: java.io.FilenameFilter): java.lang.String[];
        /**
         * 
         */
         isInvalid(): boolean;
        /**
         * 
         * @param {java.io.ObjectInputStream} arg0 
         */
        private  readObject(arg0: java.io.ObjectInputStream): void;
        /**
         * 
         */
        public isHidden(): boolean;
        /**
         * 
         */
         getPrefixLength(): int;
        /**
         * 
         */
        public toPath(): java.nio.file.Path;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public mkdirs(): boolean;
        /**
         * 
         */
        public isAbsolute(): boolean;
        /**
         * 
         */
        public exists(): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public lastModified(): long;
        /**
         * 
         */
        public createNewFile(): boolean;
        /**
         * 
         */
        public setReadOnly(): boolean;
        /**
         * 
         */
        public isDirectory(): boolean;
        /**
         * 
         * @param {long} arg0 
         */
        public setLastModified(arg0: long): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemShovelDiamond extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerActionPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        ACTION_ABORT_BREAK: int;
        /**  */
        ACTION_DIMENSION_CHANGE_REQUEST: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        ACTION_START_SPRINT: int;
        /**  */
        ACTION_GET_UPDATED_BLOCK: int;
        /**  */
        ACTION_START_SPIN_ATTACK: int;
        /**  */
        ACTION_DROP_ITEM: int;
        /**  */
        ACTION_START_SWIMMING: int;
        /**  */
        ACTION_CONTINUE_BREAK: int;
        /**  */
        ACTION_START_GLIDE: int;
        /**  */
        ACTION_INTERACT_BLOCK: int;
        /**  */
        action: int;
        /**  */
        ACTION_STOP_BREAK: int;
        /**  */
        ACTION_STOP_SLEEPING: int;
        /**  */
        ACTION_RESPAWN: int;
        /**  */
        ACTION_STOP_SNEAK: int;
        /**  */
        ACTION_STOP_SPIN_ATTACK: int;
        /**  */
        ACTION_STOP_GLIDE: int;
        /**  */
        ACTION_DIMENSION_CHANGE_ACK: int;
        /**  */
        ACTION_SET_ENCHANTMENT_SEED: int;
        /**  */
        entityId: long;
        /**  */
        ACTION_JUMP: int;
        /**  */
        ACTION_BUILD_DENIED: int;
        /**  */
        face: int;
        /**  */
        x: int;
        /**  */
        ACTION_START_SLEEPING: int;
        /**  */
        y: int;
        /**  */
        ACTION_START_SNEAK: int;
        /**  */
        z: int;
        /**  */
        ACTION_STOP_SPRINT: int;
        /**  */
        ACTION_STOP_SWIMMING: int;
        /**  */
        ACTION_START_BREAK: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace org.java_websocket{
    abstract class WebSocket extends java.lang.Object{
        /**
         * 
         */
        public abstract getAttachment(): java.lang.Object;
        /**
         * 
         */
        public abstract sendPing(): void;
        /**
         * 
         */
        public abstract getLocalSocketAddress(): java.net.InetSocketAddress;
        /**
         * 
         */
        public abstract getResourceDescriptor(): java.lang.String;
        /**
         * 
         */
        public abstract getProtocol(): org.java_websocket.protocols.IProtocol;
        /**
         * 
         */
        public abstract isFlushAndClose(): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         */
        public abstract closeConnection(arg0: int,arg1: java.lang.String): void;
        /**
         * 
         */
        public abstract getSSLSession(): javax.net.ssl.SSLSession;
        /**
         * 
         */
        public abstract isOpen(): boolean;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract sendFrame(arg0: java.util.Collection): void;
        /**
         * 
         * @param {org.java_websocket.framing.Framedata} arg0 
         */
        public abstract sendFrame(arg0: org.java_websocket.framing.Framedata): void;
        /**
         * 
         * @param {org.java_websocket.enums.Opcode} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         * @param {boolean} arg2 
         */
        public abstract sendFragmentedFrame(arg0: org.java_websocket.enums.Opcode,arg1: java.nio.ByteBuffer,arg2: boolean): void;
        /**
         * 
         */
        public abstract isClosed(): boolean;
        /**
         * 
         */
        public abstract hasSSLSupport(): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract setAttachment(arg0: java.lang.Object): void;
        /**
         * 
         */
        public abstract hasBufferedData(): boolean;
        /**
         * 
         */
        public abstract isClosing(): boolean;
        /**
         * 
         */
        public abstract getReadyState(): org.java_websocket.enums.ReadyState;
        /**
         * 
         */
        public abstract close(): void;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract close(arg0: int): void;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         */
        public abstract close(arg0: int,arg1: java.lang.String): void;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public abstract send(arg0: byte[]): void;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        public abstract send(arg0: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public abstract send(arg0: java.lang.String): void;
        /**
         * 
         */
        public abstract getRemoteSocketAddress(): java.net.InetSocketAddress;
        /**
         * 
         */
        public abstract getDraft(): org.java_websocket.drafts.Draft;
    }
}
declare namespace cn.nukkit.block{
     class BlockDaylightDetector extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public updatePower(): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getWeakPower(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isInverted(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockTerracottaGlazed extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ServerSettingsRequestPacket extends cn.nukkit.network.protocol.DataPacket{
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.form.window{
     class FormWindowCustom extends cn.nukkit.form.window.FormWindow{
        /**  */
        response: cn.nukkit.form.response.FormResponseCustom;
        /**  */
        icon: cn.nukkit.form.element.ElementButtonImageData;
        /**  */
        type: java.lang.String;
        /**  */
        title: java.lang.String;
        /**  */
        content: java.util.List;
        /**
         * 
         * @param {cn.nukkit.form.element.ElementButtonImageData} icon 
         */
        public setIcon(icon: cn.nukkit.form.element.ElementButtonImageData): void;
        /**
         * 
         * @param {java.lang.String} icon 
         */
        public setIcon(icon: java.lang.String): void;
        /**
         * 
         */
        public getTitle(): java.lang.String;
        /**
         * 
         * @param {java.lang.Integer} i 
         * @param {java.lang.Object} response 
         */
        private lambda$setElementsFromResponse$0(i: java.lang.Integer,response: java.lang.Object): void;
        /**
         * 
         */
        public setElementsFromResponse(): void;
        /**
         * 
         */
        public  getResponse(): cn.nukkit.form.response.FormResponse;
        /**
         * 
         */
        public getResponse(): cn.nukkit.form.response.FormResponseCustom;
        /**
         * 
         */
        public getElements(): java.util.List;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public setTitle(title: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} data 
         */
        public setResponse(data: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.form.element.Element} element 
         */
        public addElement(element: cn.nukkit.form.element.Element): void;
        /**
         * 
         */
        public getIcon(): cn.nukkit.form.element.ElementButtonImageData;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class BNClosedEvent extends cn.nukkit.event.Event{
    }
}
declare namespace cn.nukkit.event.player{
    abstract class PlayerBucketEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        blockFace: cn.nukkit.math.BlockFace;
        /**  */
        bucket: cn.nukkit.item.Item;
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        liquid: cn.nukkit.block.Block;
        /**  */
        blockClicked: cn.nukkit.block.Block;
        /**
         * 
         */
        public getBucket(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getBlockClicked(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerChatEvent extends cn.nukkit.event.player.PlayerMessageEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        recipients: java.util.Set;
        /**  */
        format: java.lang.String;
        /**
         * 
         * @param {java.lang.String} format 
         */
        public setFormat(format: java.lang.String): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public setPlayer(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getFormat(): java.lang.String;
        /**
         * 
         * @param {java.util.Set} recipients 
         */
        public setRecipients(recipients: java.util.Set): void;
        /**
         * 
         */
        public getRecipients(): java.util.Set;
    }
}
declare namespace cn.nukkit.item{
     class ItemChestplateGold extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryTransactionEvent extends cn.nukkit.event.Event{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        transaction: cn.nukkit.inventory.transaction.InventoryTransaction;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getTransaction(): cn.nukkit.inventory.transaction.InventoryTransaction;
    }
}
declare namespace cn.nukkit.utils{
    abstract class Zlib extends java.lang.Object{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        provider: cn.nukkit.utils.ZlibProvider;
        /**  */
        providers: cn.nukkit.utils.ZlibProvider[];
        /**
         * 
         * @param {byte[][]} data 
         * @param {int} level 
         */
        public static deflate(data: byte[][],level: int): byte[];
        /**
         * 
         * @param {byte[]} data 
         */
        public static deflate(data: byte[]): byte[];
        /**
         * 
         * @param {byte[]} data 
         * @param {int} level 
         */
        public static deflate(data: byte[],level: int): byte[];
        /**
         * 
         * @param {byte[]} data 
         * @param {int} maxSize 
         */
        public static inflate(data: byte[],maxSize: int): byte[];
        /**
         * 
         * @param {byte[]} data 
         */
        public static inflate(data: byte[]): byte[];
        /**
         * 
         * @param {int} providerIndex 
         */
        public static setProvider(providerIndex: int): void;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerBedLeaveEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        bed: cn.nukkit.block.Block;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getBed(): cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.block{
     class BlockEndPortalFrame extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        END_PORTAL_EYE: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        FACES: int[];
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public createPortal(): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {java.util.List} visited 
         */
        private searchCenter(visited: java.util.List): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        private checkFrame(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {int} x 
         * @param {int} z 
         */
        private checkFrame(block: cn.nukkit.block.Block,x: int,z: int): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ResourcePacksInfoPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        scripting: boolean;
        /**  */
        mustAccept: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        behaviourPackEntries: cn.nukkit.resourcepacks.ResourcePack[];
        /**  */
        forcingServerPacksEnabled: boolean;
        /**  */
        resourcePackEntries: cn.nukkit.resourcepacks.ResourcePack[];
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         * @param {cn.nukkit.resourcepacks.ResourcePack[]} packs 
         */
        private encodePacks(packs: cn.nukkit.resourcepacks.ResourcePack[]): void;
        /**
         * 
         */
        public getResourcePackEntries(): cn.nukkit.resourcepacks.ResourcePack[];
        /**
         * 
         */
        public getBehaviourPackEntries(): cn.nukkit.resourcepacks.ResourcePack[];
        /**
         * 
         */
        public isForcingServerPacksEnabled(): boolean;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         * @param {boolean} forcingServerPacksEnabled 
         */
        public setForcingServerPacksEnabled(forcingServerPacksEnabled: boolean): void;
        /**
         * 
         * @param {boolean} scripting 
         */
        public setScriptingEnabled(scripting: boolean): void;
        /**
         * 
         * @param {cn.nukkit.resourcepacks.ResourcePack[]} behaviourPackEntries 
         */
        public setBehaviourPackEntries(behaviourPackEntries: cn.nukkit.resourcepacks.ResourcePack[]): void;
        /**
         * 
         */
        public isScriptingEnabled(): boolean;
        /**
         * 
         */
        public isForcedToAccept(): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.resourcepacks.ResourcePack[]} resourcePackEntries 
         */
        public setResourcePackEntries(resourcePackEntries: cn.nukkit.resourcepacks.ResourcePack[]): void;
        /**
         * 
         * @param {boolean} mustAccept 
         */
        public setForcedToAccept(mustAccept: boolean): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemItemFrame extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.blockentity{
    abstract class BlockEntity extends cn.nukkit.level.Position{
        /**  */
        TARGET: java.lang.String;
        /**  */
        server: cn.nukkit.Server;
        /**  */
        BLAST_FURNACE: java.lang.String;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        COMPARATOR: java.lang.String;
        /**  */
        SKULL: java.lang.String;
        /**  */
        chunk: cn.nukkit.level.format.FullChunk;
        /**  */
        BEACON: java.lang.String;
        /**  */
        FURNACE: java.lang.String;
        /**  */
        ITEM_FRAME: java.lang.String;
        /**  */
        BEEHIVE: java.lang.String;
        /**  */
        knownBlockEntities: com.google.common.collect.BiMap;
        /**  */
        ENDER_CHEST: java.lang.String;
        /**  */
        namedTag: cn.nukkit.nbt.tag.CompoundTag;
        /**  */
        SIGN: java.lang.String;
        /**  */
        id: long;
        /**  */
        CAULDRON: java.lang.String;
        /**  */
        BELL: java.lang.String;
        /**  */
        FLOWER_POT: java.lang.String;
        /**  */
        BREWING_STAND: java.lang.String;
        /**  */
        BED: java.lang.String;
        /**  */
        MUSIC: java.lang.String;
        /**  */
        NETHER_REACTOR: java.lang.String;
        /**  */
        MOB_SPAWNER: java.lang.String;
        /**  */
        CONDUIT: java.lang.String;
        /**  */
        CAMPFIRE: java.lang.String;
        /**  */
        timing: co.aikar.timings.Timing;
        /**  */
        SMOKER: java.lang.String;
        /**  */
        DISPENSER: java.lang.String;
        /**  */
        count: long;
        /**  */
        LODESTONE: java.lang.String;
        /**  */
        HOPPER: java.lang.String;
        /**  */
        CHEST: java.lang.String;
        /**  */
        DAYLIGHT_DETECTOR: java.lang.String;
        /**  */
        movable: boolean;
        /**  */
        BANNER: java.lang.String;
        /**  */
        MOVING_BLOCK: java.lang.String;
        /**  */
        lastUpdate: long;
        /**  */
        LECTERN: java.lang.String;
        /**  */
        name: java.lang.String;
        /**  */
        SHULKER_BOX: java.lang.String;
        /**  */
        closed: boolean;
        /**  */
        PISTON_ARM: java.lang.String;
        /**  */
        JUKEBOX: java.lang.String;
        /**  */
        BARREL: java.lang.String;
        /**  */
        ENCHANT_TABLE: java.lang.String;
        /**  */
        DROPPER: java.lang.String;
        /**
         * 
         */
        public onBreak(): void;
        /**
         * 
         * @param {boolean} isSilkTouch 
         */
        public onBreak(isSilkTouch: boolean): void;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getCleanedNBT(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public  scheduleUpdate(): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public  getLevelBlockEntity(): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public getId(): long;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.Class} c 
         */
        public static registerBlockEntity(name: java.lang.String,c: java.lang.Class): boolean;
        /**
         * 
         */
        public isMovable(): boolean;
        /**
         * 
         */
        public isObservable(): boolean;
        /**
         * 
         */
        public  getSaveId(): java.lang.String;
        /**
         * 
         */
        public setDirty(): void;
        /**
         * 
         * @param {java.lang.String} type 
         * @param {cn.nukkit.level.Position} position 
         * @param {java.lang.Object[]} args 
         */
        public static  createBlockEntity(type: java.lang.String,position: cn.nukkit.level.Position,...args: java.lang.Object[]): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         * @param {java.lang.String} type 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {java.lang.Object[]} args 
         */
        public static  createBlockEntity(type: java.lang.String,chunk: cn.nukkit.level.format.FullChunk,nbt: cn.nukkit.nbt.tag.CompoundTag,...args: java.lang.Object[]): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         * @param {java.lang.String} type 
         * @param {cn.nukkit.level.Position} pos 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {java.lang.Object[]} args 
         */
        public static  createBlockEntity(type: java.lang.String,pos: cn.nukkit.level.Position,nbt: cn.nukkit.nbt.tag.CompoundTag,...args: java.lang.Object[]): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {java.lang.String} id 
         */
        public static getDefaultCompound(pos: cn.nukkit.math.Vector3,id: java.lang.String): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public abstract isBlockEntityValid(): boolean;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public onUpdate(): boolean;
    }
}
declare namespace cn.nukkit.level.format.anvil{
     class Anvil extends cn.nukkit.level.format.generic.BaseLevelProvider{
        /**  */
        PAD_256: byte[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        VERSION: int;
        /**  */
        lastPosition: int;
        /**
         * 
         * @param {int} y 
         */
        public static createChunkSection(y: int): cn.nukkit.level.format.anvil.ChunkSection;
        /**
         * 
         */
        public static getProviderOrder(): byte;
        /**
         * 
         * @param {long} index 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {boolean} create 
         */
        public  loadChunk(index: long,chunkX: int,chunkZ: int,create: boolean): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {long} time 
         */
        public doGarbageCollection(time: long): void;
        /**
         * 
         * @param {java.lang.String} path 
         */
        public static isValid(path: java.lang.String): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public requestChunkTask(x: int,z: int): cn.nukkit.scheduler.AsyncTask;
        /**
         * 
         */
        public static getProviderName(): java.lang.String;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        protected  loadRegion(x: int,z: int): cn.nukkit.level.format.generic.BaseRegionLoader;
        /**
         * 
         */
        public getMaximumLayer(): int;
        /**
         * 
         */
        public static usesChunkSection(): boolean;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public  getEmptyChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getEmptyChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.anvil.Chunk;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public  saveChunk(x: int,z: int,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public  saveChunk(X: int,Z: int): void;
        /**
         * 
         * @param {java.lang.String} path 
         * @param {java.lang.String} name 
         * @param {long} seed 
         * @param {java.lang.Class} generator 
         */
        public static generate(path: java.lang.String,name: java.lang.String,seed: long,generator: java.lang.Class): void;
        /**
         * 
         * @param {java.lang.String} path 
         * @param {java.lang.String} name 
         * @param {long} seed 
         * @param {java.lang.Class} generator 
         * @param {java.util.Map} options 
         */
        public static generate(path: java.lang.String,name: java.lang.String,seed: long,generator: java.lang.Class,options: java.util.Map): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} levelData 
         * @param {java.io.File} file 
         */
        private static lambda$generate$1(levelData: cn.nukkit.nbt.tag.CompoundTag,file: java.io.File): void;
        /**
         * 
         * @param {java.io.File} dir 
         * @param {java.lang.String} name 
         */
        private static lambda$isValid$0(dir: java.io.File,name: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockEndPortal extends cn.nukkit.block.BlockFlowable{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.inventory{
     class CraftingGrid extends cn.nukkit.inventory.PlayerUIComponent{
    }
}
declare namespace java.nio{
    abstract class ByteBuffer extends java.nio.Buffer{
        /**  */
        bigEndian: boolean;
        /**  */
        nativeByteOrder: boolean;
        /**  */
        isReadOnly: boolean;
        /**  */
        offset: int;
        /**  */
        hb: byte[];
        /**
         * 
         */
        public abstract asIntBuffer(): java.nio.IntBuffer;
        /**
         * 
         * @param {byte} arg0 
         * @param {byte} arg1 
         */
        private static compare(arg0: byte,arg1: byte): int;
        /**
         * 
         */
        public abstract compact(): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract asLongBuffer(): java.nio.LongBuffer;
        /**
         * 
         */
        public abstract getDouble(): double;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getDouble(arg0: int): double;
        /**
         * 
         * @param {double} arg0 
         */
        public abstract putDouble(arg0: double): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         * @param {double} arg1 
         */
        public abstract putDouble(arg0: int,arg1: double): java.nio.ByteBuffer;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  compareTo(arg0: java.lang.Object): int;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        public compareTo(arg0: java.nio.ByteBuffer): int;
        /**
         * 
         */
        public abstract getFloat(): float;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getFloat(arg0: int): float;
        /**
         * 
         * @param {int} arg0 
         * @param {long} arg1 
         */
        public abstract putLong(arg0: int,arg1: long): java.nio.ByteBuffer;
        /**
         * 
         * @param {long} arg0 
         */
        public abstract putLong(arg0: long): java.nio.ByteBuffer;
        /**
         * 
         * @param {byte[]} arg0 
         * @param {int} arg1 
         * @param {int} arg2 
         */
        public put(arg0: byte[],arg1: int,arg2: int): java.nio.ByteBuffer;
        /**
         * 
         * @param {byte} arg0 
         */
        public abstract put(arg0: byte): java.nio.ByteBuffer;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        public put(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         * @param {byte} arg1 
         */
        public abstract put(arg0: int,arg1: byte): java.nio.ByteBuffer;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public  put(arg0: byte[]): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract asReadOnlyBuffer(): java.nio.ByteBuffer;
        /**
         * 
         */
        public  array(): byte[];
        /**
         * 
         */
        public  array(): java.lang.Object;
        /**
         * 
         */
        public abstract asDoubleBuffer(): java.nio.DoubleBuffer;
        /**
         * 
         */
        public abstract slice(): java.nio.ByteBuffer;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract get(arg0: int): byte;
        /**
         * 
         * @param {byte[]} arg0 
         * @param {int} arg1 
         * @param {int} arg2 
         */
        public get(arg0: byte[],arg1: int,arg2: int): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract get(): byte;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public get(arg0: byte[]): java.nio.ByteBuffer;
        /**
         * 
         */
        public  arrayOffset(): int;
        /**
         * 
         * @param {short} arg0 
         */
        public abstract putShort(arg0: short): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         * @param {short} arg1 
         */
        public abstract putShort(arg0: int,arg1: short): java.nio.ByteBuffer;
        /**
         * 
         * @param {java.nio.ByteOrder} arg0 
         */
        public  order(arg0: java.nio.ByteOrder): java.nio.ByteBuffer;
        /**
         * 
         */
        public  order(): java.nio.ByteOrder;
        /**
         * 
         */
        public  hasArray(): boolean;
        /**
         * 
         * @param {int} arg0 
         */
        public static allocateDirect(arg0: int): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract asCharBuffer(): java.nio.CharBuffer;
        /**
         * 
         */
        public abstract asFloatBuffer(): java.nio.FloatBuffer;
        /**
         * 
         */
        public abstract getShort(): short;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getShort(arg0: int): short;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public abstract putInt(arg0: int,arg1: int): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract putInt(arg0: int): java.nio.ByteBuffer;
        /**
         * 
         * @param {char} arg0 
         */
        public abstract putChar(arg0: char): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         * @param {char} arg1 
         */
        public abstract putChar(arg0: int,arg1: char): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract duplicate(): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract getLong(): long;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getLong(arg0: int): long;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getChar(arg0: int): char;
        /**
         * 
         */
        public abstract getChar(): char;
        /**
         * 
         * @param {int} arg0 
         */
        public abstract getInt(arg0: int): int;
        /**
         * 
         */
        public abstract getInt(): int;
        /**
         * 
         * @param {float} arg0 
         */
        public abstract putFloat(arg0: float): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         * @param {float} arg1 
         */
        public abstract putFloat(arg0: int,arg1: float): java.nio.ByteBuffer;
        /**
         * 
         * @param {int} arg0 
         */
        public static allocate(arg0: int): java.nio.ByteBuffer;
        /**
         * 
         * @param {byte} arg0 
         * @param {byte} arg1 
         */
        private static equals(arg0: byte,arg1: byte): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {int} arg0 
         */
        abstract _get(arg0: int): byte;
        /**
         * 
         * @param {int} arg0 
         * @param {byte} arg1 
         */
        abstract _put(arg0: int,arg1: byte): void;
        /**
         * 
         */
        public abstract isDirect(): boolean;
        /**
         * 
         * @param {byte[]} arg0 
         * @param {int} arg1 
         * @param {int} arg2 
         */
        public static wrap(arg0: byte[],arg1: int,arg2: int): java.nio.ByteBuffer;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public static wrap(arg0: byte[]): java.nio.ByteBuffer;
        /**
         * 
         */
        public abstract asShortBuffer(): java.nio.ShortBuffer;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AddPaintingPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        entityRuntimeId: long;
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: float;
        /**  */
        entityUniqueId: long;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        title: java.lang.String;
        /**  */
        direction: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockSlabRedSandstone extends cn.nukkit.block.BlockSlab{
        /**  */
        MOSSY_COBBLESTONE: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        DARK_PRISMARINE: int;
        /**  */
        PURPUR: int;
        /**  */
        PRISMARINE: int;
        /**  */
        RED_SANDSTONE: int;
        /**  */
        PRISMARINE_BRICKS: int;
        /**  */
        SMOOTH_SANDSTONE: int;
        /**  */
        RED_NETHER_BRICK: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.block.BlockSlab} slab 
         */
        public isSameType(slab: cn.nukkit.block.BlockSlab): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getSlabName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.StoneSlab2Type} type 
         */
        public setSlabType(type: cn.nukkit.blockproperty.value.StoneSlab2Type): void;
        /**
         * 
         */
        public getSlabType(): cn.nukkit.blockproperty.value.StoneSlab2Type;
    }
}
declare namespace cn.nukkit.item{
     class ItemCarrotOnAStick extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class CreativeContentPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        entries: cn.nukkit.item.Item[];
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorGroundCover extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        STONE: int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class DifficultyCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityZoglin extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public isBaby(): boolean;
        /**
         * 
         * @param {boolean} baby 
         */
        public setBaby(baby: boolean): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemAppleGoldEnchanted extends cn.nukkit.item.ItemEdible{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.level.biome{
     class BiomeSelector extends java.lang.Object{
        /**  */
        rainfall: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        ocean: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        temperature: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        hills: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        river: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public pickBiome(x: int,z: int): cn.nukkit.level.biome.Biome;
    }
}
declare namespace cn.nukkit.form.window{
     class FormWindowSimple extends cn.nukkit.form.window.FormWindow{
        /**  */
        buttons: java.util.List;
        /**  */
        response: cn.nukkit.form.response.FormResponseSimple;
        /**  */
        type: java.lang.String;
        /**  */
        title: java.lang.String;
        /**  */
        content: java.lang.String;
        /**
         * 
         * @param {java.lang.String} content 
         */
        public setContent(content: java.lang.String): void;
        /**
         * 
         */
        public getTitle(): java.lang.String;
        /**
         * 
         */
        public getButtons(): java.util.List;
        /**
         * 
         */
        public  getResponse(): cn.nukkit.form.response.FormResponse;
        /**
         * 
         */
        public getResponse(): cn.nukkit.form.response.FormResponseSimple;
        /**
         * 
         */
        public getContent(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} title 
         */
        public setTitle(title: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} data 
         */
        public setResponse(data: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.form.element.ElementButton} button 
         */
        public addButton(button: cn.nukkit.form.element.ElementButton): void;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerTeleportEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        cause: cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause;
        /**  */
        from: cn.nukkit.level.Location;
        /**  */
        to: cn.nukkit.level.Location;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getTo(): cn.nukkit.level.Location;
        /**
         * 
         */
        public getCause(): cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause;
        /**
         * 
         * @param {cn.nukkit.level.Level} baseLevel 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        private vectorToLocation(baseLevel: cn.nukkit.level.Level,vector: cn.nukkit.math.Vector3): cn.nukkit.level.Location;
        /**
         * 
         */
        public getFrom(): cn.nukkit.level.Location;
    }
}
declare namespace cn.nukkit.network.protocol{
     class InventoryContentPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        SPECIAL_OFFHAND: int;
        /**  */
        SPECIAL_HOTBAR: int;
        /**  */
        slots: cn.nukkit.item.Item[];
        /**  */
        SPECIAL_CREATIVE: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        SPECIAL_ARMOR: int;
        /**  */
        inventoryId: int;
        /**  */
        SPECIAL_INVENTORY: int;
        /**  */
        SPECIAL_FIXED_INVENTORY: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public  clone(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public clone(): cn.nukkit.network.protocol.InventoryContentPacket;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         */
        public clean(): cn.nukkit.network.protocol.DataPacket;
    }
}
declare namespace cn.nukkit.item{
     class ItemBlazePowder extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.inventory{
     class BrewingRecipe extends cn.nukkit.inventory.MixRecipe{
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.RecipeType;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingManager} manager 
         */
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void;
    }
}
declare namespace cn.nukkit.utils{
     class DyeColor extends java.lang.Enum{
        /**  */
        dyeColorMeta: int;
        /**  */
        colorName: java.lang.String;
        /**  */
        GRAY: cn.nukkit.utils.DyeColor;
        /**  */
        leatherColor: cn.nukkit.utils.BlockColor;
        /**  */
        BLUE: cn.nukkit.utils.DyeColor;
        /**  */
        woolColorMeta: int;
        /**  */
        dyeName: java.lang.String;
        /**  */
        itemDyeMeta: int;
        /**  */
        PINK: cn.nukkit.utils.DyeColor;
        /**  */
        BLACK: cn.nukkit.utils.DyeColor;
        /**  */
        BROWN: cn.nukkit.utils.DyeColor;
        /**  */
        $VALUES: cn.nukkit.utils.DyeColor[];
        /**  */
        ORANGE: cn.nukkit.utils.DyeColor;
        /**  */
        WHITE: cn.nukkit.utils.DyeColor;
        /**  */
        BY_WOOL_DATA: cn.nukkit.utils.DyeColor[];
        /**  */
        PURPLE: cn.nukkit.utils.DyeColor;
        /**  */
        GREEN: cn.nukkit.utils.DyeColor;
        /**  */
        RED: cn.nukkit.utils.DyeColor;
        /**  */
        LIGHT_GRAY: cn.nukkit.utils.DyeColor;
        /**  */
        blockColor: cn.nukkit.utils.BlockColor;
        /**  */
        LIGHT_BLUE: cn.nukkit.utils.DyeColor;
        /**  */
        LIME: cn.nukkit.utils.DyeColor;
        /**  */
        BY_DYE_DATA: cn.nukkit.utils.DyeColor[];
        /**  */
        MAGENTA: cn.nukkit.utils.DyeColor;
        /**  */
        YELLOW: cn.nukkit.utils.DyeColor;
        /**  */
        CYAN: cn.nukkit.utils.DyeColor;
        /**
         * 
         * @param {int} woolColorMeta 
         */
        public static getByWoolData(woolColorMeta: int): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getLeatherColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getDyeData(): int;
        /**
         * 
         * @param {int} dyeColorMeta 
         */
        public static getByDyeData(dyeColorMeta: int): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getWoolData(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public static values(): cn.nukkit.utils.DyeColor[];
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getItemDyeMeta(): int;
        /**
         * 
         */
        public getDyeName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetLocalPlayerAsInitializedPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.utils{
     class BlockColor extends java.lang.Object{
        /**  */
        LIME_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        WHITE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LIGHT_GRAY_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        MAGENTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        FOLIAGE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CYAN_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        SPRUCE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        REDSTONE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        SNOW_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        PURPLE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        GREEN_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CRIMSON_NYLIUM_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        WATER_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        red: int;
        /**  */
        ICE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        QUARTZ_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CLOTH_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        PINK_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        BLACK_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        WARPED_NYLIUM_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LIME_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        WARPED_STEM_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        VOID_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        TRANSPARENT_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        IRON_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        ORANGE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        GRAY_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        YELLOW_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CRIMSON_HYPHAE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        MAGENTA_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        WHITE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        SAND_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        ORANGE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        ADOBE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CLAY_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        DIRT_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        OBSIDIAN_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CYAN_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        BLACK_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        GRAY_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        AIR_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        RED_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LIGHT_BLUE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        YELLOW_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        alpha: int;
        /**  */
        NETHERRACK_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        GRASS_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        BLUE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        GREEN_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        STONE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        RED_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        WARPED_WART_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        GOLD_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        green: int;
        /**  */
        WARPED_HYPHAE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LIGHT_BLUE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        PINK_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        BROWN_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        BROWN_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        CRIMSON_STEM_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        DIAMOND_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LAPIS_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        blue: int;
        /**  */
        WOOD_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        BLUE_TERRACOTA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        EMERALD_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LIGHT_GRAY_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        PURPLE_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        TNT_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**  */
        LAVA_BLOCK_COLOR: cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getGreen(): int;
        /**
         * 
         */
        public getRed(): int;
        /**
         * 
         * @param {int} dyeColorMeta 
         */
        public static getDyeColor(dyeColorMeta: int): cn.nukkit.utils.BlockColor;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getBlue(): int;
        /**
         * 
         */
        public getRGB(): int;
        /**
         * 
         */
        public getAlpha(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class BlockForceFieldParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.level.generator{
     class Nether extends cn.nukkit.level.generator.Generator{
        /**  */
        localSeed1: long;
        /**  */
        random: java.util.Random;
        /**  */
        generationPopulators: java.util.List;
        /**  */
        noiseGen: cn.nukkit.level.generator.noise.nukkit.f.SimplexF[];
        /**  */
        localSeed2: long;
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        populators: java.util.List;
        /**  */
        nukkitRandom: cn.nukkit.math.NukkitRandom;
        /**  */
        bedrockDepth: double;
        /**  */
        lavaHeight: double;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        public init(level: cn.nukkit.level.ChunkManager,random: cn.nukkit.math.NukkitRandom): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getChunkManager(): cn.nukkit.level.ChunkManager;
        /**
         * 
         */
        public getSpawn(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getSettings(): java.util.Map;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public populateChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         */
        public getDimension(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getNoise(x: int,y: int,z: int): float;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public generateChunk(chunkX: int,chunkZ: int): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemMelon extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.item{
     class ItemBeefRaw extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.inventory{
     class CraftingManager extends java.lang.Object{
        /**  */
        shapedRecipes: java.util.Map;
        /**  */
        recipes: java.util.Collection;
        /**  */
        containerRecipes: java.util.Map;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        brewingRecipes: java.util.Map;
        /**  */
        smithingRecipes: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
        /**  */
        packet: cn.nukkit.network.protocol.DataPacket;
        /**  */
        cartographyRecipes: java.util.Map;
        /**  */
        stonecutterRecipes: java.util.Map;
        /**  */
        recipeComparator: java.util.Comparator;
        /**  */
        furnaceRecipes: java.util.Map;
        /**  */
        multiRecipes: java.util.Map;
        /**  */
        shapelessRecipes: java.util.Map;
        /**  */
        RECIPE_COUNT: int;
        /**  */
        blastFurnaceRecipes: java.util.Map;
        /**  */
        smokerRecipes: java.util.Map;
        /**  */
        campfireRecipes: java.util.Map;
        /**
         * 
         * @param {cn.nukkit.inventory.BlastFurnaceRecipe} recipe 
         */
        public registerBlastFurnaceRecipe(recipe: cn.nukkit.inventory.BlastFurnaceRecipe): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} input 
         */
        public matchSmokerRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.SmokerRecipe;
        /**
         * 
         * @param {java.util.Map} map 
         */
        private static lambda$null$8(map: java.util.Map): java.util.stream.Stream;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {cn.nukkit.inventory.SmithingRecipe} recipe 
         */
        private static lambda$null$9(inputList: java.util.List,recipe: cn.nukkit.inventory.SmithingRecipe): boolean;
        /**
         * 
         * @param {java.lang.Integer} k 
         */
        private static lambda$registerShapelessRecipe$4(k: java.lang.Integer): java.util.Map;
        /**
         * 
         */
        public static getCraftingPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {cn.nukkit.item.Item} primaryOutput 
         * @param {java.util.List} extraOutputList 
         */
        public matchCartographyRecipe(inputList: java.util.List,primaryOutput: cn.nukkit.item.Item,extraOutputList: java.util.List): cn.nukkit.inventory.CartographyRecipe;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {cn.nukkit.item.Item} primaryOutput 
         * @param {java.util.List} extraOutputList 
         */
        public matchRecipe(inputList: java.util.List,primaryOutput: cn.nukkit.item.Item,extraOutputList: java.util.List): cn.nukkit.inventory.CraftingRecipe;
        /**
         * 
         * @param {cn.nukkit.inventory.CampfireRecipe} recipe 
         */
        public registerCampfireRecipe(recipe: cn.nukkit.inventory.CampfireRecipe): void;
        /**
         * 
         * @param {cn.nukkit.inventory.SmithingRecipe} recipe 
         * @param {java.util.List} inputList 
         * @param {cn.nukkit.item.Item} primaryOutput 
         */
        private matchItemsAccumulation(recipe: cn.nukkit.inventory.SmithingRecipe,inputList: java.util.List,primaryOutput: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingRecipe} recipe 
         * @param {java.util.List} inputList 
         * @param {cn.nukkit.item.Item} primaryOutput 
         * @param {java.util.List} extraOutputList 
         */
        private matchItemsAccumulation(recipe: cn.nukkit.inventory.CraftingRecipe,inputList: java.util.List,primaryOutput: cn.nukkit.item.Item,extraOutputList: java.util.List): boolean;
        /**
         * 
         * @param {java.lang.Integer} k 
         */
        private static lambda$registerShapedRecipe$2(k: java.lang.Integer): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.item.Item} output 
         */
        public matchStonecutterRecipe(output: cn.nukkit.item.Item): cn.nukkit.inventory.StonecutterRecipe;
        /**
         * 
         * @param {cn.nukkit.inventory.Recipe} recipe 
         */
        public registerRecipe(recipe: cn.nukkit.inventory.Recipe): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} ingot 
         * @param {it.unimi.dsi.fastutil.ints.Int2IntMap.Entry} e 
         */
        private lambda$registerSmithingRecipes$1(ingot: cn.nukkit.item.Item,e: it.unimi.dsi.fastutil.ints.Int2IntMap.Entry): void;
        /**
         * 
         * @param {java.util.Map} data 
         */
        private parseRecipeItem(data: java.util.Map): cn.nukkit.item.Item;
        /**
         * 
         */
        public rebuildPacket(): void;
        /**
         * 
         * @param {java.util.Collection} items 
         */
        private static getMultiItemHash(items: java.util.Collection): java.util.UUID;
        /**
         * 
         * @param {cn.nukkit.inventory.MultiRecipe} recipe 
         */
        public registerMultiRecipe(recipe: cn.nukkit.inventory.MultiRecipe): void;
        /**
         * 
         * @param {java.lang.Integer} k 
         */
        private static lambda$registerCartographyRecipe$3(k: java.lang.Integer): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.inventory.BrewingRecipe} recipe 
         */
        public registerBrewingRecipe(recipe: cn.nukkit.inventory.BrewingRecipe): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} input 
         */
        public matchCampfireRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.CampfireRecipe;
        /**
         * 
         * @param {int} k 
         */
        private static lambda$registerSmithingRecipe$5(k: int): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.inventory.FurnaceRecipe} recipe 
         */
        public registerFurnaceRecipe(recipe: cn.nukkit.inventory.FurnaceRecipe): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} input 
         * @param {cn.nukkit.item.Item} potion 
         */
        public matchBrewingRecipe(input: cn.nukkit.item.Item,potion: cn.nukkit.item.Item): cn.nukkit.inventory.BrewingRecipe;
        /**
         * 
         * @param {cn.nukkit.item.Item} ingredient 
         * @param {cn.nukkit.item.Item} potion 
         */
        private static getPotionHash(ingredient: cn.nukkit.item.Item,potion: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {cn.nukkit.utils.Config} config 
         */
        private loadRecipes(config: cn.nukkit.utils.Config): void;
        /**
         * 
         * @param {int} ingredientId 
         * @param {int} containerId 
         */
        private static getContainerHash(ingredientId: int,containerId: int): int;
        /**
         * 
         * @param {java.util.List} inputList 
         */
        public matchSmithingRecipe(inputList: java.util.List): cn.nukkit.inventory.SmithingRecipe;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {cn.nukkit.item.Item} primaryOutput 
         */
        public matchSmithingRecipe(inputList: java.util.List,primaryOutput: cn.nukkit.item.Item): cn.nukkit.inventory.SmithingRecipe;
        /**
         * 
         * @param {cn.nukkit.item.Item} equipment 
         * @param {cn.nukkit.item.Item} ingredient 
         */
        public matchSmithingRecipe(equipment: cn.nukkit.item.Item,ingredient: cn.nukkit.item.Item): cn.nukkit.inventory.SmithingRecipe;
        /**
         * 
         * @param {cn.nukkit.item.Item} equipment 
         * @param {cn.nukkit.item.Item} ingredient 
         * @param {cn.nukkit.item.Item} primaryOutput 
         */
        public matchSmithingRecipe(equipment: cn.nukkit.item.Item,ingredient: cn.nukkit.item.Item,primaryOutput: cn.nukkit.item.Item): cn.nukkit.inventory.SmithingRecipe;
        /**
         * 
         * @param {cn.nukkit.inventory.StonecutterRecipe} recipe 
         */
        public registerStonecutterRecipe(recipe: cn.nukkit.inventory.StonecutterRecipe): void;
        /**
         * 
         * @param {cn.nukkit.inventory.ContainerRecipe} recipe 
         */
        public registerContainerRecipe(recipe: cn.nukkit.inventory.ContainerRecipe): void;
        /**
         * 
         * @param {cn.nukkit.inventory.CartographyRecipe} recipe 
         */
        public registerCartographyRecipe(recipe: cn.nukkit.inventory.CartographyRecipe): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        private static getItemHash(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {int} id 
         * @param {int} meta 
         */
        private static getItemHash(id: int,meta: int): int;
        /**
         * 
         * @param {cn.nukkit.inventory.SmokerRecipe} recipe 
         */
        public registerSmokerRecipe(recipe: cn.nukkit.inventory.SmokerRecipe): void;
        /**
         * 
         * @param {java.util.Map} map 
         */
        private static lambda$matchSmithingRecipe$6(map: java.util.Map): java.util.stream.Stream;
        /**
         * 
         * @param {cn.nukkit.item.Item} input 
         * @param {cn.nukkit.item.Item} potion 
         */
        public matchContainerRecipe(input: cn.nukkit.item.Item,potion: cn.nukkit.item.Item): cn.nukkit.inventory.ContainerRecipe;
        /**
         * 
         */
        public getFurnaceRecipes(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.item.Item} i1 
         * @param {cn.nukkit.item.Item} i2 
         */
        private static lambda$static$0(i1: cn.nukkit.item.Item,i2: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} input 
         */
        public matchFurnaceRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.FurnaceRecipe;
        /**
         * 
         */
        private registerSmithingRecipes(): void;
        /**
         * 
         * @param {cn.nukkit.inventory.ShapelessRecipe} recipe 
         */
        public registerShapelessRecipe(recipe: cn.nukkit.inventory.ShapelessRecipe): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        private static getFullItemHash(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {java.util.List} inputList 
         */
        private matchSmithingRecipe(inputList: java.util.List): cn.nukkit.inventory.SmithingRecipe;
        /**
         * 
         * @param {cn.nukkit.item.Item} input 
         */
        public matchBlastFurnaceRecipe(input: cn.nukkit.item.Item): cn.nukkit.inventory.BlastFurnaceRecipe;
        /**
         * 
         * @param {java.util.UUID} inputHash 
         * @param {java.util.Map.Entry} entry 
         */
        private static lambda$matchSmithingRecipe$7(inputHash: java.util.UUID,entry: java.util.Map.Entry): boolean;
        /**
         * 
         */
        public getRecipes(): java.util.Collection;
        /**
         * 
         * @param {cn.nukkit.inventory.SmithingRecipe} recipe 
         */
        public registerSmithingRecipe(recipe: cn.nukkit.inventory.SmithingRecipe): void;
        /**
         * 
         * @param {cn.nukkit.inventory.ShapedRecipe} recipe 
         */
        public registerShapedRecipe(recipe: cn.nukkit.inventory.ShapedRecipe): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockBone extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        SPECIAL_PILLAR_AXIS: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        FACES: int[];
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemBoat extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getDamage(): int;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public getLegacyBoatDamage(): java.util.OptionalInt;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemPorkchopRaw extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace com.nukkitx.fakeinventories.inventory{
    abstract class FakeInventory extends cn.nukkit.inventory.ContainerInventory{
        /**  */
        ZERO: cn.nukkit.math.BlockVector3;
        /**  */
        listeners: java.util.List;
        /**  */
        blockPositions: java.util.Map;
        /**  */
        closed: boolean;
        /**  */
        title: java.lang.String;
        /**  */
        open: java.util.Map;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         * @param {cn.nukkit.inventory.transaction.action.SlotChangeAction} arg1 
         */
        public onSlotChange(arg0: cn.nukkit.Player,arg1: cn.nukkit.inventory.transaction.action.SlotChangeAction): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         * @param {java.util.List} arg1 
         */
        protected onFakeOpen(arg0: cn.nukkit.Player,arg1: java.util.List): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public setTitle(arg0: java.lang.String): void;
        /**
         * 
         * @param {com.nukkitx.fakeinventories.inventory.FakeInventoryListener} arg0 
         */
        public removeListener(arg0: com.nukkitx.fakeinventories.inventory.FakeInventoryListener): void;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        public onClose(arg0: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        public getPosition(arg0: cn.nukkit.Player): java.util.List;
        /**
         * 
         */
        public getTitle(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        public onOpen(arg0: cn.nukkit.Player): void;
        /**
         * 
         * @param {java.util.List} arg0 
         * @param {int} arg1 
         * @param {cn.nukkit.Player} arg2 
         */
        private static lambda$onClose$0(arg0: java.util.List,arg1: int,arg2: cn.nukkit.Player): void;
        /**
         * 
         */
         close(): void;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        private lambda$close$1(arg0: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} arg0 
         */
        protected abstract onOpenBlock(arg0: cn.nukkit.Player): java.util.List;
        /**
         * 
         */
        private checkForClosed(): void;
        /**
         * 
         * @param {com.nukkitx.fakeinventories.inventory.FakeInventoryListener} arg0 
         */
        public addListener(arg0: com.nukkitx.fakeinventories.inventory.FakeInventoryListener): void;
    }
}
declare namespace cn.nukkit.event.entity{
    abstract class EntityEvent extends cn.nukkit.event.Event{
        /**  */
        entity: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemTool extends cn.nukkit.item.Item{
        /**  */
        TYPE_AXE: int;
        /**  */
        DURABILITY_WOODEN: int;
        /**  */
        TIER_IRON: int;
        /**  */
        DURABILITY_DIAMOND: int;
        /**  */
        TIER_STONE: int;
        /**  */
        DURABILITY_IRON: int;
        /**  */
        DURABILITY_BOW: int;
        /**  */
        DURABILITY_STONE: int;
        /**  */
        TYPE_NONE: int;
        /**  */
        DURABILITY_NETHERITE: int;
        /**  */
        DURABILITY_FLINT_STEEL: int;
        /**  */
        TYPE_SHEARS: int;
        /**  */
        TIER_GOLD: int;
        /**  */
        TYPE_SHOVEL: int;
        /**  */
        TIER_WOODEN: int;
        /**  */
        DURABILITY_GOLD: int;
        /**  */
        TIER_NETHERITE: int;
        /**  */
        TIER_DIAMOND: int;
        /**  */
        DURABILITY_CROSSBOW: int;
        /**  */
        TYPE_PICKAXE: int;
        /**  */
        TYPE_HOE: int;
        /**  */
        DURABILITY_FISHING_ROD: int;
        /**  */
        TYPE_HANDS_ONLY: int;
        /**  */
        DURABILITY_TRIDENT: int;
        /**  */
        DURABILITY_SHEARS: int;
        /**  */
        TYPE_SWORD: int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public useOn(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public useOn(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public getEnchantAbility(): int;
        /**
         * 
         */
        private isDurable(): boolean;
        /**
         * 
         */
        public isTool(): boolean;
        /**
         * 
         */
        public isShears(): boolean;
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public isUnbreakable(): boolean;
        /**
         * 
         * @param {int} toolType 
         */
        public static getBestTool(toolType: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemPickaxeNetherite extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityRegainHealthEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        reason: int;
        /**  */
        amount: float;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        CAUSE_MAGIC: int;
        /**  */
        CAUSE_CUSTOM: int;
        /**  */
        CAUSE_EATING: int;
        /**  */
        CAUSE_REGEN: int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getRegainReason(): int;
        /**
         * 
         * @param {float} amount 
         */
        public setAmount(amount: float): void;
        /**
         * 
         */
        public getAmount(): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemSlimeball extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item.enchantment.bow{
     class EnchantmentBowKnockback extends cn.nukkit.item.enchantment.bow.EnchantmentBow{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemRabbitFoot extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class SavannaTreePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockStemMelon extends cn.nukkit.block.BlockCropsStem{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getSeedsId(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getFruitId(): int;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityMusic extends cn.nukkit.blockentity.BlockEntity{
        /**
         * 
         */
        public getPitch(): int;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public changePitch(): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         * @param {boolean} powered 
         */
        public setPowered(powered: boolean): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class KillCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace database{
    /**  */
    var memoryStorage: com.blocklynukkit.loader.other.data.MemoryStorage;
    /**  */
    var database: java.lang.String;
    /**  */
    var localStorage: com.blocklynukkit.loader.other.data.LocalStorage;
    /**  */
    var connection: java.sql.Connection;
    /**
     * 
     * @param {java.lang.String} source 
     * @param {java.lang.String} str 
     */
    function countStr(source: java.lang.String,str: java.lang.String): int;
    /**
     * 
     * @param {java.lang.String} stt 
     * @param {java.lang.String} col 
     */
    function databaseQuery(stt: java.lang.String,col: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} url 
     * @param {java.lang.String} username 
     * @param {java.lang.String} password 
     */
    function databaseOpen(url: java.lang.String,username: java.lang.String,password: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} url 
     * @param {java.lang.String} username 
     * @param {java.lang.String} password 
     * @param {java.lang.String} table 
     */
    function databaseOpen(url: java.lang.String,username: java.lang.String,password: java.lang.String,table: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} stt 
     * @param {java.lang.String} col 
     */
    function query(stt: java.lang.String,col: java.lang.String): java.util.List;
    /**
     * 
     * @param {java.lang.String} stt 
     */
    function update(stt: java.lang.String): void;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 
     * @param {java.lang.String} url 
     * @param {java.lang.String} username 
     * @param {java.lang.String} password 
     * @param {java.lang.String} table 
     */
    function open(url: java.lang.String,username: java.lang.String,password: java.lang.String,table: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} stt 
     */
    function databaseUpdate(stt: java.lang.String): void;
}
declare namespace cn.nukkit.block{
     class BlockClay extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class MegaTaigaBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.generator.populator.type{
    abstract class PopulatorSurfaceBlock extends cn.nukkit.level.generator.populator.type.PopulatorCount{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager,x: int,z: int,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected abstract getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected populateCount(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected abstract canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        protected placeBlock(x: int,y: int,z: int,id: int,chunk: cn.nukkit.level.format.FullChunk,random: cn.nukkit.math.NukkitRandom): void;
    }
}
declare namespace cn.nukkit.plugin{
    abstract class EventExecutor extends java.lang.Object{
        /**
         * 
         * @param {cn.nukkit.event.Listener} listener 
         * @param {cn.nukkit.event.Event} event 
         */
        public abstract execute(listener: cn.nukkit.event.Listener,event: cn.nukkit.event.Event): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class SpawnpointCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AddItemEntityPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        entityRuntimeId: long;
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        metadata: cn.nukkit.entity.data.EntityMetadata;
        /**  */
        speedZ: float;
        /**  */
        NETWORK_ID: byte;
        /**  */
        speedY: float;
        /**  */
        speedX: float;
        /**  */
        x: float;
        /**  */
        entityUniqueId: long;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        isFromFishing: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class QQOtherEvent extends cn.nukkit.event.Event{
        /**  */
        fromQQ: java.lang.String;
        /**  */
        selfQQ: java.lang.String;
        /**  */
        fromGroup: java.lang.String;
        /**  */
        type: int;
        /**  */
        seq: java.lang.String;
        /**
         * 
         */
        public getFromQQ(): java.lang.String;
        /**
         * 
         */
        public getSeq(): java.lang.String;
        /**
         * 
         */
        public getSelfQQ(): java.lang.String;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         */
        public getFromGroup(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockMushroomBrown extends cn.nukkit.block.BlockMushroom{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected getType(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockRailPowered extends cn.nukkit.block.BlockRail{
        /**
         * 
         * @param {boolean} active 
         */
        public setRailActive(active: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.block.Block} newBlock 
         * @param {boolean} update 
         */
        public afterRemoval(newBlock: cn.nukkit.block.Block,update: boolean): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {boolean} relative 
         * @param {int} power 
         */
        private checkSurrounding(pos: cn.nukkit.math.Vector3,relative: boolean,power: int): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.utils.Rail.Orientation} state 
         * @param {int} power 
         * @param {boolean} relative 
         */
        protected canPowered(pos: cn.nukkit.math.Vector3,state: cn.nukkit.utils.Rail.Orientation,power: int,relative: boolean): boolean;
        /**
         * 
         */
        public isActive(): boolean;
        /**
         * 
         */
        public isRailActive(): cn.nukkit.utils.OptionalBoolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.level.generator{
     class PopChunkManager extends cn.nukkit.level.generator.SimpleChunkManager{
        /**  */
        CX: int;
        /**  */
        chunks: cn.nukkit.level.format.generic.BaseFullChunk[];
        /**  */
        CZ: int;
        /**  */
        clean: boolean;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        public setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {long} seed 
         */
        public cleanChunks(seed: long): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityBat extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemShovelIron extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockFurnace extends cn.nukkit.block.BlockFurnaceBurning{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class LevelSoundEventPacketV1 extends cn.nukkit.network.protocol.LevelSoundEventPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        extraData: int;
        /**  */
        sound: int;
        /**  */
        isBabyMob: boolean;
        /**  */
        x: float;
        /**  */
        isGlobal: boolean;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        pitch: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ResourcePackChunkRequestPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        packId: java.util.UUID;
        /**  */
        NETWORK_ID: byte;
        /**  */
        chunkIndex: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace org.java_websocket.handshake{
    abstract class ClientHandshake extends java.lang.Object{
        /**
         * 
         */
        public abstract getResourceDescriptor(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockCarpet extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.utils.DyeColor} color 
         */
        public setDyeColor(color: cn.nukkit.utils.DyeColor): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockMonsterEgg extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        NAMES: java.lang.String[];
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        COBBLESTONE: int;
        /**  */
        CHISELED_BRICK: int;
        /**  */
        MONSTER_EGG_STONE_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        STONE: int;
        /**  */
        STONE_BRICK: int;
        /**  */
        MOSSY_BRICK: int;
        /**  */
        CRACKED_BRICK: int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.MonsterEggStoneType} value 
         */
        public setMonsterEggStoneType(value: cn.nukkit.blockproperty.value.MonsterEggStoneType): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getMonsterEggStoneType(): cn.nukkit.blockproperty.value.MonsterEggStoneType;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockBreakEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        face: cn.nukkit.math.BlockFace;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        blockDrops: cn.nukkit.item.Item[];
        /**  */
        instaBreak: boolean;
        /**  */
        blockXP: int;
        /**  */
        player: cn.nukkit.Player;
        /**  */
        fastBreak: boolean;
        /**
         * 
         */
        public isFastBreak(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} drops 
         */
        public setDrops(drops: cn.nukkit.item.Item[]): void;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public getInstaBreak(): boolean;
        /**
         * 
         * @param {boolean} instaBreak 
         */
        public setInstaBreak(instaBreak: boolean): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} xp 
         */
        public setDropExp(xp: int): void;
        /**
         * 
         */
        public getFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.blockentity{
    abstract class BlockEntityNameable extends java.lang.Object{
        /**
         * 
         * @param {java.lang.String} name 
         */
        public abstract setName(name: java.lang.String): void;
        /**
         * 
         */
        public abstract hasName(): boolean;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockWater extends cn.nukkit.block.BlockLiquid{
        /**
         * 
         * @param {int} meta 
         */
        public getBlock(meta: int): cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.block.Block} newBlock 
         * @param {boolean} update 
         */
        public afterRemoval(newBlock: cn.nukkit.block.Block,update: boolean): void;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public tickRate(): int;
        /**
         * 
         */
        public usesWaterLogging(): boolean;
    }
}
declare namespace java.net{
     class URLEncoder extends java.lang.Object{
        /**  */
        dfltEncName: java.lang.String;
        /**  */
        dontNeedEncoding: java.util.BitSet;
        /**  */
        caseDiff: int;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static encode(arg0: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.String} arg1 
         */
        public static encode(arg0: java.lang.String,arg1: java.lang.String): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemBootsGold extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class IntTag extends cn.nukkit.nbt.tag.NumberTag{
        /**  */
        data: int;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         * @param {java.lang.Integer} data 
         */
        public setData(data: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public  setData(data: java.lang.Number): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): java.lang.Integer;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public  getData(): java.lang.Number;
        /**
         * 
         */
        public getData(): java.lang.Integer;
    }
}
declare namespace cn.nukkit.block{
     class BlockBrewingStand extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        HAS_POTION_C: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        HAS_POTION_B: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        HAS_POTION_A: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockTrapdoorIron extends cn.nukkit.block.BlockTrapdoor{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class BlockPickRequestPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        addUserData: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        selectedSlot: int;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class TerrainParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.inventory{
    abstract class ContainerInventory extends cn.nukkit.inventory.BaseInventory{
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public onClose(who: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public onOpen(who: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inv 
         */
        public static calculateRedstone(inv: cn.nukkit.inventory.Inventory): int;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorSugarcane extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.Level} level 
         */
        private findWater(x: int,y: int,z: int,level: cn.nukkit.level.Level): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityMinecartTNT extends cn.nukkit.entity.item.EntityMinecartAbstract{
        /**  */
        fuse: int;
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public dropItem(): void;
        /**
         * 
         */
        public isRideable(): boolean;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getType(): cn.nukkit.utils.MinecartType;
        /**
         * 
         * @param {double} square 
         */
        public explode(square: double): void;
        /**
         * 
         */
        public explode(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {boolean} flag 
         */
        public activate(x: int,y: int,z: int,flag: boolean): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {byte} mode 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity,mode: byte): boolean;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.ocean{
     class OceanBiome extends cn.nukkit.level.biome.type.WateryBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} y 
         */
        public getGroundBlock(y: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockCobweb extends cn.nukkit.block.BlockFlowable{
        /**
         * 
         */
        public diffusesSkyLight(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
    }
}
declare namespace cn.nukkit.entity.data{
     class IntEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        data: int;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Integer} data 
         */
        public setData(data: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): java.lang.Integer;
    }
}
declare namespace cn.nukkit.event.level{
     class SpawnChangeEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        previousSpawn: cn.nukkit.level.Position;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPreviousSpawn(): cn.nukkit.level.Position;
    }
}
declare namespace cn.nukkit.item{
     class ItemApple extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerArmorDamagePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        damage: int[];
        /**  */
        NETWORK_ID: byte;
        /**  */
        flags: java.util.Set;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockStemPumpkin extends cn.nukkit.block.BlockCropsStem{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getSeedsId(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getFruitId(): int;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityTurtle extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {int} ticks 
         */
        public setBreedingAge(ticks: int): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setHomePos(pos: cn.nukkit.math.Vector3): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntitySnowGolem extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
    abstract class ProjectileItem extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public abstract getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public abstract getThrowForce(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.entity.Entity} projectile 
         */
        protected correctProjectile(player: cn.nukkit.Player,projectile: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         */
        protected correctNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        protected addThrowSound(player: cn.nukkit.Player): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordChirp extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.inventory{
    abstract class CraftingRecipe extends java.lang.Object{
        /**
         * 
         */
        public abstract requiresCraftingTable(): boolean;
        /**
         * 
         */
        public abstract getPriority(): int;
        /**
         * 
         */
        public abstract getIngredientsAggregate(): java.util.List;
        /**
         * 
         * @param {java.util.UUID} id 
         */
        public abstract setId(id: java.util.UUID): void;
        /**
         * 
         */
        public abstract getId(): java.util.UUID;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {java.util.List} extraOutputList 
         * @param {int} multiplier 
         */
        public abstract matchItems(inputList: java.util.List,extraOutputList: java.util.List,multiplier: int): boolean;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {java.util.List} extraOutputList 
         */
        public abstract matchItems(inputList: java.util.List,extraOutputList: java.util.List): boolean;
        /**
         * 
         */
        public abstract getAllResults(): java.util.List;
        /**
         * 
         */
        public abstract getRecipeId(): java.lang.String;
        /**
         * 
         */
        public abstract getExtraResults(): java.util.List;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerJoinEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        joinMessage: cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public getJoinMessage(): cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {java.lang.String} joinMessage 
         */
        public setJoinMessage(joinMessage: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} joinMessage 
         */
        public setJoinMessage(joinMessage: cn.nukkit.lang.TextContainer): void;
    }
}
declare namespace java.lang{
     class Thread extends java.lang.Object{
        /**  */
        blocker: sun.nio.ch.Interruptible;
        /**  */
        blockerLock: java.lang.Object;
        /**  */
        threadLocals: java.lang.ThreadLocal.ThreadLocalMap;
        /**  */
        threadQ: java.lang.Thread;
        /**  */
        MIN_PRIORITY: int;
        /**  */
        eetop: long;
        /**  */
        tid: long;
        /**  */
        uncaughtExceptionHandler: java.lang.Thread.UncaughtExceptionHandler;
        /**  */
        defaultUncaughtExceptionHandler: java.lang.Thread.UncaughtExceptionHandler;
        /**  */
        stillborn: boolean;
        /**  */
        threadStatus: int;
        /**  */
        contextClassLoader: java.lang.ClassLoader;
        /**  */
        stackSize: long;
        /**  */
        threadLocalRandomSecondarySeed: int;
        /**  */
        inheritedAccessControlContext: java.security.AccessControlContext;
        /**  */
        parkBlocker: java.lang.Object;
        /**  */
        group: java.lang.ThreadGroup;
        /**  */
        EMPTY_STACK_TRACE: java.lang.StackTraceElement[];
        /**  */
        single_step: boolean;
        /**  */
        inheritableThreadLocals: java.lang.ThreadLocal.ThreadLocalMap;
        /**  */
        priority: int;
        /**  */
        MAX_PRIORITY: int;
        /**  */
        NORM_PRIORITY: int;
        /**  */
        daemon: boolean;
        /**  */
        target: java.lang.Runnable;
        /**  */
        threadSeqNumber: long;
        /**  */
        nativeParkEventPointer: long;
        /**  */
        SUBCLASS_IMPLEMENTATION_PERMISSION: java.lang.RuntimePermission;
        /**  */
        name: java.lang.String;
        /**  */
        threadInitNumber: int;
        /**  */
        threadLocalRandomSeed: long;
        /**  */
        threadLocalRandomProbe: int;
        /**
         * 
         */
        public  getName(): java.lang.String;
        /**
         * 
         */
        private  suspend0(): void;
        /**
         * 
         * @param {java.lang.Class} arg0 
         */
        private static isCCLOverridden(arg0: java.lang.Class): boolean;
        /**
         * 
         */
        public run(): void;
        /**
         * 
         * @param {int} arg0 
         */
        private  setPriority0(arg0: int): void;
        /**
         * 
         * @param {java.lang.ClassLoader} arg0 
         */
        public setContextClassLoader(arg0: java.lang.ClassLoader): void;
        /**
         * 
         * @param {java.lang.Thread[]} arg0 
         */
        private static  dumpThreads(arg0: java.lang.Thread[]): java.lang.StackTraceElement[][];
        /**
         * 
         */
        public getStackTrace(): java.lang.StackTraceElement[];
        /**
         * 
         */
        public  isDaemon(): boolean;
        /**
         * 
         */
        private static  nextThreadID(): long;
        /**
         * 
         */
        public interrupt(): void;
        /**
         * 
         * @param {long} arg0 
         */
        public   join(arg0: long): void;
        /**
         * 
         * @param {long} arg0 
         * @param {int} arg1 
         */
        public   join(arg0: long,arg1: int): void;
        /**
         * 
         */
        public  join(): void;
        /**
         * 
         */
        public  suspend(): void;
        /**
         * 
         * @param {java.lang.Throwable} arg0 
         */
        private dispatchUncaughtException(arg0: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.ThreadGroup} arg0 
         * @param {java.lang.Runnable} arg1 
         * @param {java.lang.String} arg2 
         * @param {long} arg3 
         * @param {java.security.AccessControlContext} arg4 
         * @param {boolean} arg5 
         */
        private init(arg0: java.lang.ThreadGroup,arg1: java.lang.Runnable,arg2: java.lang.String,arg3: long,arg4: java.security.AccessControlContext,arg5: boolean): void;
        /**
         * 
         * @param {java.lang.ThreadGroup} arg0 
         * @param {java.lang.Runnable} arg1 
         * @param {java.lang.String} arg2 
         * @param {long} arg3 
         */
        private init(arg0: java.lang.ThreadGroup,arg1: java.lang.Runnable,arg2: java.lang.String,arg3: long): void;
        /**
         * 
         */
        public static  currentThread(): java.lang.Thread;
        /**
         * 
         * @param {java.lang.Thread.UncaughtExceptionHandler} arg0 
         */
        public setUncaughtExceptionHandler(arg0: java.lang.Thread.UncaughtExceptionHandler): void;
        /**
         * 
         * @param {java.lang.Thread.UncaughtExceptionHandler} arg0 
         */
        public static setDefaultUncaughtExceptionHandler(arg0: java.lang.Thread.UncaughtExceptionHandler): void;
        /**
         * 
         */
        public destroy(): void;
        /**
         * 
         */
        public static interrupted(): boolean;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private  setNativeName(arg0: java.lang.String): void;
        /**
         * 
         */
        public  checkAccess(): void;
        /**
         * 
         */
        private exit(): void;
        /**
         * 
         */
        public static getDefaultUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler;
        /**
         * 
         */
        public   isAlive(): boolean;
        /**
         * 
         * @param {java.lang.Throwable} arg0 
         */
        public   stop(arg0: java.lang.Throwable): void;
        /**
         * 
         */
        public  stop(): void;
        /**
         * 
         */
        public getContextClassLoader(): java.lang.ClassLoader;
        /**
         * 
         * @param {int} arg0 
         */
        public  setPriority(arg0: int): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public   setName(arg0: java.lang.String): void;
        /**
         * 
         */
        public  getThreadGroup(): java.lang.ThreadGroup;
        /**
         * 
         */
        private  start0(): void;
        /**
         * 
         */
        public static getAllStackTraces(): java.util.Map;
        /**
         * 
         */
        private  interrupt0(): void;
        /**
         * 
         */
        private  resume0(): void;
        /**
         * 
         */
        private static  registerNatives(): void;
        /**
         * 
         */
        public getId(): long;
        /**
         * 
         * @param {long} arg0 
         * @param {int} arg1 
         */
        public static sleep(arg0: long,arg1: int): void;
        /**
         * 
         * @param {long} arg0 
         */
        public static  sleep(arg0: long): void;
        /**
         * 
         */
        public static  yield(): void;
        /**
         * 
         * @param {java.lang.Thread[]} arg0 
         */
        public static enumerate(arg0: java.lang.Thread[]): int;
        /**
         * 
         * @param {java.lang.Class} arg0 
         */
        private static auditSubclass(arg0: java.lang.Class): boolean;
        /**
         * 
         */
        private static  nextThreadNum(): int;
        /**
         * 
         */
        public static activeCount(): int;
        /**
         * 
         */
        public  resume(): void;
        /**
         * 
         * @param {sun.nio.ch.Interruptible} arg0 
         */
         blockedOn(arg0: sun.nio.ch.Interruptible): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        private  stop0(arg0: java.lang.Object): void;
        /**
         * 
         */
        public isInterrupted(): boolean;
        /**
         * 
         * @param {boolean} arg0 
         */
        private  isInterrupted(arg0: boolean): boolean;
        /**
         * 
         */
        public static dumpStack(): void;
        /**
         * 
         */
        public  start(): void;
        /**
         * 
         * @param {java.lang.ref.ReferenceQueue} arg0 
         * @param {java.util.concurrent.ConcurrentMap} arg1 
         */
        static processQueue(arg0: java.lang.ref.ReferenceQueue,arg1: java.util.concurrent.ConcurrentMap): void;
        /**
         * 
         */
        public getUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler;
        /**
         * 
         * @param {boolean} arg0 
         */
        public  setDaemon(arg0: boolean): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public static  holdsLock(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public getState(): java.lang.Thread.State;
        /**
         * 
         */
        protected clone(): java.lang.Object;
        /**
         * 
         */
        public  getPriority(): int;
        /**
         * 
         */
        public  countStackFrames(): int;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        private static  getThreads(): java.lang.Thread[];
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneWire extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        canProvidePower: boolean;
        /**  */
        blocksNeedingUpdate: java.util.Set;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected static canConnectUpwardsTo(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        protected static canConnectUpwardsTo(level: cn.nukkit.level.Level,pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        protected static canConnectTo(block: cn.nukkit.block.Block,side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        private isPowerSourceAt(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         * @param {boolean} force 
         */
        private calculateCurrentChanges(force: boolean): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} maxStrength 
         */
        private getMaxCurrentStrength(pos: cn.nukkit.math.Vector3,maxStrength: int): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        private getIndirectPower(pos: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        private getIndirectPower(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        private updateAround(pos: cn.nukkit.level.Position,face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} direction 
         */
        private getStrongPower(pos: cn.nukkit.math.Vector3,direction: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        private getStrongPower(pos: cn.nukkit.math.Vector3): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} support 
         */
        public canBePlacedOn(support: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {boolean} force 
         */
        private updateSurroundingRedstone(force: boolean): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace org.java_websocket{
    abstract class WebSocketListener extends java.lang.Object{
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.ClientHandshake} arg1 
         */
        public abstract onWebsocketHandshakeSentAsClient(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.ClientHandshake): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public abstract getLocalSocketAddress(arg0: org.java_websocket.WebSocket): java.net.InetSocketAddress;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         */
        public abstract onWebsocketMessage(arg0: org.java_websocket.WebSocket,arg1: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.String} arg1 
         */
        public abstract onWebsocketMessage(arg0: org.java_websocket.WebSocket,arg1: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.Handshakedata} arg1 
         */
        public abstract onWebsocketOpen(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.Handshakedata): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public abstract onWriteDemand(arg0: org.java_websocket.WebSocket): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.drafts.Draft} arg1 
         * @param {org.java_websocket.handshake.ClientHandshake} arg2 
         */
        public abstract onWebsocketHandshakeReceivedAsServer(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.drafts.Draft,arg2: org.java_websocket.handshake.ClientHandshake): org.java_websocket.handshake.ServerHandshakeBuilder;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.Exception} arg1 
         */
        public abstract onWebsocketError(arg0: org.java_websocket.WebSocket,arg1: java.lang.Exception): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.framing.Framedata} arg1 
         */
        public abstract onWebsocketPing(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.framing.Framedata): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.ClientHandshake} arg1 
         * @param {org.java_websocket.handshake.ServerHandshake} arg2 
         */
        public abstract onWebsocketHandshakeReceivedAsClient(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.ClientHandshake,arg2: org.java_websocket.handshake.ServerHandshake): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         */
        public abstract onWebsocketCloseInitiated(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public abstract onPreparePing(arg0: org.java_websocket.WebSocket): org.java_websocket.framing.PingFrame;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.framing.Framedata} arg1 
         */
        public abstract onWebsocketPong(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.framing.Framedata): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public abstract onWebsocketClosing(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public abstract onWebsocketClose(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public abstract getRemoteSocketAddress(arg0: org.java_websocket.WebSocket): java.net.InetSocketAddress;
    }
}
declare namespace cn.nukkit.utils{
     class ChunkException extends java.lang.RuntimeException{
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaStained extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.utils.bugreport{
     class ExceptionHandler extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Thread} thread 
         * @param {java.lang.Throwable} throwable 
         */
        public uncaughtException(thread: java.lang.Thread,throwable: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.Thread} thread 
         * @param {java.lang.Throwable} throwable 
         */
        public handle(thread: java.lang.Thread,throwable: java.lang.Throwable): void;
        /**
         * 
         */
        public static registerExceptionHandler(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class InventoryTransactionPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        USE_ITEM_ACTION_CLICK_AIR: int;
        /**  */
        isCraftingPart: boolean;
        /**  */
        RELEASE_ITEM_ACTION_CONSUME: int;
        /**  */
        USE_ITEM_ON_ENTITY_ACTION_ATTACK: int;
        /**  */
        USE_ITEM_ON_ENTITY_ACTION_INTERACT: int;
        /**  */
        ACTION_MAGIC_SLOT_CREATIVE_DELETE_ITEM: int;
        /**  */
        transactionData: cn.nukkit.inventory.transaction.data.TransactionData;
        /**  */
        USE_ITEM_ACTION_CLICK_BLOCK: int;
        /**  */
        ACTION_MAGIC_SLOT_CREATIVE_CREATE_ITEM: int;
        /**  */
        isEnchantingPart: boolean;
        /**  */
        ACTION_MAGIC_SLOT_PICKUP_ITEM: int;
        /**  */
        legacyRequestId: int;
        /**  */
        USE_ITEM_ACTION_BREAK_BLOCK: int;
        /**  */
        transactionType: int;
        /**  */
        TYPE_RELEASE_ITEM: int;
        /**  */
        ACTION_MAGIC_SLOT_DROP_ITEM: int;
        /**  */
        TYPE_USE_ITEM_ON_ENTITY: int;
        /**  */
        TYPE_MISMATCH: int;
        /**  */
        TYPE_NORMAL: int;
        /**  */
        RELEASE_ITEM_ACTION_RELEASE: int;
        /**  */
        isRepairItemPart: boolean;
        /**  */
        TYPE_USE_ITEM: int;
        /**  */
        actions: cn.nukkit.network.protocol.types.NetworkInventoryAction[];
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityEvoker extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityFirework extends cn.nukkit.entity.Entity{
        /**  */
        firework: cn.nukkit.item.Item;
        /**  */
        NETWORK_ID: int;
        /**  */
        lifetime: int;
        /**  */
        fireworkAge: int;
        /**  */
        hadCollision: boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setFirework(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.command.defaults{
     class SaveOffCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryOpenEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        who: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityFurnace extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        maxTime: int;
        /**  */
        burnDuration: int;
        /**  */
        burnTime: int;
        /**  */
        cookTime: int;
        /**  */
        inventory: cn.nukkit.inventory.FurnaceInventory;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public onBreak(): void;
        /**
         * 
         * @param {int} maxTime 
         */
        public setMaxTime(maxTime: int): void;
        /**
         * 
         */
        public hasName(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} burnTime 
         */
        public setBurnTime(burnTime: int): void;
        /**
         * 
         */
        public getMaxTime(): int;
        /**
         * 
         * @param {int} cookTime 
         */
        public setCookTime(cookTime: int): void;
        /**
         * 
         * @param {int} index 
         */
        public getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getBurnDuration(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} raw 
         */
        protected matchRecipe(raw: cn.nukkit.item.Item): cn.nukkit.inventory.SmeltingRecipe;
        /**
         * 
         * @param {int} index 
         */
        protected getSlotIndex(index: int): int;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        protected getBurningBlockId(): int;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.FurnaceInventory;
        /**
         * 
         */
        public getCookTime(): int;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(index: int,item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        protected getClientName(): java.lang.String;
        /**
         * 
         */
        protected getSpeedMultiplier(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        protected getIdleBlockId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} fuel 
         */
        protected checkFuel(fuel: cn.nukkit.item.Item): void;
        /**
         * 
         */
        protected getFurnaceName(): java.lang.String;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         */
        protected getInventoryType(): cn.nukkit.inventory.InventoryType;
        /**
         * 
         * @param {boolean} burning 
         */
        protected setBurning(burning: boolean): void;
        /**
         * 
         */
        public getBurnTime(): int;
        /**
         * 
         * @param {int} burnDuration 
         */
        public setBurnDuration(burnDuration: int): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public onUpdate(): boolean;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityWolf extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreedingItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.level{
     class LevelInitEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.block{
     class BlockPistonHead extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item.enchantment.protection{
     class EnchantmentProtectionProjectile extends cn.nukkit.item.enchantment.protection.EnchantmentProtection{
        /**
         * 
         */
        public getTypeModifier(): double;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} e 
         */
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float;
    }
}
declare namespace cn.nukkit.block{
     class BlockCake extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        BITES: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public getMinY(): double;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.plugin{
     class PluginClassLoader extends java.net.URLClassLoader{
        /**  */
        loader: cn.nukkit.plugin.JavaPluginLoader;
        /**  */
        classes: java.util.Map;
        /**
         * 
         * @param {java.lang.String} name 
         */
        protected findClass(name: java.lang.String): java.lang.Class;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} checkGlobal 
         */
        protected findClass(name: java.lang.String,checkGlobal: boolean): java.lang.Class;
        /**
         * 
         */
         getClasses(): java.util.Set;
    }
}
declare namespace cn.nukkit.utils{
     class EventException extends java.lang.RuntimeException{
        /**  */
        cause: java.lang.Throwable;
        /**
         * 
         */
        public getCause(): java.lang.Throwable;
    }
}
declare namespace cn.nukkit.network.protocol{
     class EmotePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        flags: byte;
        /**  */
        emoteID: java.lang.String;
        /**  */
        runtimeId: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.server{
     class DataPacketSendEvent extends cn.nukkit.event.server.ServerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        packet: cn.nukkit.network.protocol.DataPacket;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public getPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.level.generator.object.ore{
     class OreType extends java.lang.Object{
        /**  */
        blockId: int;
        /**  */
        minHeight: int;
        /**  */
        clusterCount: int;
        /**  */
        EMPTY_ARRAY: cn.nukkit.level.generator.object.ore.OreType[];
        /**  */
        maxHeight: int;
        /**  */
        replaceBlockId: int;
        /**  */
        fullId: int;
        /**  */
        blockData: int;
        /**  */
        clusterSize: int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {int} replaceId 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public spawn(level: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,replaceId: int,x: int,y: int,z: int): boolean;
    }
}
declare namespace cn.nukkit.permission{
     class PermissionAttachment extends java.lang.Object{
        /**  */
        removed: cn.nukkit.permission.PermissionRemovedExecutor;
        /**  */
        plugin: cn.nukkit.plugin.Plugin;
        /**  */
        permissions: java.util.Map;
        /**  */
        permissible: cn.nukkit.permission.Permissible;
        /**
         * 
         */
        public getRemovalCallback(): cn.nukkit.permission.PermissionRemovedExecutor;
        /**
         * 
         */
        public clearPermissions(): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} value 
         */
        public unsetPermission(name: java.lang.String,value: boolean): void;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         * @param {boolean} value 
         */
        public unsetPermission(permission: cn.nukkit.permission.Permission,value: boolean): void;
        /**
         * 
         */
        public getPermissions(): java.util.Map;
        /**
         * 
         */
        public getPlugin(): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         * @param {boolean} value 
         */
        public setPermission(permission: cn.nukkit.permission.Permission,value: boolean): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} value 
         */
        public setPermission(name: java.lang.String,value: boolean): void;
        /**
         * 
         * @param {java.util.List} permissions 
         */
        public unsetPermissions(permissions: java.util.List): void;
        /**
         * 
         * @param {java.util.Map} permissions 
         */
        public setPermissions(permissions: java.util.Map): void;
        /**
         * 
         * @param {cn.nukkit.permission.PermissionRemovedExecutor} executor 
         */
        public setRemovalCallback(executor: cn.nukkit.permission.PermissionRemovedExecutor): void;
        /**
         * 
         */
        public remove(): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntitySalmon extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item.randomitem{
     class ConstantItemSelector extends cn.nukkit.item.randomitem.Selector{
        /**  */
        item: cn.nukkit.item.Item;
        /**
         * 
         */
        public select(): java.lang.Object;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemShield extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
    }
}
declare namespace cn.nukkit.entity.projectile{
     class EntitySnowball extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        NETWORK_ID: int;
        /**  */
        particleIndex: int;
        /**  */
        particleCounts: byte[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getResultDamage(entity: cn.nukkit.entity.Entity): int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        protected addHitEffect(): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
        /**
         * 
         */
        private static nextParticleCount(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoneyBottle extends cn.nukkit.item.ItemEdible{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onUse(player: cn.nukkit.Player,ticksUsed: int): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.plains{
     class PlainsBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public isDry(): boolean;
    }
}
declare namespace cn.nukkit.event.level{
     class StructureGrowEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        blocks: java.util.List;
        /**  */
        block: cn.nukkit.block.Block;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {java.util.List} blocks 
         */
        public setBlockList(blocks: java.util.List): void;
        /**
         * 
         */
        public getBlockList(): java.util.List;
    }
}
declare namespace cn.nukkit.item{
     class ItemLeggingsIron extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isLeggings(): boolean;
    }
}
declare namespace cn.nukkit.level.particle{
     class InstantEnchantParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.item{
     class ItemHoeStone extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.level{
     class EnumLevel extends java.lang.Enum{
        /**  */
        OVERWORLD: cn.nukkit.level.EnumLevel;
        /**  */
        NETHER: cn.nukkit.level.EnumLevel;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        level: cn.nukkit.level.Level;
        /**  */
        $VALUES: cn.nukkit.level.EnumLevel[];
        /**
         * 
         */
        public getLevel(): cn.nukkit.level.Level;
        /**
         * 
         */
        public static initLevels(): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.level.EnumLevel;
        /**
         * 
         * @param {int} value 
         * @param {int} factor 
         */
        private static  mRound(value: int,factor: int): int;
        /**
         * 
         */
        public static values(): cn.nukkit.level.EnumLevel[];
        /**
         * 
         * @param {cn.nukkit.level.Position} current 
         */
        public static moveToNether(current: cn.nukkit.level.Position): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.level.Level} current 
         */
        public static getOtherNetherPair(current: cn.nukkit.level.Level): cn.nukkit.level.Level;
    }
}
declare namespace cn.nukkit.math{
     class BlockVector3 extends java.lang.Object{
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public distance(pos: cn.nukkit.math.Vector3): double;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} pos 
         */
        public distance(pos: cn.nukkit.math.BlockVector3): double;
        /**
         * 
         */
        public getChunkVector(): cn.nukkit.math.ChunkVector2;
        /**
         * 
         * @param {int} step 
         */
        public south(step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public south(): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setComponentsAdding(pos: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public north(): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} step 
         */
        public north(step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} step 
         */
        public down(step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public down(): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public asVector3(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public distanceSquared(x: double,y: double,z: double): double;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} pos 
         */
        public distanceSquared(pos: cn.nukkit.math.BlockVector3): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public distanceSquared(pos: cn.nukkit.math.Vector3): double;
        /**
         * 
         */
        public east(): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} step 
         */
        public east(step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public getChunkSectionY(): int;
        /**
         * 
         */
        public  hashCode(): int;
        /**
         * 
         * @param {int} step 
         */
        public west(step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public west(): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} number 
         */
        public divide(number: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public up(): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} step 
         */
        public up(step: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} number 
         */
        public multiply(number: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} x 
         */
        public add(x: cn.nukkit.math.BlockVector3): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public add(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public add(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public add(x: int,y: int,z: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         */
        public add(x: int,y: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} x 
         */
        public add(x: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {double} x 
         */
        public add(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public setComponents(x: int,y: int,z: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} x 
         */
        public subtract(x: cn.nukkit.math.BlockVector3): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public subtract(x: int,y: int,z: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         */
        public subtract(x: int,y: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public subtract(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public subtract(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} x 
         */
        public subtract(x: int): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public subtract(): cn.nukkit.math.BlockVector3;
        /**
         * 
         * @param {double} x 
         */
        public subtract(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace.Axis} axis 
         */
        public getAxis(axis: cn.nukkit.math.BlockFace.Axis): int;
        /**
         * 
         */
        public getX(): int;
        /**
         * 
         */
        public getY(): int;
        /**
         * 
         */
        public getChunkZ(): int;
        /**
         * 
         */
        public getZ(): int;
        /**
         * 
         */
        public getChunkX(): int;
        /**
         * 
         * @param {java.lang.Object} o 
         */
        public equals(o: java.lang.Object): boolean;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public asVector3f(): cn.nukkit.math.Vector3f;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsWood extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoeNetherite extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class BlockEntityDataPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**  */
        namedTag: byte[];
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.entity{
     class ExplosionPrimeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        force: double;
        /**  */
        blockBreaking: boolean;
        /**
         * 
         * @param {double} force 
         */
        public setForce(force: double): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getForce(): double;
        /**
         * 
         */
        public isBlockBreaking(): boolean;
        /**
         * 
         * @param {boolean} affectsBlocks 
         */
        public setBlockBreaking(affectsBlocks: boolean): void;
    }
}
declare namespace cn.nukkit.event.level{
     class ChunkLoadEvent extends cn.nukkit.event.level.ChunkEvent{
        /**  */
        newChunk: boolean;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isNewChunk(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockPotato extends cn.nukkit.block.BlockCrops{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityTropicalFish extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemSpiderEye extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.utils{
     class ZlibThreadLocal extends java.lang.Object{
        /**  */
        INFLATER: java.lang.ThreadLocal;
        /**  */
        DEFLATER: java.lang.ThreadLocal;
        /**  */
        BUFFER: java.lang.ThreadLocal;
        /**
         * 
         * @param {byte[]} data 
         * @param {int} level 
         */
        public deflate(data: byte[],level: int): byte[];
        /**
         * 
         * @param {byte[][]} datas 
         * @param {int} level 
         */
        public deflate(datas: byte[][],level: int): byte[];
        /**
         * 
         * @param {byte[]} data 
         * @param {int} maxSize 
         */
        public inflate(data: byte[],maxSize: int): byte[];
        /**
         * 
         */
        private static lambda$static$0(): byte[];
    }
}
declare namespace cn.nukkit.event.entity{
     class ItemDespawnEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.item.EntityItem;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceGateAcacia extends cn.nukkit.block.BlockFenceGate{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockDispenser extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        TRIGGERED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        protected getDispenseBehavior(item: cn.nukkit.item.Item): cn.nukkit.dispenser.DispenseBehavior;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {boolean} value 
         */
        public setTriggered(value: boolean): void;
        /**
         * 
         */
        public dispense(): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getDispensePosition(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public isTriggered(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemCompass extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.nbt.tag{
     class ByteArrayTag extends cn.nukkit.nbt.tag.Tag{
        /**  */
        data: byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): byte[];
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public getData(): byte[];
    }
}
declare namespace cn.nukkit.event.vehicle{
     class VehicleCreateEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.permission{
     class PermissionAttachmentInfo extends java.lang.Object{
        /**  */
        attachment: cn.nukkit.permission.PermissionAttachment;
        /**  */
        permissible: cn.nukkit.permission.Permissible;
        /**  */
        permission: java.lang.String;
        /**  */
        value: boolean;
        /**
         * 
         */
        public getValue(): boolean;
        /**
         * 
         */
        public getAttachment(): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         */
        public getPermission(): java.lang.String;
        /**
         * 
         */
        public getPermissible(): cn.nukkit.permission.Permissible;
    }
}
declare namespace cn.nukkit.command.defaults{
     class TitleCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemRedstoneComparator extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.entity.projectile{
     class EntityEgg extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        protected addHitEffect(): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class ColdTaigaBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isFreezing(): boolean;
        /**
         * 
         */
        public getCoverBlock(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerFoodLevelChangeEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        foodSaturationLevel: float;
        /**  */
        foodLevel: int;
        /**
         * 
         * @param {float} foodSaturationLevel 
         */
        public setFoodSaturationLevel(foodSaturationLevel: float): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {int} foodLevel 
         */
        public setFoodLevel(foodLevel: int): void;
        /**
         * 
         */
        public getFoodLevel(): int;
        /**
         * 
         */
        public getFoodSaturationLevel(): float;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MobEffectPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        duration: int;
        /**  */
        eid: long;
        /**  */
        eventId: int;
        /**  */
        EVENT_REMOVE: byte;
        /**  */
        effectId: int;
        /**  */
        EVENT_MODIFY: byte;
        /**  */
        NETWORK_ID: byte;
        /**  */
        EVENT_ADD: byte;
        /**  */
        amplifier: int;
        /**  */
        particles: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemMushroomStew extends cn.nukkit.item.ItemEdible{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.command.data{
     class CommandParameter extends java.lang.Object{
        /**  */
        enumData: cn.nukkit.command.data.CommandEnum;
        /**  */
        ENUM_TYPE_PARTICLE_LIST: java.lang.String;
        /**  */
        ENUM_TYPE_BLOCK_LIST: java.lang.String;
        /**  */
        ARG_TYPE_BOOL: java.lang.String;
        /**  */
        EMPTY_ARRAY: cn.nukkit.command.data.CommandParameter[];
        /**  */
        ENUM_TYPE_ITEM_LIST: java.lang.String;
        /**  */
        ARG_TYPE_TARGET: java.lang.String;
        /**  */
        optional: boolean;
        /**  */
        ENUM_TYPE_EFFECT_LIST: java.lang.String;
        /**  */
        type: cn.nukkit.command.data.CommandParamType;
        /**  */
        ARG_TYPE_STRING: java.lang.String;
        /**  */
        ENUM_TYPE_ENCHANTMENT_LIST: java.lang.String;
        /**  */
        ARG_TYPE_PLAYER: java.lang.String;
        /**  */
        ARG_TYPE_STRING_ENUM: java.lang.String;
        /**  */
        name: java.lang.String;
        /**  */
        options: byte;
        /**  */
        ARG_TYPE_RAW_TEXT: java.lang.String;
        /**  */
        ARG_TYPE_BLOCK_POS: java.lang.String;
        /**  */
        ARG_TYPE_INT: java.lang.String;
        /**  */
        postFix: java.lang.String;
        /**  */
        ENUM_TYPE_ENTITY_LIST: java.lang.String;
        /**  */
        ENUM_TYPE_COMMAND_LIST: java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} optional 
         * @param {cn.nukkit.command.data.CommandParamType} type 
         */
        public static newType(name: java.lang.String,optional: boolean,type: cn.nukkit.command.data.CommandParamType): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.command.data.CommandParamType} type 
         */
        public static newType(name: java.lang.String,type: cn.nukkit.command.data.CommandParamType): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.String} postfix 
         */
        public static newPostfix(name: java.lang.String,postfix: java.lang.String): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} optional 
         * @param {java.lang.String} postfix 
         */
        public static newPostfix(name: java.lang.String,optional: boolean,postfix: java.lang.String): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.String[]} values 
         */
        public static newEnum(name: java.lang.String,values: java.lang.String[]): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} optional 
         * @param {cn.nukkit.command.data.CommandEnum} data 
         */
        public static newEnum(name: java.lang.String,optional: boolean,data: cn.nukkit.command.data.CommandEnum): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.command.data.CommandEnum} data 
         */
        public static newEnum(name: java.lang.String,data: cn.nukkit.command.data.CommandEnum): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.String} type 
         */
        public static newEnum(name: java.lang.String,type: java.lang.String): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} optional 
         * @param {java.lang.String[]} values 
         */
        public static newEnum(name: java.lang.String,optional: boolean,values: java.lang.String[]): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} optional 
         * @param {java.lang.String} type 
         */
        public static newEnum(name: java.lang.String,optional: boolean,type: java.lang.String): cn.nukkit.command.data.CommandParameter;
        /**
         * 
         * @param {java.lang.String} param 
         */
        protected static fromString(param: java.lang.String): cn.nukkit.command.data.CommandParamType;
    }
}
declare namespace cn.nukkit.utils{
    abstract class SimpleConfig extends java.lang.Object{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        configFile: java.io.File;
        /**
         * 
         */
        public load(): boolean;
        /**
         * 
         * @param {boolean} async 
         */
        public save(async: boolean): boolean;
        /**
         * 
         */
        public save(): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private getPath(field: java.lang.reflect.Field): java.lang.String;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private skipLoad(field: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} field 
         */
        private skipSave(field: java.lang.reflect.Field): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockHugeMushroomBrown extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        HUGE_MUSHROOM: cn.nukkit.blockproperty.IntBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerItemConsumeEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemSalmon extends cn.nukkit.item.ItemFish{
    }
}
declare namespace cn.nukkit.network.protocol{
     class BiomeDefinitionListPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        TAG: byte[];
        /**  */
        tag: byte[];
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class BatchPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        payload: byte[];
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public trim(): void;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedGreen extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemHorseArmorGold extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AddEntityPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        metadata: cn.nukkit.entity.data.EntityMetadata;
        /**  */
        speedZ: float;
        /**  */
        NETWORK_ID: byte;
        /**  */
        speedY: float;
        /**  */
        speedX: float;
        /**  */
        headYaw: float;
        /**  */
        entityUniqueId: long;
        /**  */
        type: int;
        /**  */
        LEGACY_IDS: com.google.common.collect.ImmutableMap;
        /**  */
        yaw: float;
        /**  */
        entityRuntimeId: long;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        attributes: cn.nukkit.entity.Attribute[];
        /**  */
        links: cn.nukkit.network.protocol.types.EntityLink[];
        /**  */
        id: java.lang.String;
        /**  */
        pitch: float;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class SwampTreePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.level.generator.noise.vanilla.f{
     class NoiseGeneratorImprovedF extends java.lang.Object{
        /**  */
        GRAD_Y: float[];
        /**  */
        yCoord: float;
        /**  */
        GRAD_Z: float[];
        /**  */
        xCoord: float;
        /**  */
        GRAD_2Z: float[];
        /**  */
        zCoord: float;
        /**  */
        GRAD_2X: float[];
        /**  */
        permutations: int[];
        /**  */
        GRAD_X: float[];
        /**
         * 
         * @param {float[]} noiseArray 
         * @param {float} xOffset 
         * @param {float} yOffset 
         * @param {float} zOffset 
         * @param {int} xSize 
         * @param {int} ySize 
         * @param {int} zSize 
         * @param {float} xScale 
         * @param {float} yScale 
         * @param {float} zScale 
         * @param {float} noiseScale 
         */
        public populateNoiseArray(noiseArray: float[],xOffset: float,yOffset: float,zOffset: float,xSize: int,ySize: int,zSize: int,xScale: float,yScale: float,zScale: float,noiseScale: float): void;
        /**
         * 
         * @param {int} p_76309_1_ 
         * @param {float} p_76309_2_ 
         * @param {float} p_76309_4_ 
         */
        public  grad2(p_76309_1_: int,p_76309_2_: float,p_76309_4_: float): float;
        /**
         * 
         * @param {float} p_76311_1_ 
         * @param {float} p_76311_3_ 
         * @param {float} p_76311_5_ 
         */
        public  lerp(p_76311_1_: float,p_76311_3_: float,p_76311_5_: float): float;
        /**
         * 
         * @param {int} p_76310_1_ 
         * @param {float} p_76310_2_ 
         * @param {float} p_76310_4_ 
         * @param {float} p_76310_6_ 
         */
        public  grad(p_76310_1_: int,p_76310_2_: float,p_76310_4_: float,p_76310_6_: float): float;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryMoveItemEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        targetInventory: cn.nukkit.inventory.Inventory;
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        action: cn.nukkit.event.inventory.InventoryMoveItemEvent.Action;
        /**  */
        source: cn.nukkit.inventory.InventoryHolder;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSource(): cn.nukkit.inventory.InventoryHolder;
        /**
         * 
         */
        public getTargetInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getAction(): cn.nukkit.event.inventory.InventoryMoveItemEvent.Action;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(item: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorSpruce extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.command.defaults{
     class ParticleCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**  */
        ENUM_VALUES: java.lang.String[];
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} data 
         */
        private getParticle(name: java.lang.String,pos: cn.nukkit.math.Vector3,data: int): cn.nukkit.level.particle.Particle;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockPlaceEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        blockReplace: cn.nukkit.block.Block;
        /**  */
        blockAgainst: cn.nukkit.block.Block;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getBlockAgainst(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getBlockReplace(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorGrass extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
    abstract class ProtocolInfo extends java.lang.Object{
        /**  */
        CONTAINER_SET_DATA_PACKET: byte;
        /**  */
        CLIENT_CACHE_STATUS_PACKET: byte;
        /**  */
        SET_TIME_PACKET: byte;
        /**  */
        CONTAINER_OPEN_PACKET: byte;
        /**  */
        RESOURCE_PACK_CHUNK_REQUEST_PACKET: byte;
        /**  */
        INVENTORY_TRANSACTION_PACKET: byte;
        /**  */
        RESOURCE_PACK_CHUNK_DATA_PACKET: byte;
        /**  */
        SET_SCOREBOARD_IDENTITY_PACKET: byte;
        /**  */
        RESPAWN_PACKET: byte;
        /**  */
        EVENT_PACKET: byte;
        /**  */
        NETWORK_SETTINGS_PACKET: byte;
        /**  */
        ITEM_STACK_REQUEST_PACKET: byte;
        /**  */
        MOVE_ENTITY_ABSOLUTE_PACKET: byte;
        /**  */
        BLOCK_ENTITY_DATA_PACKET: byte;
        /**  */
        SHOW_CREDITS_PACKET: byte;
        /**  */
        SPAWN_PARTICLE_EFFECT_PACKET: byte;
        /**  */
        REQUEST_CHUNK_RADIUS_PACKET: byte;
        /**  */
        ADD_VOLUME_ENTITY: byte;
        /**  */
        SUPPORTED_PROTOCOLS: java.util.List;
        /**  */
        EMOTE_LIST_PACKET: byte;
        /**  */
        CLIENTBOUND_MAP_ITEM_DATA_PACKET: byte;
        /**  */
        REMOVE_VOLUME_ENTITY_PACKET: byte;
        /**  */
        STRUCTURE_TEMPLATE_DATA_EXPORT_RESPONSE: byte;
        /**  */
        FULL_CHUNK_DATA_PACKET: byte;
        /**  */
        ITEM_STACK_RESPONSE_PACKET: byte;
        /**  */
        CHANGE_DIMENSION_PACKET: byte;
        /**  */
        PHOTO_TRANSFER_PACKET: byte;
        /**  */
        CLIENT_CACHE_BLOB_STATUS_PACKET: byte;
        /**  */
        ITEM_COMPONENT_PACKET: byte;
        /**  */
        BOSS_EVENT_PACKET: byte;
        /**  */
        ADD_ITEM_ENTITY_PACKET: byte;
        /**  */
        NETWORK_CHUNK_PUBLISHER_UPDATE_PACKET: byte;
        /**  */
        LEVEL_EVENT_GENERIC_PACKET: byte;
        /**  */
        SYNC_ENTITY_PROPERTY_PACKET: byte;
        /**  */
        SET_ENTITY_DATA_PACKET: byte;
        /**  */
        ON_SCREEN_TEXTURE_ANIMATION_PACKET: byte;
        /**  */
        SCRIPT_CUSTOM_EVENT_PACKET: byte;
        /**  */
        INITIATE_WEB_SOCKET_CONNECTION_PACKET: byte;
        /**  */
        SERVER_TO_CLIENT_HANDSHAKE_PACKET: byte;
        /**  */
        SPAWN_EXPERIENCE_ORB_PACKET: byte;
        /**  */
        MAP_INFO_REQUEST_PACKET: byte;
        /**  */
        MODAL_FORM_RESPONSE_PACKET: byte;
        /**  */
        MOVE_ENTITY_DELTA_PACKET: byte;
        /**  */
        CODE_BUILDER_PACKET: byte;
        /**  */
        UPDATE_PLAYER_GAME_TYPE_PACKET: byte;
        /**  */
        ADD_BEHAVIOR_TREE_PACKET: byte;
        /**  */
        SET_HEALTH_PACKET: byte;
        /**  */
        ADD_PAINTING_PACKET: byte;
        /**  */
        TEXT_PACKET: byte;
        /**  */
        SET_COMMANDS_ENABLED_PACKET: byte;
        /**  */
        BOOK_EDIT_PACKET: byte;
        /**  */
        MOTION_PREDICTION_HINTS_PACKET: byte;
        /**  */
        MULTIPLAYER_SETTINGS_PACKET: byte;
        /**  */
        POS_TRACKING_CLIENT_REQUEST_PACKET: byte;
        /**  */
        COMPLETED_USING_ITEM_PACKET: byte;
        /**  */
        LEVEL_SOUND_EVENT_PACKET: byte;
        /**  */
        SETTINGS_COMMAND_PACKET: byte;
        /**  */
        UPDATE_SOFT_ENUM_PACKET: byte;
        /**  */
        LOGIN_PACKET: byte;
        /**  */
        ITEM_FRAME_DROP_ITEM_PACKET: byte;
        /**  */
        ENTITY_PICK_REQUEST_PACKET: byte;
        /**  */
        SET_DIFFICULTY_PACKET: byte;
        /**  */
        UPDATE_EQUIPMENT_PACKET: byte;
        /**  */
        CONTAINER_CLOSE_PACKET: byte;
        /**  */
        TAKE_ITEM_ENTITY_PACKET: byte;
        /**  */
        CAMERA_PACKET: byte;
        /**  */
        ADD_VOLUME_ENTITY_PACKET: byte;
        /**  */
        SERVER_SETTINGS_REQUEST_PACKET: byte;
        /**  */
        RIDER_JUMP_PACKET: byte;
        /**  */
        SIMULATION_TYPE_PACKET: byte;
        /**  */
        SET_TITLE_PACKET: byte;
        /**  */
        STRUCTURE_TEMPLATE_DATA_EXPORT_REQUEST: byte;
        /**  */
        CLIENT_TO_SERVER_HANDSHAKE_PACKET: byte;
        /**  */
        PLAYER_SKIN_PACKET: byte;
        /**  */
        PLAY_STATUS_PACKET: byte;
        /**  */
        SET_SPAWN_POSITION_PACKET: byte;
        /**  */
        ADD_ENTITY_PACKET: byte;
        /**  */
        START_GAME_PACKET: byte;
        /**  */
        POS_TRACKING_SERVER_BROADCAST_PACKET: byte;
        /**  */
        PLAYER_ENCHANT_OPTIONS_PACKET: byte;
        /**  */
        MINECRAFT_VERSION: java.lang.String;
        /**  */
        ADVENTURE_SETTINGS_PACKET: byte;
        /**  */
        CHUNK_RADIUS_UPDATED_PACKET: byte;
        /**  */
        SHOW_PROFILE_PACKET: byte;
        /**  */
        EMOTE_PACKET: byte;
        /**  */
        LEVEL_EVENT_PACKET: byte;
        /**  */
        MODAL_FORM_REQUEST_PACKET: byte;
        /**  */
        MOB_EFFECT_PACKET: byte;
        /**  */
        CORRECT_PLAYER_MOVE_PREDICTION_PACKET: byte;
        /**  */
        CURRENT_PROTOCOL: int;
        /**  */
        CRAFTING_EVENT_PACKET: byte;
        /**  */
        DEBUG_INFO_PACKET: byte;
        /**  */
        PLAYER_LIST_PACKET: byte;
        /**  */
        RESOURCE_PACKS_INFO_PACKET: byte;
        /**  */
        STRUCTURE_BLOCK_UPDATE_PACKET: byte;
        /**  */
        ANVIL_DAMAGE_PACKET: byte;
        /**  */
        AVAILABLE_ENTITY_IDENTIFIERS_PACKET: byte;
        /**  */
        RESOURCE_PACK_STACK_PACKET: byte;
        /**  */
        SET_LOCAL_PLAYER_AS_INITIALIZED_PACKET: byte;
        /**  */
        STOP_SOUND_PACKET: byte;
        /**  */
        BLOCK_EVENT_PACKET: byte;
        /**  */
        LECTERN_UPDATE_PACKET: byte;
        /**  */
        SYNC_ENTITY_PROPERTY: byte;
        /**  */
        PLAYER_ARMOR_DAMAGE_PACKET: byte;
        /**  */
        SET_LAST_HURT_BY_PACKET: byte;
        /**  */
        NETWORK_STACK_LATENCY_PACKET: byte;
        /**  */
        ADD_PLAYER_PACKET: byte;
        /**  */
        BATCH_PACKET: byte;
        /**  */
        PLAYER_ACTION_PACKET: byte;
        /**  */
        INVENTORY_SLOT_PACKET: byte;
        /**  */
        PLAYER_HOTBAR_PACKET: byte;
        /**  */
        ENTITY_EVENT_PACKET: byte;
        /**  */
        GAME_RULES_CHANGED_PACKET: byte;
        /**  */
        COMMAND_OUTPUT_PACKET: byte;
        /**  */
        CRAFTING_DATA_PACKET: byte;
        /**  */
        MOB_ARMOR_EQUIPMENT_PACKET: byte;
        /**  */
        AVAILABLE_COMMANDS_PACKET: byte;
        /**  */
        UPDATE_BLOCK_PROPERTIES: byte;
        /**  */
        FILTER_TEXT_PACKET: byte;
        /**  */
        MAP_CREATE_LOCKED_COPY_PACKET: byte;
        /**  */
        UPDATE_ATTRIBUTES_PACKET: byte;
        /**  */
        SHOW_STORE_OFFER_PACKET: byte;
        /**  */
        SIMPLE_EVENT_PACKET: byte;
        /**  */
        REMOVE_VOLUME_ENTITY: byte;
        /**  */
        EDUCATION_SETTINGS_PACKET: byte;
        /**  */
        SET_PLAYER_GAME_TYPE_PACKET: byte;
        /**  */
        PLAY_SOUND_PACKET: byte;
        /**  */
        ENTITY_FALL_PACKET: byte;
        /**  */
        NPC_REQUEST_PACKET: byte;
        /**  */
        SET_DEFAULT_GAME_TYPE_PACKET: byte;
        /**  */
        COMMAND_BLOCK_UPDATE_PACKET: byte;
        /**  */
        VIDEO_STREAM_CONNECT_PACKET: byte;
        /**  */
        REMOVE_ENTITY_PACKET: byte;
        /**  */
        ANIMATE_ENTITY_PACKET: byte;
        /**  */
        TRANSFER_PACKET: byte;
        /**  */
        RESOURCE_PACK_CLIENT_RESPONSE_PACKET: byte;
        /**  */
        INVENTORY_CONTENT_PACKET: byte;
        /**  */
        SUB_CLIENT_LOGIN_PACKET: byte;
        /**  */
        UPDATE_BLOCK_PACKET: byte;
        /**  */
        SERVER_SETTINGS_RESPONSE_PACKET: byte;
        /**  */
        RESOURCE_PACK_DATA_INFO_PACKET: byte;
        /**  */
        BIOME_DEFINITION_LIST_PACKET: byte;
        /**  */
        SET_ENTITY_LINK_PACKET: byte;
        /**  */
        LEVEL_SOUND_EVENT_PACKET_V1: byte;
        /**  */
        SET_ENTITY_MOTION_PACKET: byte;
        /**  */
        LEVEL_SOUND_EVENT_PACKET_V2: byte;
        /**  */
        PACKET_VIOLATION_WARNING_PACKET: byte;
        /**  */
        MOB_EQUIPMENT_PACKET: byte;
        /**  */
        MINECRAFT_VERSION_NETWORK: java.lang.String;
        /**  */
        PLAYER_AUTH_INPUT_PACKET: byte;
        /**  */
        CLIENT_CACHE_MISS_RESPONSE_PACKET: byte;
        /**  */
        HURT_ARMOR_PACKET: byte;
        /**  */
        PLAYER_INPUT_PACKET: byte;
        /**  */
        ANIMATE_PACKET: byte;
        /**  */
        DISCONNECT_PACKET: byte;
        /**  */
        CAMERA_SHAKE_PACKET: byte;
        /**  */
        TICK_SYNC_PACKET: byte;
        /**  */
        INTERACT_PACKET: byte;
        /**  */
        GUI_DATA_PICK_ITEM_PACKET: byte;
        /**  */
        PURCHASE_RECEIPT_PACKET: byte;
        /**  */
        COMMAND_REQUEST_PACKET: byte;
        /**  */
        NPC_DIALOGUE_PACKET: byte;
        /**  */
        BLOCK_PICK_REQUEST_PACKET: byte;
        /**  */
        UPDATE_TRADE_PACKET: byte;
        /**  */
        MOVE_PLAYER_PACKET: byte;
        /**  */
        CREATIVE_CONTENT_PACKET: byte;
        /**  */
        CLIENTBOUND_DEBUG_RENDERER_PACKET: byte;
        /**  */
        PLAYER_FOG_PACKET: byte;
    }
}
declare namespace cn.nukkit.block{
     class BlockAnvil extends cn.nukkit.block.BlockFallableMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        DAMAGE: cn.nukkit.blockproperty.BlockProperty;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getAnvilDamage(): cn.nukkit.blockproperty.value.AnvilDamage;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.AnvilDamage} anvilDamage 
         */
        public setAnvilDamage(anvilDamage: cn.nukkit.blockproperty.value.AnvilDamage): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockConcrete extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.inventory{
     class PlayerUIComponent extends cn.nukkit.inventory.BaseInventory{
        /**  */
        offset: int;
        /**  */
        size: int;
        /**  */
        playerUI: cn.nukkit.inventory.PlayerUIInventory;
        /**  */
        CREATED_ITEM_OUTPUT_UI_SLOT: int;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {int} size 
         */
        public setMaxStackSize(size: int): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} before 
         * @param {boolean} send 
         */
        public onSlotChange(index: int,before: cn.nukkit.item.Item,send: boolean): void;
        /**
         * 
         * @param {int} index 
         * @param {boolean} send 
         */
        public clear(index: int,send: boolean): boolean;
        /**
         * 
         * @param {int} index 
         */
        public getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getViewers(): java.util.Set;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public onClose(who: cn.nukkit.Player): void;
        /**
         * 
         * @param {java.lang.Integer} slot 
         */
        private lambda$getContents$0(slot: java.lang.Integer): boolean;
        /**
         * 
         */
        public getTitle(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public onOpen(who: cn.nukkit.Player): void;
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.InventoryType;
        /**
         * 
         */
        public getContents(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public  sendContents(...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.Player[]} players 
         */
        public  sendSlot(index: int,...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public close(who: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public open(who: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} send 
         */
        public setItem(index: int,item: cn.nukkit.item.Item,send: boolean): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class UpdatePlayerGameTypePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        gameType: cn.nukkit.network.protocol.UpdatePlayerGameTypePacket.GameType;
        /**  */
        NETWORK_ID: byte;
        /**  */
        entityId: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemBeetroot extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.item.enchantment.bow{
     class EnchantmentBowFlame extends cn.nukkit.item.enchantment.bow.EnchantmentBow{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemFish extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityMinecartChest extends cn.nukkit.entity.item.EntityMinecartAbstract{
        /**  */
        NETWORK_ID: int;
        /**  */
        inventory: cn.nukkit.inventory.MinecartChestInventory;
        /**
         * 
         */
        public dropItem(): void;
        /**
         * 
         */
        public isRideable(): boolean;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getType(): cn.nukkit.utils.MinecartType;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {byte} mode 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity,mode: byte): boolean;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.MinecartChestInventory;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemPrismarineCrystals extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.format.generic{
    abstract class BaseLevelProvider extends java.lang.Object{
        /**  */
        path: java.lang.String;
        /**  */
        spawn: cn.nukkit.math.Vector3;
        /**  */
        regions: it.unimi.dsi.fastutil.longs.Long2ObjectMap;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        level: cn.nukkit.level.Level;
        /**  */
        chunks: it.unimi.dsi.fastutil.longs.Long2ObjectMap;
        /**  */
        lastChunk: java.util.concurrent.atomic.AtomicReference;
        /**  */
        lastRegion: java.util.concurrent.atomic.AtomicReference;
        /**  */
        levelData: cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getTime(): long;
        /**
         * 
         */
        public doGarbageCollection(): void;
        /**
         * 
         */
        public getRainTime(): int;
        /**
         * 
         * @param {boolean} raining 
         */
        public setRaining(raining: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setSpawn(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {long} index 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        public putChunk(index: long,chunk: cn.nukkit.level.format.generic.BaseFullChunk): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public isChunkPopulated(chunkX: int,chunkZ: int): boolean;
        /**
         * 
         */
        public getGeneratorOptions(): java.util.Map;
        /**
         * 
         */
        public saveChunks(): void;
        /**
         * 
         */
        public saveLevelData(): void;
        /**
         * 
         */
        public getGenerator(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.level.GameRules} rules 
         */
        public setGameRules(rules: cn.nukkit.level.GameRules): void;
        /**
         * 
         * @param {int} chunkX 
         */
        protected static getRegionIndexX(chunkX: int): int;
        /**
         * 
         */
        public getThunderTime(): int;
        /**
         * 
         * @param {int} chunkZ 
         */
        protected static getRegionIndexZ(chunkZ: int): int;
        /**
         * 
         */
        public getPath(): java.lang.String;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getLoadedChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {long} hash 
         */
        public getLoadedChunk(hash: long): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public  close(): void;
        /**
         * 
         * @param {long} value 
         */
        public setTime(value: long): void;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         */
        public getSeed(): long;
        /**
         * 
         */
        public getSpawn(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {boolean} create 
         */
        public loadChunk(chunkX: int,chunkZ: int,create: boolean): boolean;
        /**
         * 
         * @param {long} index 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {boolean} create 
         */
        public abstract loadChunk(index: long,chunkX: int,chunkZ: int,create: boolean): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public loadChunk(chunkX: int,chunkZ: int): boolean;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {long} currentTick 
         */
        public setCurrentTick(currentTick: long): void;
        /**
         * 
         */
        public unloadChunks(): void;
        /**
         * 
         */
        public getGamerules(): cn.nukkit.level.GameRules;
        /**
         * 
         */
        public getLoadedChunks(): java.util.Map;
        /**
         * 
         * @param {java.io.File} file 
         */
        private lambda$saveLevelData$0(file: java.io.File): void;
        /**
         * 
         */
        public getCurrentTick(): long;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public isChunkLoaded(X: int,Z: int): boolean;
        /**
         * 
         * @param {long} hash 
         */
        public isChunkLoaded(hash: long): boolean;
        /**
         * 
         */
        public getLevel(): cn.nukkit.level.Level;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public isChunkGenerated(chunkX: int,chunkZ: int): boolean;
        /**
         * 
         */
        public size(): int;
        /**
         * 
         * @param {int} rainTime 
         */
        public setRainTime(rainTime: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getRegion(x: int,z: int): cn.nukkit.level.format.generic.BaseRegionLoader;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {boolean} create 
         */
        public getChunk(chunkX: int,chunkZ: int,create: boolean): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public getLevelData(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isThundering(): boolean;
        /**
         * 
         * @param {boolean} thundering 
         */
        public setThundering(thundering: boolean): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         * @param {boolean} safe 
         */
        public unloadChunk(X: int,Z: int,safe: boolean): boolean;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public unloadChunk(X: int,Z: int): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public updateLevelName(name: java.lang.String): void;
        /**
         * 
         * @param {long} value 
         */
        public setSeed(value: long): void;
        /**
         * 
         */
        public isRaining(): boolean;
        /**
         * 
         * @param {int} thunderTime 
         */
        public setThunderTime(thunderTime: int): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockBed extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        OCCUPIED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        HEAD_PIECE: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isBedValid(): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public isOccupied(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onActivate(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getFootPart(): cn.nukkit.block.BlockBed;
        /**
         * 
         * @param {boolean} headPiece 
         */
        public setHeadPiece(headPiece: boolean): void;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {boolean} occupied 
         */
        public setOccupied(occupied: boolean): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public  clone(): cn.nukkit.positiontracking.NamedPosition;
        /**
         * 
         */
        public  clone(): cn.nukkit.block.Block;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public clone(): cn.nukkit.block.BlockBed;
        /**
         * 
         */
        public  clone(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public isHeadPiece(): boolean;
        /**
         * 
         */
        public getHeadPart(): cn.nukkit.block.BlockBed;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityZombieVillager extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.data{
     class StringEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        data: java.lang.String;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.String} data 
         */
        public setData(data: java.lang.String): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): java.lang.String;
    }
}
declare namespace cn.nukkit.math{
     class Vector3f extends java.lang.Object{
        /**  */
        SIDE_NORTH: int;
        /**  */
        SIDE_SOUTH: int;
        /**  */
        SIDE_EAST: int;
        /**  */
        SIDE_UP: int;
        /**  */
        SIDE_WEST: int;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        SIDE_DOWN: int;
        /**
         * 
         */
        public rawHashCode(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} pos 
         */
        public distance(pos: cn.nukkit.math.Vector3f): double;
        /**
         * 
         * @param {int} side 
         */
        public static getOppositeSide(side: int): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} v 
         */
        public dot(v: cn.nukkit.math.Vector3f): float;
        /**
         * 
         */
        public getFloorY(): int;
        /**
         * 
         * @param {int} side 
         */
        public getSide(side: int): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {int} side 
         * @param {int} step 
         */
        public getSide(side: int,step: int): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         * @param {float} z 
         */
        public maxPlainDistance(x: float,z: float): float;
        /**
         * 
         */
        public maxPlainDistance(): float;
        /**
         * 
         * @param {float} x 
         */
        public maxPlainDistance(x: float): float;
        /**
         * 
         * @param {cn.nukkit.math.Vector2f} vector 
         */
        public maxPlainDistance(vector: cn.nukkit.math.Vector2f): float;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} x 
         */
        public maxPlainDistance(x: cn.nukkit.math.Vector3f): float;
        /**
         * 
         */
        public getFloorX(): int;
        /**
         * 
         */
        public getUp(): float;
        /**
         * 
         */
        public asVector3(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getFloorZ(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} pos 
         */
        public distanceSquared(pos: cn.nukkit.math.Vector3f): double;
        /**
         * 
         */
        public normalize(): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} number 
         */
        public divide(number: float): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public floor(): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} number 
         */
        public multiply(number: float): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} v 
         * @param {float} y 
         */
        public getIntermediateWithYValue(v: cn.nukkit.math.Vector3f,y: float): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public add(x: float,y: float,z: float): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} x 
         */
        public add(x: cn.nukkit.math.Vector3f): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         */
        public add(x: float,y: float): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         */
        public add(x: float): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public setComponents(x: float,y: float,z: float): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public asBlockVector3(): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public getWest(): float;
        /**
         * 
         */
        public lengthSquared(): float;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} x 
         */
        public subtract(x: cn.nukkit.math.Vector3f): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public subtract(x: float,y: float,z: float): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public subtract(): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         */
        public subtract(x: float): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         */
        public subtract(x: float,y: float): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public length(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} v 
         */
        public cross(v: cn.nukkit.math.Vector3f): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace.Axis} axis 
         */
        public getAxis(axis: cn.nukkit.math.BlockFace.Axis): float;
        /**
         * 
         */
        public ceil(): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} v 
         * @param {float} z 
         */
        public getIntermediateWithZValue(v: cn.nukkit.math.Vector3f,z: float): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getSouth(): float;
        /**
         * 
         */
        public getX(): float;
        /**
         * 
         */
        public abs(): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getY(): float;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} v 
         * @param {float} x 
         */
        public getIntermediateWithXValue(v: cn.nukkit.math.Vector3f,x: float): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getRight(): float;
        /**
         * 
         */
        public round(): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getZ(): float;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public clone(): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getForward(): float;
    }
}
declare namespace cn.nukkit.metadata{
     class EntityMetadataStore extends cn.nukkit.metadata.MetadataStore{
        /**
         * 
         * @param {cn.nukkit.metadata.Metadatable} entity 
         * @param {java.lang.String} metadataKey 
         */
        protected disambiguate(entity: cn.nukkit.metadata.Metadatable,metadataKey: java.lang.String): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsQuartz extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemClock extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedLime extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.biome.type{
    abstract class WateryBiome extends cn.nukkit.level.biome.type.CoveredBiome{
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundDepth(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getGroundBlock(y: int): int;
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceDepth(y: int): int;
    }
}
declare namespace cn.nukkit.event.server{
     class PlayerDataSerializeEvent extends cn.nukkit.event.server.ServerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        name: java.util.Optional;
        /**  */
        serializer: cn.nukkit.utils.PlayerDataSerializer;
        /**  */
        uuid: java.util.Optional;
        /**
         * 
         */
        public getName(): java.util.Optional;
        /**
         * 
         */
        public getSerializer(): cn.nukkit.utils.PlayerDataSerializer;
        /**
         * 
         * @param {cn.nukkit.utils.PlayerDataSerializer} serializer 
         */
        public setSerializer(serializer: cn.nukkit.utils.PlayerDataSerializer): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getUuid(): java.util.Optional;
    }
}
declare namespace cn.nukkit.block{
     class BlockWall extends cn.nukkit.block.BlockWallBase{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        MOSSY_WALL: int;
        /**  */
        WALL_BLOCK_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        NONE_MOSSY_WALL: int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.block.BlockWall.WallType} type 
         */
        public setWallType(type: cn.nukkit.block.BlockWall.WallType): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getWallType(): cn.nukkit.block.BlockWall.WallType;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerCreationEvent extends cn.nukkit.event.Event{
        /**  */
        playerClass: java.lang.Class;
        /**  */
        clientId: java.lang.Long;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        baseClass: java.lang.Class;
        /**  */
        interfaz: cn.nukkit.network.SourceInterface;
        /**  */
        socketAddress: java.net.InetSocketAddress;
        /**
         * 
         */
        public getInterface(): cn.nukkit.network.SourceInterface;
        /**
         * 
         */
        public getPort(): int;
        /**
         * 
         */
        public getClientId(): java.lang.Long;
        /**
         * 
         */
        public getSocketAddress(): java.net.InetSocketAddress;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {java.lang.Class} playerClass 
         */
        public setPlayerClass(playerClass: java.lang.Class): void;
        /**
         * 
         */
        public getAddress(): java.lang.String;
        /**
         * 
         */
        public getBaseClass(): java.lang.Class;
        /**
         * 
         * @param {java.lang.Class} baseClass 
         */
        public setBaseClass(baseClass: java.lang.Class): void;
        /**
         * 
         */
        public getPlayerClass(): java.lang.Class;
    }
}
declare namespace cn.nukkit.math{
     class MathHelper extends java.lang.Object{
        /**  */
        a: float[];
        /**
         * 
         * @param {float} f 
         */
        public static floor_float_int(f: float): int;
        /**
         * 
         * @param {double} first 
         * @param {double} second 
         * @param {double} third 
         * @param {double} fourth 
         */
        public static max(first: double,second: double,third: double,fourth: double): double;
        /**
         * 
         * @param {float} paramFloat 
         */
        public static cos(paramFloat: float): float;
        /**
         * 
         * @param {double} paramFloat 
         */
        public static cos(paramFloat: double): float;
        /**
         * 
         * @param {double} lowerBnd 
         * @param {double} upperBnd 
         * @param {double} slide 
         */
        public static denormalizeClamp(lowerBnd: double,upperBnd: double,slide: double): double;
        /**
         * 
         * @param {float} lowerBnd 
         * @param {float} upperBnd 
         * @param {float} slide 
         */
        public static denormalizeClamp(lowerBnd: float,upperBnd: float,slide: float): float;
        /**
         * 
         * @param {float} floatNumber 
         */
        public static ceil(floatNumber: float): int;
        /**
         * 
         * @param {double} d 
         */
        public static floor_double_long(d: double): long;
        /**
         * 
         * @param {int} number 
         */
        public static abs(number: int): int;
        /**
         * 
         * @param {float} paramFloat 
         */
        public static sqrt(paramFloat: float): float;
        /**
         * 
         * @param {float} paramFloat 
         */
        public static sin(paramFloat: float): float;
        /**
         * 
         * @param {double} paramFloat 
         */
        public static sin(paramFloat: double): float;
        /**
         * 
         * @param {java.util.Random} random 
         * @param {int} min 
         * @param {int} max 
         */
        public static getRandomNumberInRange(random: java.util.Random,min: int,max: int): int;
        /**
         * 
         * @param {double} d0 
         */
        public static floor(d0: double): int;
        /**
         * 
         * @param {int} bits 
         */
        public static log2(bits: int): int;
        /**
         * 
         * @param {int} check 
         * @param {int} min 
         * @param {int} max 
         */
        public static clamp(check: int,min: int,max: int): int;
        /**
         * 
         * @param {float} num 
         * @param {float} min 
         * @param {float} max 
         */
        public static clamp(num: float,min: float,max: float): float;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityVillagerV1 extends cn.nukkit.entity.EntityCreature{
        /**  */
        NETWORK_ID: int;
        /**  */
        PROFESSION_FARMER: int;
        /**  */
        PROFESSION_LIBRARIAN: int;
        /**  */
        PROFESSION_GENERIC: int;
        /**  */
        PROFESSION_BLACKSMITH: int;
        /**  */
        PROFESSION_BUTCHER: int;
        /**  */
        PROFESSION_PRIEST: int;
        /**
         * 
         */
        public isBaby(): boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {int} profession 
         */
        public setProfession(profession: int): void;
        /**
         * 
         */
        public getProfession(): int;
    }
}
declare namespace cn.nukkit.command.defaults{
     class VersionCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {java.lang.String[]} authorsString 
         * @param {java.lang.String} s 
         */
        private static lambda$execute$1(authorsString: java.lang.String[],s: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} finalPluginName 
         * @param {cn.nukkit.plugin.Plugin[]} exactPlugin 
         * @param {boolean[]} found 
         * @param {java.lang.String} s 
         * @param {cn.nukkit.plugin.Plugin} p 
         */
        private static lambda$execute$0(finalPluginName: java.lang.String,exactPlugin: cn.nukkit.plugin.Plugin[],found: boolean[],s: java.lang.String,p: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.level.particle{
     class SporeParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityVehicleEnterEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        vehicle: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getVehicle(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.block{
     class BlockStonecutter extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.permission{
     class Permission extends java.lang.Object{
        /**  */
        DEFAULT_OP: java.lang.String;
        /**  */
        DEFAULT_TRUE: java.lang.String;
        /**  */
        DEFAULT_FALSE: java.lang.String;
        /**  */
        children: java.util.Map;
        /**  */
        defaultValue: java.lang.String;
        /**  */
        name: java.lang.String;
        /**  */
        description: java.lang.String;
        /**  */
        DEFAULT_NOT_OP: java.lang.String;
        /**  */
        DEFAULT_PERMISSION: java.lang.String;
        /**
         * 
         */
        public getChildren(): java.util.Map;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public recalculatePermissibles(): void;
        /**
         * 
         */
        public getPermissibles(): java.util.Set;
        /**
         * 
         * @param {java.lang.String} value 
         */
        public static getByName(value: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.Map} data 
         * @param {java.lang.String} defaultValue 
         */
        public static loadPermission(name: java.lang.String,data: java.util.Map,defaultValue: java.lang.String): cn.nukkit.permission.Permission;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.Map} data 
         * @param {java.lang.String} defaultValue 
         * @param {java.util.List} output 
         */
        public static loadPermission(name: java.lang.String,data: java.util.Map,defaultValue: java.lang.String,output: java.util.List): cn.nukkit.permission.Permission;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.Map} data 
         */
        public static loadPermission(name: java.lang.String,data: java.util.Map): cn.nukkit.permission.Permission;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         * @param {boolean} value 
         */
        public addParent(permission: cn.nukkit.permission.Permission,value: boolean): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {boolean} value 
         */
        public addParent(name: java.lang.String,value: boolean): cn.nukkit.permission.Permission;
        /**
         * 
         */
        public getDefault(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} description 
         */
        public setDescription(description: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} value 
         */
        public setDefault(value: java.lang.String): void;
        /**
         * 
         */
        public getDescription(): java.lang.String;
        /**
         * 
         * @param {java.util.Map} data 
         * @param {java.lang.String} defaultValue 
         */
        public static loadPermissions(data: java.util.Map,defaultValue: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.util.Map} data 
         */
        public static loadPermissions(data: java.util.Map): java.util.List;
    }
}
declare namespace cn.nukkit.item{
     class ItemMelonGlistering extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityDonkey extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace gameapi{
    /**
     * 
     * @param {com.blocklynukkit.gameAPI.Scoreboard.Scoreboard} sb 
     * @param {java.lang.String} objectiveName 
     * @param {java.lang.String} displayName 
     */
    function setObjective(sb: com.blocklynukkit.gameAPI.Scoreboard.Scoreboard,objectiveName: java.lang.String,displayName: java.lang.String): void;
    /**
     * 
     * @param {com.blocklynukkit.gameAPI.Menu.Form.FormMenu} menu 
     * @param {java.lang.String} buttonText 
     * @param {java.lang.String} imageData 
     * @param {java.lang.String} formCallback 
     */
    function addMenuButton(menu: com.blocklynukkit.gameAPI.Menu.Form.FormMenu,buttonText: java.lang.String,imageData: java.lang.String,formCallback: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} title 
     * @param {java.lang.String} content 
     */
    function createFormMenu(title: java.lang.String,content: java.lang.String): com.blocklynukkit.gameAPI.Menu.Form.FormMenu;
    /**
     * 
     * @param {java.lang.String} prefix 
     */
    function getMessager(prefix: java.lang.String): com.blocklynukkit.gameAPI.Language.Messager;
    /**
     * 
     * @param {cn.nukkit.Player} player 
     * @param {java.lang.String} gameName 
     */
    function joinGame(player: cn.nukkit.Player,gameName: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} messageType 
     */
    function getMultiline(messageType: java.lang.String): com.blocklynukkit.gameAPI.Language.Multiline;
    /**
     * 
     * @param {java.lang.String} gameName 
     */
    function getAllRoomByName(gameName: java.lang.String): java.util.List;
    /**
     * 
     */
    function getAllGameNames(): java.util.List;
    /**
     * 
     * @param {cn.nukkit.Player} player 
     */
    function leaveGame(player: cn.nukkit.Player): void;
    /**
     * 
     * @param {java.lang.String} name 
     * @param {boolean} useTeam 
     * @param {java.lang.String} startGameCallBack 
     * @param {java.lang.String} endGameCallBack 
     * @param {java.lang.String} mainLoopCallBack 
     * @param {java.lang.String} deathCallBack 
     */
    function createGame(name: java.lang.String,useTeam: boolean,startGameCallBack: java.lang.String,endGameCallBack: java.lang.String,mainLoopCallBack: java.lang.String,deathCallBack: java.lang.String): void;
    /**
     * 
     * @param {com.blocklynukkit.gameAPI.Menu.Inventory.InventoryMenu} menu 
     * @param {int} slot 
     * @param {cn.nukkit.item.Item} item 
     * @param {java.lang.String} inventoryCallback 
     */
    function addMenuItem(menu: com.blocklynukkit.gameAPI.Menu.Inventory.InventoryMenu,slot: int,item: cn.nukkit.item.Item,inventoryCallback: java.lang.String): void;
    /**
     * 
     * @param {cn.nukkit.Player} player 
     */
    function getPlayerRoom(player: cn.nukkit.Player): com.blocklynukkit.gameAPI.GameBase;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 
     * @param {cn.nukkit.Player} p 
     */
    function getScoreboard(p: cn.nukkit.Player): com.blocklynukkit.gameAPI.Scoreboard.Scoreboard;
    /**
     * 
     * @param {com.blocklynukkit.gameAPI.GameBase} game 
     */
    function getGameMessager(game: com.blocklynukkit.gameAPI.GameBase): com.blocklynukkit.gameAPI.Language.Messager;
    /**
     * 
     * @param {java.lang.String} inventoryType 
     * @param {java.lang.String} title 
     */
    function createInventoryMenu(inventoryType: java.lang.String,title: java.lang.String): com.blocklynukkit.gameAPI.Menu.Inventory.InventoryMenu;
    /**
     * 
     * @param {cn.nukkit.Player} player 
     */
    function isPlayerInGame(player: cn.nukkit.Player): boolean;
}
declare namespace cn.nukkit.block{
     class BlockLadder extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        offMaxX: double;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        offMinZ: double;
        /**  */
        offMinX: double;
        /**  */
        offMaxZ: double;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {int} meta 
         */
        public setDamage(meta: int): void;
        /**
         * 
         */
        public canBeClimbed(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        private calculateOffsets(): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         * @param {cn.nukkit.block.Block} support 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        private isSupportValid(support: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace): boolean;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class ListTag extends cn.nukkit.nbt.tag.Tag{
        /**  */
        list: java.util.List;
        /**  */
        type: byte;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        public add(tag: cn.nukkit.nbt.tag.Tag): cn.nukkit.nbt.tag.ListTag;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        public add(index: int,tag: cn.nukkit.nbt.tag.Tag): cn.nukkit.nbt.tag.ListTag;
        /**
         * 
         * @param {java.util.StringJoiner} joiner 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        private static lambda$toString$0(joiner: java.util.StringJoiner,tag: cn.nukkit.nbt.tag.Tag): void;
        /**
         * 
         */
        public getAll(): java.util.List;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        public remove(tag: cn.nukkit.nbt.tag.Tag): void;
        /**
         * 
         * @param {int} index 
         */
        public remove(index: int): void;
        /**
         * 
         * @param {java.lang.String} prefix 
         * @param {java.io.PrintStream} out 
         */
        public print(prefix: java.lang.String,out: java.io.PrintStream): void;
        /**
         * 
         * @param {java.util.Collection} tags 
         */
        public removeAll(tags: java.util.Collection): void;
        /**
         * 
         */
        public size(): int;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {int} index 
         */
        public get(index: int): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         */
        public parseValue(): java.util.List;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         * @param {java.util.List} tags 
         */
        public setAll(tags: java.util.List): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsDarkOak extends cn.nukkit.block.BlockStairsWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class ExplodeParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.inventory{
     class ShapelessRecipe extends java.lang.Object{
        /**  */
        output: cn.nukkit.item.Item;
        /**  */
        most: long;
        /**  */
        least: long;
        /**  */
        ingredients: java.util.List;
        /**  */
        priority: int;
        /**  */
        ingredientsAggregate: java.util.List;
        /**  */
        recipeId: java.lang.String;
        /**
         * 
         */
        public requiresCraftingTable(): boolean;
        /**
         * 
         */
        public getIngredientsAggregate(): java.util.List;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingManager} manager 
         */
        public registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void;
        /**
         * 
         */
        public getId(): java.util.UUID;
        /**
         * 
         */
        public getIngredientList(): java.util.List;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {java.util.List} extraOutputList 
         * @param {int} multiplier 
         */
        public matchItems(inputList: java.util.List,extraOutputList: java.util.List,multiplier: int): boolean;
        /**
         * 
         * @param {java.util.List} inputList 
         * @param {java.util.List} extraOutputList 
         */
        public matchItems(inputList: java.util.List,extraOutputList: java.util.List): boolean;
        /**
         * 
         */
        public getExtraResults(): java.util.List;
        /**
         * 
         */
        public getType(): cn.nukkit.inventory.RecipeType;
        /**
         * 
         */
        public getResult(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getPriority(): int;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public setId(uuid: java.util.UUID): void;
        /**
         * 
         */
        public getAllResults(): java.util.List;
        /**
         * 
         */
        public getRecipeId(): java.lang.String;
        /**
         * 
         */
        public getIngredientCount(): int;
    }
}
declare namespace cn.nukkit.nbt.stream{
     class PGZIPOutputStream extends java.io.FilterOutputStream{
        /**  */
        bytesWritten: int;
        /**  */
        emitQueue: java.util.concurrent.BlockingQueue;
        /**  */
        blockSizes: it.unimi.dsi.fastutil.ints.IntList;
        /**  */
        GZIP_MAGIC: int;
        /**  */
        level: int;
        /**  */
        crc: java.util.zip.CRC32;
        /**  */
        executor: java.util.concurrent.ExecutorService;
        /**  */
        EXECUTOR: java.util.concurrent.ExecutorService;
        /**  */
        nthreads: int;
        /**  */
        block: cn.nukkit.nbt.stream.PGZIPBlock;
        /**  */
        strategy: int;
        /**
         * 
         */
        private writeHeader(): void;
        /**
         * 
         */
        private submit(): void;
        /**
         * 
         */
        protected newDeflater(): java.util.zip.Deflater;
        /**
         * 
         * @param {int} taskCountAllowed 
         */
        private emitUntil(taskCountAllowed: int): void;
        /**
         * 
         */
        private tryEmit(): void;
        /**
         * 
         * @param {int} level 
         */
        public setLevel(level: int): void;
        /**
         * 
         */
        public flush(): void;
        /**
         * 
         * @param {java.io.OutputStream} out 
         * @param {java.util.zip.Deflater} deflater 
         */
        protected static newDeflaterOutputStream(out: java.io.OutputStream,deflater: java.util.zip.Deflater): java.util.zip.DeflaterOutputStream;
        /**
         * 
         * @param {int} strategy 
         */
        public setStrategy(strategy: int): void;
        /**
         * 
         */
        public finish(): void;
        /**
         * 
         * @param {byte[]} b 
         */
        public write(b: byte[]): void;
        /**
         * 
         * @param {byte[]} b 
         * @param {int} off 
         * @param {int} len 
         */
        public write(b: byte[],off: int,len: int): void;
        /**
         * 
         * @param {int} b 
         */
        public write(b: int): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public static getSharedThreadPool(): java.util.concurrent.ExecutorService;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsStoneBrick extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockQuartz extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        QUARTZ_CHISELED: int;
        /**  */
        QUARTZ_NORMAL: int;
        /**  */
        QUARTZ_PILLAR: int;
        /**  */
        QUARTZ_PILLAR2: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntitySpider extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetSpawnPositionPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        spawnType: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        TYPE_PLAYER_SPAWN: int;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        TYPE_WORLD_SPAWN: int;
        /**  */
        z: int;
        /**  */
        dimension: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class EntityFallPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        NETWORK_ID: byte;
        /**  */
        fallDistance: float;
        /**  */
        unknown: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MapInfoRequestPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        mapId: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class RequestChunkRadiusPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        radius: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorDoublePlant extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**  */
        type: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        protected placeBlock(x: int,y: int,z: int,id: int,chunk: cn.nukkit.level.format.FullChunk,random: cn.nukkit.math.NukkitRandom): void;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityXPOrb extends cn.nukkit.entity.Entity{
        /**  */
        pickupDelay: int;
        /**  */
        NETWORK_ID: int;
        /**  */
        closestPlayer: cn.nukkit.Player;
        /**  */
        exp: int;
        /**  */
        ORB_SPLIT_SIZES: int[];
        /**  */
        age: int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {int} amount 
         */
        public static splitIntoOrbSizes(amount: int): java.util.List;
        /**
         * 
         * @param {int} pickupDelay 
         */
        public setPickupDelay(pickupDelay: int): void;
        /**
         * 
         */
        public canCollide(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        public getExp(): int;
        /**
         * 
         */
        public getPickupDelay(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {int} amount 
         */
        public static getMaxOrbSize(amount: int): int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         * @param {int} exp 
         */
        public setExp(exp: int): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
    }
}
declare namespace cn.nukkit.item.enchantment.protection{
     class EnchantmentProtectionAll extends cn.nukkit.item.enchantment.protection.EnchantmentProtection{
        /**
         * 
         */
        public getTypeModifier(): double;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} e 
         */
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemString extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorIron extends cn.nukkit.block.BlockDoor{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockDaylightDetectorInverted extends cn.nukkit.block.BlockDaylightDetector{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isInverted(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.level.generator.noise.vanilla.f{
     class NoiseGeneratorOctavesF extends java.lang.Object{
        /**  */
        octaves: int;
        /**  */
        generatorCollection: cn.nukkit.level.generator.noise.vanilla.f.NoiseGeneratorImprovedF[];
        /**
         * 
         * @param {float[]} noiseArray 
         * @param {int} xOffset 
         * @param {int} yOffset 
         * @param {int} zOffset 
         * @param {int} xSize 
         * @param {int} ySize 
         * @param {int} zSize 
         * @param {float} xScale 
         * @param {float} yScale 
         * @param {float} zScale 
         */
        public generateNoiseOctaves(noiseArray: float[],xOffset: int,yOffset: int,zOffset: int,xSize: int,ySize: int,zSize: int,xScale: float,yScale: float,zScale: float): float[];
        /**
         * 
         * @param {float[]} noiseArray 
         * @param {int} xOffset 
         * @param {int} zOffset 
         * @param {int} xSize 
         * @param {int} zSize 
         * @param {float} xScale 
         * @param {float} zScale 
         * @param {float} p_76305_10_ 
         */
        public generateNoiseOctaves(noiseArray: float[],xOffset: int,zOffset: int,xSize: int,zSize: int,xScale: float,zScale: float,p_76305_10_: float): float[];
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityPainting extends cn.nukkit.entity.EntityHanging{
        /**  */
        motive: cn.nukkit.entity.item.EntityPainting.Motive;
        /**  */
        NETWORK_ID: int;
        /**  */
        motives: cn.nukkit.entity.item.EntityPainting.Motive[];
        /**  */
        width: float;
        /**  */
        length: float;
        /**  */
        height: float;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityPistonArm} piston 
         */
        public onPushByPiston(piston: cn.nukkit.blockentity.BlockEntityPistonArm): void;
        /**
         * 
         */
        public getArt(): cn.nukkit.entity.item.EntityPainting.Motive;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getMotive(name: java.lang.String): cn.nukkit.entity.item.EntityPainting.Motive;
        /**
         * 
         */
        public getMotive(): cn.nukkit.entity.item.EntityPainting.Motive;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.extremehills{
     class ExtremeHillsBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public doesOverhang(): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.extremehills{
     class ExtremeHillsMBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsPlusBiome{
        /**  */
        gravelNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        STATE_GRASS: cn.nukkit.blockstate.BlockState;
        /**  */
        STATE_GRAVEL: cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getGroundDepth(x: int,y: int,z: int): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceDepth(x: int,y: int,z: int): int;
        /**
         * 
         */
        public doesOverhang(): boolean;
    }
}
declare namespace cn.nukkit.entity.weather{
    abstract class EntityLightningStrike extends java.lang.Object{
        /**
         * 
         * @param {boolean} e 
         */
        public abstract setEffect(e: boolean): void;
        /**
         * 
         */
        public abstract isEffect(): boolean;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockSolidMeta extends cn.nukkit.block.BlockMeta{
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ShowProfilePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        xuid: java.lang.String;
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.resourcepacks{
     class ZippedResourcePack extends cn.nukkit.resourcepacks.AbstractResourcePack{
        /**  */
        file: java.io.File;
        /**  */
        sha256: byte[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         * @param {java.util.zip.ZipEntry} e 
         */
        private static lambda$new$0(e: java.util.zip.ZipEntry): boolean;
        /**
         * 
         */
        public getPackSize(): int;
        /**
         * 
         */
        public getSha256(): byte[];
        /**
         * 
         */
        private static lambda$new$2(): java.lang.IllegalArgumentException;
        /**
         * 
         * @param {int} off 
         * @param {int} len 
         */
        public getPackChunk(off: int,len: int): byte[];
        /**
         * 
         * @param {java.util.zip.ZipEntry} e 
         */
        private static lambda$new$1(e: java.util.zip.ZipEntry): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ResourcePackClientResponsePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        packEntries: cn.nukkit.network.protocol.ResourcePackClientResponsePacket.Entry[];
        /**  */
        STATUS_SEND_PACKS: byte;
        /**  */
        STATUS_HAVE_ALL_PACKS: byte;
        /**  */
        responseStatus: byte;
        /**  */
        STATUS_REFUSED: byte;
        /**  */
        STATUS_COMPLETED: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item.enchantment.bow{
     class EnchantmentBowInfinity extends cn.nukkit.item.enchantment.bow.EnchantmentBow{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        protected checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace com.blocklynukkit.loader.other.lizi{
     class bnqqbot extends java.lang.Object{
        /**  */
        random: java.util.Random;
        /**  */
        qqid: int;
        /**
         * 
         * @param {java.lang.String} fromQQ 
         * @param {java.lang.String} toGroup 
         * @param {java.lang.String} toQQ 
         * @param {int} second 
         */
        public banSpeakGroupMember(fromQQ: java.lang.String,toGroup: java.lang.String,toQQ: java.lang.String,second: int): void;
        /**
         * 
         * @param {java.lang.String} fromQQ 
         * @param {java.lang.String} toGroup 
         * @param {java.lang.String} toQQ 
         */
        public kickGroupMember(fromQQ: java.lang.String,toGroup: java.lang.String,toQQ: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} fromQQ 
         * @param {java.lang.String} toGroup 
         * @param {java.lang.String} message 
         */
        public sendGroupMessage(fromQQ: java.lang.String,toGroup: java.lang.String,message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} ip 
         */
        public reDirectBot(ip: java.lang.String): void;
        /**
         * 
         */
        public startBot(): void;
        /**
         * 
         */
        public stopBot(): void;
        /**
         * 
         * @param {java.lang.String} fromQQ 
         * @param {java.lang.String} toQQ 
         * @param {java.lang.String} message 
         */
        public sendFriendMessage(fromQQ: java.lang.String,toQQ: java.lang.String,message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} fromQQ 
         * @param {java.lang.String} toGroup 
         * @param {java.lang.String} picturePaths 
         * @param {java.lang.String} message 
         */
        public sendGroupPicMessage(fromQQ: java.lang.String,toGroup: java.lang.String,picturePaths: java.lang.String,message: java.lang.String): void;
    }
}
declare namespace cn.nukkit.event.inventory{
     class BrewEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        brewingStand: cn.nukkit.blockentity.BlockEntityBrewingStand;
        /**  */
        ingredient: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        fuel: int;
        /**  */
        potions: cn.nukkit.item.Item[];
        /**
         * 
         * @param {int} index 
         */
        public getPotion(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public getFuel(): int;
        /**
         * 
         */
        public getIngredient(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getBrewingStand(): cn.nukkit.blockentity.BlockEntityBrewingStand;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPotions(): cn.nukkit.item.Item[];
    }
}
declare namespace cn.nukkit.item{
     class ItemBookAndQuill extends cn.nukkit.item.ItemBookWritable{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockEnchantingTable extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.utils{
     class BinaryStream extends java.lang.Object{
        /**  */
        MAX_ARRAY_SIZE: int;
        /**  */
        offset: int;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        count: int;
        /**  */
        buffer: byte[];
        /**
         * 
         */
        public getByte(): int;
        /**
         * 
         * @param {java.lang.Class} clazz 
         * @param {java.util.function.Function} _function 
         */
        public getArray(clazz: java.lang.Class,_function: java.util.function.Function): java.lang.Object[];
        /**
         * 
         * @param {int} minCapacity 
         */
        private static hugeCapacity(minCapacity: int): int;
        /**
         * 
         * @param {long} eid 
         */
        public putEntityUniqueId(eid: long): void;
        /**
         * 
         */
        public getVector3f(): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {long} v 
         */
        public putVarLong(v: long): void;
        /**
         * 
         * @param {byte[]} bytes 
         */
        public put(bytes: byte[]): void;
        /**
         * 
         */
        public getUUID(): java.util.UUID;
        /**
         * 
         * @param {int} offset 
         */
        public setOffset(offset: int): void;
        /**
         * 
         * @param {boolean} bool 
         */
        public putBoolean(bool: boolean): void;
        /**
         * 
         */
        public getCount(): int;
        /**
         * 
         * @param {long} eid 
         */
        public putEntityRuntimeId(eid: long): void;
        /**
         * 
         * @param {java.util.UUID} uuid 
         */
        public putUUID(uuid: java.util.UUID): void;
        /**
         * 
         */
        public getRecipeIngredient(): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} minCapacity 
         */
        private grow(minCapacity: int): void;
        /**
         * 
         * @param {int} i 
         */
        public putInt(i: int): void;
        /**
         * 
         */
        public getUnsignedVarLong(): long;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {java.lang.String} tagName 
         */
        private extractStringList(item: cn.nukkit.item.Item,tagName: java.lang.String): java.util.List;
        /**
         * 
         * @param {int} accuracy 
         */
        public getLFloat(accuracy: int): float;
        /**
         * 
         */
        public getLFloat(): float;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        private readUnknownItem(item: cn.nukkit.item.Item): cn.nukkit.item.Item;
        /**
         * 
         */
        public getEntityLink(): cn.nukkit.network.protocol.types.EntityLink;
        /**
         * 
         */
        public getInt(): int;
        /**
         * 
         * @param {float} v 
         */
        public putFloat(v: float): void;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getEntityRuntimeId(): long;
        /**
         * 
         */
        public reset(): cn.nukkit.utils.BinaryStream;
        /**
         * 
         * @param {int} minCapacity 
         */
        private ensureCapacity(minCapacity: int): void;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         * @param {cn.nukkit.level.GameRules.Value} value 
         */
        private lambda$putGameRules$0(gameRule: cn.nukkit.level.GameRule,value: cn.nukkit.level.GameRules.Value): void;
        /**
         * 
         * @param {long} l 
         */
        public putLLong(l: long): void;
        /**
         * 
         * @param {cn.nukkit.level.GameRules} gameRules 
         */
        public putGameRules(gameRules: cn.nukkit.level.GameRules): void;
        /**
         * 
         * @param {int} triad 
         */
        public putTriad(triad: int): void;
        /**
         * 
         */
        public getImage(): cn.nukkit.utils.SerializedImage;
        /**
         * 
         * @param {int} s 
         */
        public putLShort(s: int): void;
        /**
         * 
         */
        public getVarInt(): int;
        /**
         * 
         * @param {long} v 
         */
        public putUnsignedVarLong(v: long): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        private createFakeUnknownItem(item: cn.nukkit.item.Item): cn.nukkit.item.Item;
        /**
         * 
         */
        public getLShort(): int;
        /**
         * 
         * @param {int} triad 
         */
        public putLTriad(triad: int): void;
        /**
         * 
         */
        public getBuffer(): byte[];
        /**
         * 
         * @param {cn.nukkit.entity.data.Skin} skin 
         */
        public putSkin(skin: cn.nukkit.entity.data.Skin): void;
        /**
         * 
         */
        public getOffset(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public putSlot(item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} instanceItem 
         */
        public putSlot(item: cn.nukkit.item.Item,instanceItem: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public putBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getFloat(): float;
        /**
         * 
         * @param {int} accuracy 
         */
        public getFloat(accuracy: int): float;
        /**
         * 
         * @param {long} l 
         */
        public putLong(l: long): void;
        /**
         * 
         * @param {int} v 
         */
        public putVarInt(v: int): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public putTag(tag: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         */
        public getLTriad(): int;
        /**
         * 
         */
        public getBlockVector3(): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public getVarLong(): long;
        /**
         * 
         * @param {byte} b 
         */
        public putByte(b: byte): void;
        /**
         * 
         * @param {float} v 
         */
        public putLFloat(v: float): void;
        /**
         * 
         */
        public get(): byte[];
        /**
         * 
         * @param {int} len 
         */
        public get(len: int): byte[];
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} v 
         */
        public putSignedBlockPosition(v: cn.nukkit.math.BlockVector3): void;
        /**
         * 
         */
        public getAttributeList(): cn.nukkit.entity.Attribute[];
        /**
         * 
         */
        public getLInt(): int;
        /**
         * 
         */
        public getBoolean(): boolean;
        /**
         * 
         */
        public getEntityUniqueId(): long;
        /**
         * 
         * @param {int} s 
         */
        public putShort(s: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} ingredient 
         */
        public putRecipeIngredient(ingredient: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.entity.Attribute[]} attributes 
         */
        public putAttributeList(attributes: cn.nukkit.entity.Attribute[]): void;
        /**
         * 
         */
        public getLLong(): long;
        /**
         * 
         * @param {cn.nukkit.network.protocol.types.EntityLink} link 
         */
        public putEntityLink(link: cn.nukkit.network.protocol.types.EntityLink): void;
        /**
         * 
         */
        public getShort(): int;
        /**
         * 
         * @param {byte[]} buffer 
         * @param {int} offset 
         */
        public setBuffer(buffer: byte[],offset: int): void;
        /**
         * 
         * @param {byte[]} buffer 
         */
        public setBuffer(buffer: byte[]): void;
        /**
         * 
         * @param {java.lang.String} string 
         */
        public putString(string: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} v 
         */
        public putVector3f(v: cn.nukkit.math.Vector3f): void;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public putVector3f(x: float,y: float,z: float): void;
        /**
         * 
         * @param {cn.nukkit.utils.SerializedImage} image 
         */
        public putImage(image: cn.nukkit.utils.SerializedImage): void;
        /**
         * 
         */
        public getString(): java.lang.String;
        /**
         * 
         */
        public getTag(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getTriad(): int;
        /**
         * 
         * @param {byte[]} b 
         */
        public putByteArray(b: byte[]): void;
        /**
         * 
         */
        public getLong(): long;
        /**
         * 
         */
        public getUnsignedVarInt(): long;
        /**
         * 
         */
        public getSlot(): cn.nukkit.item.Item;
        /**
         * 
         * @param {long} v 
         */
        public putUnsignedVarInt(v: long): void;
        /**
         * 
         * @param {int} i 
         */
        public putLInt(i: int): void;
        /**
         * 
         */
        public getSkin(): cn.nukkit.entity.data.Skin;
        /**
         * 
         */
        public getByteArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public putBlockVector3(x: int,y: int,z: int): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} v 
         */
        public putBlockVector3(v: cn.nukkit.math.BlockVector3): void;
        /**
         * 
         */
        public feof(): boolean;
        /**
         * 
         */
        public getSignedBlockPosition(): cn.nukkit.math.BlockVector3;
    }
}
declare namespace cn.nukkit.level.biome.impl.desert{
     class DesertBiome extends cn.nukkit.level.biome.type.SandyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isDry(): boolean;
    }
}
declare namespace cn.nukkit.level.format{
    abstract class ChunkSection extends java.lang.Object{
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockData(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public abstract setBlock(x: int,y: int,z: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         */
        public abstract setBlock(x: int,y: int,z: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public abstract setBlockLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public abstract setBlockStateAtLayer(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public abstract setFullBlockId(x: int,y: int,z: int,layer: int,fullId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public abstract setFullBlockId(x: int,y: int,z: int,fullId: int): boolean;
        /**
         * 
         * @param {int} contentVersion 
         */
        public setContentVersion(contentVersion: int): void;
        /**
         * 
         */
        public hasBlocks(): boolean;
        /**
         * 
         */
        public compressStorageLayers(): void;
        /**
         * 
         */
        public abstract toNBT(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getFullBlock(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         * @param {int} offsetX 
         * @param {int} offsetZ 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         */
        public scanBlocks(provider: cn.nukkit.level.format.LevelProvider,offsetX: int,offsetZ: int,min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate): java.util.List;
        /**
         * 
         */
        public abstract copy(): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockChangeStateAbove(x: int,y: int,z: int): int;
        /**
         * 
         */
        public abstract isEmpty(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         */
        public abstract getAndSetBlock(x: int,y: int,z: int,layer: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.block.Block} block 
         */
        public abstract getAndSetBlock(x: int,y: int,z: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockState(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public abstract setBlockData(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public abstract setBlockData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         */
        public getContentVersion(): int;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public abstract writeTo(stream: cn.nukkit.utils.BinaryStream): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public abstract setBlockId(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public abstract setBlockId(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public abstract setBlockSkyLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         */
        public delayPaletteUpdates(): void;
        /**
         * 
         */
        public abstract getY(): int;
        /**
         * 
         */
        public abstract getLightArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public getAndSetBlockState(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public abstract getAndSetBlockState(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public abstract getMaximumLayer(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public abstract setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         */
        public abstract setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockState(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public abstract getSkyLightArray(): byte[];
    }
}
declare namespace cn.nukkit.event.inventory{
     class FurnaceSmeltEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        result: cn.nukkit.item.Item;
        /**  */
        furnace: cn.nukkit.blockentity.BlockEntityFurnace;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        source: cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} result 
         */
        public setResult(result: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSource(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getResult(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getFurnace(): cn.nukkit.blockentity.BlockEntityFurnace;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityComparator extends cn.nukkit.blockentity.BlockEntity{
        /**  */
        outputSignal: int;
        /**
         * 
         */
        public getOutputSignal(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         * @param {int} outputSignal 
         */
        public setOutputSignal(outputSignal: int): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsRedSandstone extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.network{
     class CompressBatchedTask extends cn.nukkit.scheduler.AsyncTask{
        /**  */
        data: byte[][];
        /**  */
        level: int;
        /**  */
        finalData: byte[];
        /**  */
        channel: int;
        /**  */
        targets: java.util.List;
        /**
         * 
         * @param {cn.nukkit.Server} server 
         */
        public onCompletion(server: cn.nukkit.Server): void;
        /**
         * 
         */
        public onRun(): void;
    }
}
declare namespace cn.nukkit.event.vehicle{
     class EntityEnterVehicleEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        riding: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public isPlayer(): boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityHusk extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.data{
     class IntPositionEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} data 
         */
        public setData(data: cn.nukkit.math.BlockVector3): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): cn.nukkit.math.BlockVector3;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class IntArrayTag extends cn.nukkit.nbt.tag.Tag{
        /**  */
        data: int[];
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): int[];
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public getData(): int[];
    }
}
declare namespace cn.nukkit.block{
     class BlockSnow extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockObsidian extends cn.nukkit.block.BlockSolid{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.block.Block} newBlock 
         * @param {boolean} update 
         */
        public afterRemoval(newBlock: cn.nukkit.block.Block,update: boolean): void;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemArrow extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorGlowStone extends cn.nukkit.level.generator.populator.type.Populator{
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(chunk: cn.nukkit.level.format.FullChunk,x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerCommandPreprocessEvent extends cn.nukkit.event.player.PlayerMessageEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public setPlayer(player: cn.nukkit.Player): void;
    }
}
declare namespace cn.nukkit.metadata{
     class LevelMetadataStore extends cn.nukkit.metadata.MetadataStore{
        /**
         * 
         * @param {cn.nukkit.metadata.Metadatable} level 
         * @param {java.lang.String} metadataKey 
         */
        protected disambiguate(level: cn.nukkit.metadata.Metadatable,metadataKey: java.lang.String): java.lang.String;
    }
}
declare namespace cn.nukkit.item.enchantment.protection{
     class EnchantmentProtectionFall extends cn.nukkit.item.enchantment.protection.EnchantmentProtection{
        /**
         * 
         */
        public getTypeModifier(): double;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} e 
         */
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemBucket extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {int} meta 
         */
        protected static getName(meta: int): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onUse(player: cn.nukkit.Player,ticksUsed: int): boolean;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         */
        public getFishEntityId(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public isWater(): boolean;
        /**
         * 
         */
        public isLava(): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.block.Block} block 
         */
        protected afterUse(level: cn.nukkit.level.Level,block: cn.nukkit.block.Block): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         * @param {int} target 
         */
        public static getDamageByTarget(target: int): int;
        /**
         * 
         * @param {int} dimension 
         */
        protected canBeUsedOnDimension(dimension: int): boolean;
        /**
         * 
         */
        public getTargetBlock(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class MegaSpruceTaigaBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerAchievementAwardedEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        achievement: java.lang.String;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getAchievement(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityCod extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorSpruce extends cn.nukkit.block.BlockDoorWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockNetherPortal extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        PORTAL_AXIS: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         */
        public static spawnPortal(pos: cn.nukkit.level.Position): void;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityVillager extends cn.nukkit.entity.EntityCreature{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public isBaby(): boolean;
        /**
         * 
         * @param {boolean} baby 
         */
        public setBaby(baby: boolean): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockGrowEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        newState: cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewState(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.block{
     class BlockPumpkin extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemRecord extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public abstract getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.extremehills{
     class ExtremeHillsEdgeBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorJungle extends cn.nukkit.block.BlockDoorWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.resourcepacks{
     class ResourcePackManager extends java.lang.Object{
        /**  */
        resourcePacksById: java.util.Map;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        resourcePacks: cn.nukkit.resourcepacks.ResourcePack[];
        /**
         * 
         * @param {java.util.UUID} id 
         */
        public getPackById(id: java.util.UUID): cn.nukkit.resourcepacks.ResourcePack;
        /**
         * 
         */
        public getResourceStack(): cn.nukkit.resourcepacks.ResourcePack[];
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class TaigaHillsBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.particle{
     class LavaDripParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
     class BlockItemFrame extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        HAS_MAP: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public isStoringMap(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {boolean} map 
         */
        public setStoringMap(map: boolean): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.event.player.PlayerInteractEvent.Action} action 
         */
        public onTouch(player: cn.nukkit.Player,action: cn.nukkit.event.player.PlayerInteractEvent.Action): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerInteractEntityEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        clickedPos: cn.nukkit.math.Vector3;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        entity: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getClickedPos(): cn.nukkit.math.Vector3;
    }
}
declare namespace cn.nukkit.event{
     class EventPriority extends java.lang.Enum{
        /**  */
        LOWEST: cn.nukkit.event.EventPriority;
        /**  */
        HIGH: cn.nukkit.event.EventPriority;
        /**  */
        LOW: cn.nukkit.event.EventPriority;
        /**  */
        MONITOR: cn.nukkit.event.EventPriority;
        /**  */
        HIGHEST: cn.nukkit.event.EventPriority;
        /**  */
        slot: int;
        /**  */
        NORMAL: cn.nukkit.event.EventPriority;
        /**  */
        $VALUES: cn.nukkit.event.EventPriority[];
        /**
         * 
         */
        public getSlot(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.event.EventPriority;
        /**
         * 
         */
        public static values(): cn.nukkit.event.EventPriority[];
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordWard extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockPistonBase extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        sticky: boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {boolean} powered 
         */
        private updateAroundRedstoneTorches(powered: boolean): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {boolean} destroyBlocks 
         * @param {boolean} extending 
         */
        public static canPush(block: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,destroyBlocks: boolean,extending: boolean): boolean;
        /**
         * 
         * @param {int} damage 
         */
        protected createHead(damage: int): cn.nukkit.block.BlockPistonHead;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public isExtended(): boolean;
        /**
         * 
         */
        public isGettingPower(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public abstract getPistonHeadBlockId(): int;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {java.lang.Boolean} isPowered 
         */
        private checkState(isPowered: java.lang.Boolean): boolean;
        /**
         * 
         * @param {boolean} extending 
         */
        private doMove(extending: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.plugin{
     class PluginLogger extends java.lang.Object{
        /**  */
        pluginName: java.lang.String;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         */
        private toApacheLevel(level: cn.nukkit.utils.LogLevel): org.apache.logging.log4j.Level;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public debug(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public debug(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public critical(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public critical(message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public log(level: cn.nukkit.utils.LogLevel,message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         * @param {java.lang.String} message 
         */
        public log(level: cn.nukkit.utils.LogLevel,message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public alert(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public alert(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public warning(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public warning(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public emergency(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public emergency(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public error(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public error(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public info(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public info(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public notice(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public notice(message: java.lang.String): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class ReloadCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityDeathEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        drops: cn.nukkit.item.Item[];
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} drops 
         */
        public setDrops(drops: cn.nukkit.item.Item[]): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
    }
}
declare namespace cn.nukkit.item.enchantment.loot{
     class EnchantmentLootFishing extends cn.nukkit.item.enchantment.loot.EnchantmentLoot{
    }
}
declare namespace cn.nukkit.block{
     class BlockTripWireHook extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {boolean} canConnect 
         * @param {boolean} nextPowered 
         * @param {boolean} attached 
         * @param {boolean} powered 
         */
        private addSound(pos: cn.nukkit.math.Vector3,canConnect: boolean,nextPowered: boolean,attached: boolean,powered: boolean): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {boolean} onBreak 
         * @param {boolean} updateAround 
         * @param {int} pos 
         * @param {cn.nukkit.block.Block} block 
         */
        public calculateState(onBreak: boolean,updateAround: boolean,pos: int,block: cn.nukkit.block.Block): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setAttached(value: boolean): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getWeakPower(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public isAttached(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public setPowered(value: boolean): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.potion{
     class InstantEffect extends cn.nukkit.potion.Effect{
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerItemHeldEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        hotbarSlot: int;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSlot(): int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getInventorySlot(): int;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityFishingHook extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        WAIT_CHANCE: int;
        /**  */
        caught: boolean;
        /**  */
        waitChance: int;
        /**  */
        chance: boolean;
        /**  */
        NETWORK_ID: int;
        /**  */
        rod: cn.nukkit.item.Item;
        /**  */
        attracted: boolean;
        /**  */
        fish: cn.nukkit.math.Vector3;
        /**  */
        attractTimer: int;
        /**  */
        CHANCE: int;
        /**  */
        coughtTimer: int;
        /**
         * 
         */
        public reelLine(): void;
        /**
         * 
         */
        public canCollide(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         */
        public spawnFish(): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getDrag(): float;
        /**
         * 
         */
        public fishBites(): void;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        public getGravity(): float;
        /**
         * 
         */
        public attractFish(): boolean;
        /**
         * 
         */
        public getWaterHeight(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsAcacia extends cn.nukkit.block.BlockStairsWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemSugarcane extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityFlowerPot extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockPodzol extends cn.nukkit.block.BlockDirt{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDirtType(): java.util.Optional;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.DirtType} dirtType 
         */
        public setDirtType(dirtType: cn.nukkit.blockproperty.value.DirtType): void;
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntitySilverfish extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace blockitem{
    /**  */
    var legacyNetworkMap: java.lang.reflect.Field;
    /**  */
    var mcpackTranslation: com.blocklynukkit.loader.other.AddonsAPI.resource.TranslationNode;
    /**  */
    var namespaceNetworkMap: java.lang.reflect.Field;
    /**  */
    var getRuntimeItemMappingMethod: java.lang.reflect.Method;
    /**  */
    var networkLegacyMap: java.lang.reflect.Field;
    /**  */
    var networkNamespaceMap: java.lang.reflect.Field;
    /**  */
    var legacy2Runtime: java.lang.reflect.Field;
    /**  */
    var identifier2Legacy: java.lang.reflect.Field;
    /**  */
    var getLevelBlockAtLayerMethod: java.lang.reflect.Method;
    /**  */
    var blocklyNukkitMcpack: com.blocklynukkit.loader.other.AddonsAPI.resource.ResourcePack;
    /**  */
    var runtime2Legacy: java.lang.reflect.Field;
    /**
     * 注册新的食物物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {int} nutrition 提供的饥饿度
     * @param {int} eatTime 食用持续时间(刻)
     * @param {boolean} canOnOffhand 是否可装备在副手
     */
    function registerFoodItem(id: int,name: java.lang.String,stackSize: int,nutrition: int,eatTime: int,canOnOffhand: boolean): void;
    /**
     * 注册新的食物物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {int} nutrition 提供的饥饿度
     * @param {int} eatTime 食用持续时间(刻)
     * @param {boolean} canOnOffhand 是否可装备在副手
     * @param {java.lang.String} initFunction 物品初始化函数
     */
    function registerFoodItem(id: int,name: java.lang.String,stackSize: int,nutrition: int,eatTime: int,canOnOffhand: boolean,initFunction: Fun1<cn.nukkit.item.Item>): void;
    /**
     * 向玩家背包添加物品
     * @param {cn.nukkit.Player} player 要添加物品的玩家
     * @param {cn.nukkit.item.Item} item 要添加到玩家背包的物品
     */
    function addItemToPlayer(player: cn.nukkit.Player,item: cn.nukkit.item.Item): void;
    /**
     * 为物品对象添加附魔
     * @param {cn.nukkit.item.Item} item 物品对象
     * @param {int} id 附魔id
     * @param {int} level 附魔等级
     */
    function addItemEnchant(item: cn.nukkit.item.Item,id: int,level: int): void;
    /**
     * 设置指定位置的方块
     * @param {cn.nukkit.level.Position} position 坐标
     * @param {cn.nukkit.block.Block} block 要被设置的方块对象
     * @param {boolean} particle 是否产生破坏先前方块的粒子
     */
    function setBlock(position: cn.nukkit.level.Position,block: cn.nukkit.block.Block,particle: boolean): void;
    /**
     * 在指定位置播放声音
     * @param {cn.nukkit.level.Position} position 播放声音的坐标
     * @param {java.lang.String} soundname 声音名称，详见[声音列表](https://ci.opencollab.dev/job/NukkitX/job/Nukkit/job/master/javadoc/cn/nukkit/level/Sound.html)
     */
    function makeSound(position: cn.nukkit.level.Position,soundname: java.lang.String): void;
    /**
     * 设置玩家手中物品
     * @param {cn.nukkit.Player} player 要设置物品的玩家
     * @param {cn.nukkit.item.Item} item 要被设置到玩家手中的物品
     */
    function setItemInHand(player: cn.nukkit.Player,item: cn.nukkit.item.Item): void;
    /**
     * 
     * @param {cn.nukkit.item.Item} item 
     * @param {int} level 
     * @param {cn.nukkit.item.enchantment.Enchantment[]} enchantments 
     */
    function addEnchantment(item: cn.nukkit.item.Item,level: int,...enchantments: cn.nukkit.item.enchantment.Enchantment[]): void;
    /**
     * 
     * @param {java.lang.String} name 
     * @param {int} id 
     */
    function injectItem2Nukkit(name: java.lang.String,id: int): void;
    /**
     * 获取物品对象的nbt字符串
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function getNBTString(item: cn.nukkit.item.Item): java.lang.String;
    /**
     * 设置物品的lore标签内容，多行;分割
     * @param {cn.nukkit.item.Item} item 物品对象
     * @param {java.lang.String} string 要设置的lore内容
     */
    function setItemLore(item: cn.nukkit.item.Item,string: java.lang.String): void;
    /**
     * 获取指定位置是否是晴天
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function getIsSunny(position: cn.nukkit.level.Position): boolean;
    /**
     * 添加新的物品材质
     * @param {int} id 物品id
     * @param {java.lang.String} path 物品材质图片路径
     */
    function addItemTexture(id: int,path: java.lang.String): void;
    /**
     * 比较两个物品对象内容是否相同
     * @param {cn.nukkit.item.Item} item1 一个物品对象
     * @param {cn.nukkit.item.Item} item2 另一个物品对象
     * @param {boolean} damage 是否比较特殊值
     * @param {boolean} nbt 是否比较nbt
     */
    function isSame(item1: cn.nukkit.item.Item,item2: cn.nukkit.item.Item,damage: boolean,nbt: boolean): boolean;
    /**
     * 注册新的工具物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {java.lang.String} toolType 工具种类,可为sword shovel pickaxe axe hoe
     * @param {int} toolTier 工具挖掘等级 0-空手,1-木,2-金,3-石,4-铁,5-钻石,6-下界合金
     * @param {int} durability 工具耐久值
     * @param {int} attackDamage 攻击伤害
     * @param {boolean} canOnOffhand 是否可装备在副手
     */
    function registerToolItem(id: int,name: java.lang.String,toolType: java.lang.String,toolTier: int,durability: int,attackDamage: int,canOnOffhand: boolean): void;
    /**
     * 注册新的工具物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {java.lang.String} toolType 工具种类,可为sword shovel pickaxe axe hoe
     * @param {int} toolTier 工具挖掘等级 0-空手,1-木,2-金,3-石,4-铁,5-钻石,6-下界合金
     * @param {int} durability 工具耐久值
     * @param {int} attackDamage 攻击伤害
     * @param {boolean} canOnOffhand 是否可装备在副手
     * @param {java.lang.String} initFunction 物品初始化函数
     */
    function registerToolItem(id: int,name: java.lang.String,toolType: java.lang.String,toolTier: int,durability: int,attackDamage: int,canOnOffhand: boolean,initFunction: Fun1<cn.nukkit.item.Item>): void;
    /**
     * 获取物品的Lore标签内容，多行用;分割
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function getItemLore(item: cn.nukkit.item.Item): java.lang.String;
    /**
     * 获取玩家手中物品
     * @param {cn.nukkit.Player} player 要获取物品的玩家
     */
    function getItemInHand(player: cn.nukkit.Player): cn.nukkit.item.Item;
    /**
     * 
     * @param {int} id 
     * @param {java.lang.String} name 
     * @param {java.lang.Class} clazz 
     */
    function registerBlock(id: int,name: java.lang.String,clazz: java.lang.Class): void;
    /**
     * 获取指定坐标所在世界的所有实体
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function getLevelEntities(position: cn.nukkit.level.Position): java.util.List;
    /**
     * 添加钓鱼可能产出的产物
     * @param {java.lang.String} type 种类，可以为TREASURES/JUNKS/FISH
     * @param {cn.nukkit.item.Item} item 新增的产物物品
     * @param {double} chance 概率权重
     */
    function addFishingResult(type: java.lang.String,item: cn.nukkit.item.Item,chance: double): void;
    /**
     * 获取物品对象的所有附魔属性对象
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function getItemEnchant(item: cn.nukkit.item.Item): cn.nukkit.item.enchantment.Enchantment[];
    /**
     * 添加熔炉冶炼合成
     * @param {cn.nukkit.item.Item} input 原料物品对象
     * @param {cn.nukkit.item.Item} output 产物物品对象
     */
    function addFurnaceCraft(input: cn.nukkit.item.Item,output: cn.nukkit.item.Item): void;
    /**
     * 在指定位置生成经验球
     * @param {cn.nukkit.level.Position} position 生成经验球的位置
     * @param {int} point 包含的经验点数
     */
    function makeExpBall(position: cn.nukkit.level.Position,point: int): void;
    /**
     * 添加bn高级合成
     * @param {java.lang.String} type 合成类别，可自定义
     * @param {java.lang.String} description 对合成的描述
     * @param {cn.nukkit.item.Item[]} input 原料物品对象数组，需要使用`Java.to`函数转换
     * @param {cn.nukkit.item.Item[]} output 合成的产物数组，需要使用`Java.to`函数转换
     * @param {int} delay 合成耗时
     * @param {double} percent 合成成功率
     */
    function addBNCraft(type: java.lang.String,description: java.lang.String,input: cn.nukkit.item.Item[],output: cn.nukkit.item.Item[],delay: int,percent: double): void;
    /**
     * 把nbt字符串包含的物品信息注入到物品对象上
     * @param {cn.nukkit.item.Item} item 物品对象
     * @param {java.lang.String} str nbt字符串
     */
    function putinNBTString(item: cn.nukkit.item.Item,str: java.lang.String): void;
    /**
     * 注册新的饮品物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {int} nutrition 提供的饥饿度
     * @param {int} drinkTime 饮用持续时间(刻)
     * @param {boolean} canOnOffhand 是否可装备在副手
     * @param {java.lang.String} initFunction 物品初始化函数
     */
    function registerDrinkItem(id: int,name: java.lang.String,stackSize: int,nutrition: int,drinkTime: int,canOnOffhand: boolean,initFunction: Fun1<cn.nukkit.item.Item>): void;
    /**
     * 注册新的饮品物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {int} nutrition 提供的饥饿度
     * @param {int} drinkTime 饮用持续时间(刻)
     * @param {boolean} canOnOffhand 是否可装备在副手
     */
    function registerDrinkItem(id: int,name: java.lang.String,stackSize: int,nutrition: int,drinkTime: int,canOnOffhand: boolean): void;
    /**
     * 获取附魔对象的等级
     * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 附魔等级
     */
    function getEnchantLevel(enchantment: cn.nukkit.item.enchantment.Enchantment): int;
    /**
     * 添加新的资源包声音文件
     * @param {java.lang.String} soundName 声音名
     * @param {java.lang.String} filePath 声音文件路径(.ogg)
     */
    function addSoundFile(soundName: java.lang.String,filePath: java.lang.String): void;
    /**
     * 注册新的盔甲物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {java.lang.String} armorType 盔甲种类,可为helmet chest leggings boots
     * @param {int} armorTier 盔甲等级 0-无,1-皮革,2-铁,3-锁链,4-金,5-钻石,6-下界合金
     * @param {int} durability 工具耐久值
     * @param {int} armorPoint 提供的盔甲值
     * @param {boolean} canOnOffhand 是否可装备在副手
     */
    function registerArmorItem(id: int,name: java.lang.String,armorType: java.lang.String,armorTier: int,durability: int,armorPoint: int,canOnOffhand: boolean): void;
    /**
     * 注册新的盔甲物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {java.lang.String} armorType 盔甲种类,可为helmet chest leggings boots
     * @param {int} armorTier 盔甲等级 0-无,1-皮革,2-铁,3-锁链,4-金,5-钻石,6-下界合金
     * @param {int} durability 工具耐久值
     * @param {int} armorPoint 提供的盔甲值
     * @param {boolean} canOnOffhand 是否可装备在副手
     * @param {java.lang.String} initFunction 物品初始化函数
     */
    function registerArmorItem(id: int,name: java.lang.String,armorType: java.lang.String,armorTier: int,durability: int,armorPoint: int,canOnOffhand: boolean,initFunction: Fun1<cn.nukkit.item.Item>): void;
    /**
     * 设置指定位置的天气
     * @param {cn.nukkit.level.Position} position 坐标
     * @param {java.lang.String} mode 天气，值为clear/rain/thunder
     */
    function setLevelWeather(position: cn.nukkit.level.Position,mode: java.lang.String): void;
    /**
     * 获取坐标所在世界的所有生物
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function getEntities(position: cn.nukkit.level.Position): cn.nukkit.entity.Entity[];
    /**
     * 检测方块是否为含水方块
     * @param {cn.nukkit.block.Block} block 要检测的方块
     */
    function isBlockWaterLogged(block: cn.nukkit.block.Block): boolean;
    /**
     * 在指定位置生成掉落物
     * @param {cn.nukkit.level.Position} position 生成掉落物的位置
     * @param {cn.nukkit.item.Item} item 生成的掉落物实体的内容
     * @param {boolean} fly 生成的掉落物是否有初速度飞出，默认为false
     */
    function makeDropItem(position: cn.nukkit.level.Position,item: cn.nukkit.item.Item,fly: boolean): void;
    /**
     * 在指定位置生成掉落物
     * @param {cn.nukkit.level.Position} position 生成掉落物的位置
     * @param {cn.nukkit.item.Item} item 生成的掉落物实体的内容
     */
    function makeDropItem(position: cn.nukkit.level.Position,item: cn.nukkit.item.Item): void;
    /**
     * 
     * @param {cn.nukkit.Player} player 
     * @param {int} x 
     * @param {cn.nukkit.item.Item[]} item 
     */
    function PlayercontainsItem(player: cn.nukkit.Player,x: int,...item: cn.nukkit.item.Item[]): boolean;
    /**
     * 获取指定坐标所在世界的所有玩家
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function getLevelPlayers(position: cn.nukkit.level.Position): java.util.List;
    /**
     * 刷新客户端物品注册表
     */
    function refreshItemPalette(): void;
    /**
     * 获取附魔对象的id
     * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 附魔对象
     */
    function getEnchantID(enchantment: cn.nukkit.item.enchantment.Enchantment): int;
    /**
     * 向材质包中指定位置添加图片文件
     * @param {java.lang.String} entryPath 材质包内相对位置，包含路径和文件全名
     * @param {java.lang.String} path 要复制到材质包中的硬盘上的图片路径
     */
    function addResourcePackPictureEntry(entryPath: java.lang.String,path: java.lang.String): void;
    /**
     * 获取指定世界上所有的掉落物
     * @param {cn.nukkit.level.Level} level 世界对象
     */
    function getDropItems(level: cn.nukkit.level.Level): cn.nukkit.entity.item.EntityItem[];
    /**
     * 获取坐标所在世界的所有掉落物
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function getDropItems(position: cn.nukkit.level.Position): cn.nukkit.entity.item.EntityItem[];
    /**
     * 
     * @param {int} id 
     * @param {int} data 
     */
    function getFullId(id: int,data: int): int;
    /**
     * 添加新的盔甲材质
     * @param {int} id 物品id
     * @param {java.lang.String} inventoryPicturePath 盔甲物品栏材质图片路径
     * @param {java.lang.String} modelPicturePath 盔甲穿着时材质图片路径
     */
    function addArmorTexture(id: int,inventoryPicturePath: java.lang.String,modelPicturePath: java.lang.String): void;
    /**
     * 添加新的盔甲材质
     * @param {int} id 物品id
     * @param {java.lang.String} inventoryPicturePath 盔甲物品栏材质图片路径
     * @param {java.lang.String} modelPicturePath 盔甲穿着时材质图片路径
     * @param {java.lang.String} modelJSONPath 4d盔甲模型文件(.json)
     */
    function addArmorTexture(id: int,inventoryPicturePath: java.lang.String,modelPicturePath: java.lang.String,modelJSONPath: java.lang.String): void;
    /**
     * 获取世界对象的世界名
     * @param {cn.nukkit.level.Level} level 世界对象
     */
    function getLevelName(level: cn.nukkit.level.Level): java.lang.String;
    /**
     * 添加无序合成
     * @param {cn.nukkit.item.Item[]} inputs 原料物品数组，需使用`Java.to`函数进行转换
     * @param {cn.nukkit.item.Item} output 产物物品对象
     */
    function addShapelessCraft(inputs: cn.nukkit.item.Item[],output: cn.nukkit.item.Item): void;
    /**
     * 为指定玩家打开指定类别的bn合成
     * @param {java.lang.String} type 合成类别
     * @param {cn.nukkit.Player} player 为哪个玩家打开
     */
    function openBNCraftForPlayer(type: java.lang.String,player: cn.nukkit.Player): void;
    /**
     * 构建物品
     * @param {int} id 物品id
     * @param {int} data 物品特殊值
     * @param {int} count 物品对象数量
     */
    function buildItem(id: int,data: int,count: int): cn.nukkit.item.Item;
    /**
     * 设置物品的颜色
     * @param {cn.nukkit.item.Item} item 物品对象
     * @param {int} r 
     * @param {int} g 
     * @param {int} b 
     */
    function setItemColor(item: cn.nukkit.item.Item,r: int,g: int,b: int): void;
    /**
     * 强制更新指定坐标上的方块
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function blockUpdate(position: cn.nukkit.level.Position): void;
    /**
     * 注册新的自定义方块
     * @param {int} id 新方块的id
     * @param {java.lang.String} name 新方块的名称
     * @param {double} hardness 新方块的硬度
     * @param {double} resistance 新方块的抗爆炸度
     * @param {int} toolType 用于开采的工具种类，0-无,1-剑,2-铲,3-镐,4-斧,5-剪刀
     * @param {boolean} isSilkTouchable 是否允许被精准采集
     * @param {int} dropMinExp 挖掘后掉落的最小经验
     * @param {int} dropMaxExp 挖掘后掉落的最大经验
     * @param {int} mineTier 新方块的挖掘等级，0-空手,1-木,2-金,3-石,4-铁,5-钻石
     */
    function registerSolidBlock(id: int,name: java.lang.String,hardness: double,resistance: double,toolType: int,isSilkTouchable: boolean,dropMinExp: int,dropMaxExp: int,mineTier: int): void;
    /**
     * 从方块构建物品
     * @param {cn.nukkit.block.Block} block 源方块
     */
    function buildItemFromBlock(block: cn.nukkit.block.Block): cn.nukkit.item.Item;
    /**
     * 检测玩家背包是否有指定物品
     * @param {cn.nukkit.Player} player 要检测物品的玩家
     * @param {cn.nukkit.item.Item} item 要检测是否存在的物品
     */
    function hasItemToPlayer(player: cn.nukkit.Player,item: cn.nukkit.item.Item): boolean;
    /**
     * 获取指定位置的方块对象
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function getBlock(position: cn.nukkit.level.Position): cn.nukkit.block.Block;
    /**
     * 向材质包中指定位置添加json文件
     * @param {java.lang.String} entryPath 材质包内相对位置，包含路径和文件全名
     * @param {java.lang.String} json json文件内容
     */
    function addResourcePackJsonEntry(entryPath: java.lang.String,json: java.lang.String): void;
    /**
     * 设置物品是否无限耐久
     * @param {cn.nukkit.item.Item} item 物品对象
     * @param {boolean} unbreakable 是否无限耐久
     */
    function setItemUnbreakable(item: cn.nukkit.item.Item,unbreakable: boolean): void;
    /**
     * 构建方块
     * @param {int} id 方块id
     * @param {int} data 方块特殊值
     */
    function buildBlock(id: int,data: int): cn.nukkit.block.Block;
    /**
     * 为指定id物品添加中文翻译名
     * @param {int} id 物品id
     * @param {java.lang.String} name 中文名
     */
    function addItemChineseTranslation(id: int,name: java.lang.String): void;
    /**
     * 获取指定位置是白天还是黑夜
     * @param {cn.nukkit.level.Position} position 坐标
     */
    function isDay(position: cn.nukkit.level.Position): boolean;
    /**
     * 此函数已弃用
     * @param {cn.nukkit.item.Item} item 
     * @param {java.lang.Integer} data 
     * @param {java.lang.Integer} count 
     * @param {java.lang.Boolean} unbreakable 
     * @param {java.lang.String} name 
     * @param {java.lang.String} lore 
     * @param {java.lang.String} nbt 
     */
    function setItemProperty(item: cn.nukkit.item.Item,data: java.lang.Integer,count: java.lang.Integer,unbreakable: java.lang.Boolean,name: java.lang.String,lore: java.lang.String,nbt: java.lang.String): void;
    /**
     * 将玩家背包内的指定物品移除
     * @param {cn.nukkit.Player} player 要移除物品的玩家
     * @param {cn.nukkit.item.Item} item 要被从玩家背包移除的物品
     */
    function removeItemToPlayer(player: cn.nukkit.Player,item: cn.nukkit.item.Item): void;
    /**
     * 偏移一个坐标对象
     * @param {cn.nukkit.level.Position} position 被执行偏移操作的坐标对象
     * @param {double} x x轴偏移量
     * @param {double} y y轴偏移量
     * @param {double} z z轴偏移量
     */
    function PositionMove(position: cn.nukkit.level.Position,x: double,y: double,z: double): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     * @param {java.lang.String} s4 shape中的第4个字母
     * @param {cn.nukkit.item.Item} i4 第4个字母对应的物品对象
     * @param {java.lang.String} s5 shape中的第5个字母
     * @param {cn.nukkit.item.Item} i5 第5个字母对应的物品对象
     * @param {java.lang.String} s6 shape中的第6个字母
     * @param {cn.nukkit.item.Item} i6 第6个字母对应的物品对象
     * @param {java.lang.String} s7 shape中的第7个字母
     * @param {cn.nukkit.item.Item} i7 第7个字母对应的物品对象
     * @param {java.lang.String} s8 shape中的第8个字母
     * @param {cn.nukkit.item.Item} i8 第8个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item,s4: java.lang.String,i4: cn.nukkit.item.Item,s5: java.lang.String,i5: cn.nukkit.item.Item,s6: java.lang.String,i6: cn.nukkit.item.Item,s7: java.lang.String,i7: cn.nukkit.item.Item,s8: java.lang.String,i8: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     * @param {java.lang.String} s4 shape中的第4个字母
     * @param {cn.nukkit.item.Item} i4 第4个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item,s4: java.lang.String,i4: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成，不推荐使用
     * @param {java.lang.String[]} shape 合成形状字符串，需使用`Java.to`函数进行转换
     * @param {cn.nukkit.item.Item} output 产物
     * @param {cn.nukkit.item.Item[]} append 追加返回产物
     */
    function addShapedCraft(shape: java.lang.String[],output: cn.nukkit.item.Item,append: cn.nukkit.item.Item[]): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     * @param {java.lang.String} s4 shape中的第4个字母
     * @param {cn.nukkit.item.Item} i4 第4个字母对应的物品对象
     * @param {java.lang.String} s5 shape中的第5个字母
     * @param {cn.nukkit.item.Item} i5 第5个字母对应的物品对象
     * @param {java.lang.String} s6 shape中的第6个字母
     * @param {cn.nukkit.item.Item} i6 第6个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item,s4: java.lang.String,i4: cn.nukkit.item.Item,s5: java.lang.String,i5: cn.nukkit.item.Item,s6: java.lang.String,i6: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     * @param {java.lang.String} s4 shape中的第4个字母
     * @param {cn.nukkit.item.Item} i4 第4个字母对应的物品对象
     * @param {java.lang.String} s5 shape中的第5个字母
     * @param {cn.nukkit.item.Item} i5 第5个字母对应的物品对象
     * @param {java.lang.String} s6 shape中的第6个字母
     * @param {cn.nukkit.item.Item} i6 第6个字母对应的物品对象
     * @param {java.lang.String} s7 shape中的第7个字母
     * @param {cn.nukkit.item.Item} i7 第7个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item,s4: java.lang.String,i4: cn.nukkit.item.Item,s5: java.lang.String,i5: cn.nukkit.item.Item,s6: java.lang.String,i6: cn.nukkit.item.Item,s7: java.lang.String,i7: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     * @param {java.lang.String} s4 shape中的第4个字母
     * @param {cn.nukkit.item.Item} i4 第4个字母对应的物品对象
     * @param {java.lang.String} s5 shape中的第5个字母
     * @param {cn.nukkit.item.Item} i5 第5个字母对应的物品对象
     * @param {java.lang.String} s6 shape中的第6个字母
     * @param {cn.nukkit.item.Item} i6 第6个字母对应的物品对象
     * @param {java.lang.String} s7 shape中的第7个字母
     * @param {cn.nukkit.item.Item} i7 第7个字母对应的物品对象
     * @param {java.lang.String} s8 shape中的第8个字母
     * @param {cn.nukkit.item.Item} i8 第8个字母对应的物品对象
     * @param {java.lang.String} s9 shape中的第9个字母
     * @param {cn.nukkit.item.Item} i9 第9个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item,s4: java.lang.String,i4: cn.nukkit.item.Item,s5: java.lang.String,i5: cn.nukkit.item.Item,s6: java.lang.String,i6: cn.nukkit.item.Item,s7: java.lang.String,i7: cn.nukkit.item.Item,s8: java.lang.String,i8: cn.nukkit.item.Item,s9: java.lang.String,i9: cn.nukkit.item.Item): void;
    /**
     * 添加有序合成
     * @param {java.lang.String} shape 用一个字母或数字代表合成原材料的摆放方式，用"|"来连接三行，用空格来占格，如果最后的一行或列没有东西，请不要保留
例如石镐:`addShapedCraft("SSS| I | I ",石镐物品对象,"S",圆石物品对象,"I",木棍物品对象)`，工作台:`addShapedCraft("MM|MM",工作台物品,"M",橡木木板物品)`
     * @param {cn.nukkit.item.Item} output 合成产物
     * @param {java.lang.String} s1 shape中的第1个字母
     * @param {cn.nukkit.item.Item} i1 第1个字母对应的物品对象
     * @param {java.lang.String} s2 shape中的第2个字母
     * @param {cn.nukkit.item.Item} i2 第2个字母对应的物品对象
     * @param {java.lang.String} s3 shape中的第3个字母
     * @param {cn.nukkit.item.Item} i3 第3个字母对应的物品对象
     * @param {java.lang.String} s4 shape中的第4个字母
     * @param {cn.nukkit.item.Item} i4 第4个字母对应的物品对象
     * @param {java.lang.String} s5 shape中的第5个字母
     * @param {cn.nukkit.item.Item} i5 第5个字母对应的物品对象
     */
    function addShapedCraft(shape: java.lang.String,output: cn.nukkit.item.Item,s1: java.lang.String,i1: cn.nukkit.item.Item,s2: java.lang.String,i2: cn.nukkit.item.Item,s3: java.lang.String,i3: cn.nukkit.item.Item,s4: java.lang.String,i4: cn.nukkit.item.Item,s5: java.lang.String,i5: cn.nukkit.item.Item): void;
    /**
     * 为指定id物品添加英文翻译名
     * @param {int} id 物品id
     * @param {java.lang.String} name 英文名
     */
    function addItemEnglishTranslation(id: int,name: java.lang.String): void;
    /**
     * 将指定物品对象添加到创造模式物品栏中
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function addToCreativeBar(item: cn.nukkit.item.Item): void;
    /**
     * 注册新的简易物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {java.lang.String} type 新物品的类别，可选construction nature equipment items
     * @param {boolean} isDisplayAsTool 是否展示为工具(竖着拿在手里)
     * @param {boolean} canOnOffhand 是否可装备在副手
     * @param {java.lang.String} initFunction 物品初始化函数
     */
    function registerSimpleItem(id: int,name: java.lang.String,stackSize: int,type: java.lang.String,isDisplayAsTool: boolean,canOnOffhand: boolean,initFunction: Fun1<cn.nukkit.item.Item>): void;
    /**
     * 注册新的简易物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {java.lang.String} type 新物品的类别，可选construction nature equipment items
     * @param {boolean} isDisplayAsTool 是否展示为工具(竖着拿在手里)
     * @param {boolean} canOnOffhand 是否可装备在副手
     */
    function registerSimpleItem(id: int,name: java.lang.String,stackSize: int,type: java.lang.String,isDisplayAsTool: boolean,canOnOffhand: boolean): void;
    /**
     * 注册新的简易物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {int} stackSize 新物品的最大堆叠上限
     * @param {java.lang.String} type 新物品的类别，可选construction nature equipment items
     */
    function registerSimpleItem(id: int,name: java.lang.String,stackSize: int,type: java.lang.String): void;
    /**
     * 注册新的简易物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     * @param {java.lang.String} type 新物品的类别，可选construction nature equipment items
     */
    function registerSimpleItem(id: int,name: java.lang.String,type: java.lang.String): void;
    /**
     * 注册新的简易物品
     * @param {int} id 新物品的id
     * @param {java.lang.String} name 新物品的名称
     */
    function registerSimpleItem(id: int,name: java.lang.String): void;
    /**
     * 
     */
    function toString(): java.lang.String;
}
declare namespace cn.nukkit.block{
     class BlockIronBars extends cn.nukkit.block.BlockThin{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.event{
    abstract class Cancellable extends java.lang.Object{
        /**
         * 
         */
        public abstract isCancelled(): boolean;
        /**
         * 
         */
        public abstract setCancelled(): void;
        /**
         * 
         * @param {boolean} forceCancel 
         */
        public abstract setCancelled(forceCancel: boolean): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemLeggingsNetherite extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isLeggings(): boolean;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class JungleFloorPopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntitySlime extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetCommandsEnabledPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        enabled: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.format{
    abstract class LevelProviderManager extends java.lang.Object{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        providers: java.util.Map;
        /**
         * 
         * @param {cn.nukkit.Server} server 
         * @param {java.lang.Class} clazz 
         */
        public static addProvider(server: cn.nukkit.Server,clazz: java.lang.Class): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getProviderByName(name: java.lang.String): java.lang.Class;
        /**
         * 
         * @param {java.lang.String} path 
         */
        public static getProvider(path: java.lang.String): java.lang.Class;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ModalFormResponsePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        formId: int;
        /**  */
        data: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityGhast extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityZombieVillagerV1 extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemPotion extends cn.nukkit.item.Item{
        /**  */
        SLOWNESS: int;
        /**  */
        NIGHT_VISION_LONG: int;
        /**  */
        WEAKNESS_LONG: int;
        /**  */
        DECAY: int;
        /**  */
        INVISIBLE_LONG: int;
        /**  */
        LEAPING: int;
        /**  */
        WEAKNESS: int;
        /**  */
        LEAPING_LONG: int;
        /**  */
        SPEED_LONG: int;
        /**  */
        MUNDANE_II: int;
        /**  */
        REGENERATION_LONG: int;
        /**  */
        SPEED: int;
        /**  */
        POISON_II: int;
        /**  */
        FIRE_RESISTANCE: int;
        /**  */
        HARMING_II: int;
        /**  */
        WATER_BREATHING: int;
        /**  */
        STRENGTH_LONG: int;
        /**  */
        HARMING: int;
        /**  */
        REGENERATION_II: int;
        /**  */
        WATER_BREATHING_LONG: int;
        /**  */
        AWKWARD: int;
        /**  */
        REGENERATION: int;
        /**  */
        SPEED_II: int;
        /**  */
        STRENGTH: int;
        /**  */
        MUNDANE: int;
        /**  */
        NO_EFFECTS: int;
        /**  */
        INVISIBLE: int;
        /**  */
        SLOWNESS_LONG: int;
        /**  */
        STRENGTH_II: int;
        /**  */
        INSTANT_HEALTH_II: int;
        /**  */
        POISON: int;
        /**  */
        LEAPING_II: int;
        /**  */
        POISON_LONG: int;
        /**  */
        THICK: int;
        /**  */
        NIGHT_VISION: int;
        /**  */
        INSTANT_HEALTH: int;
        /**  */
        FIRE_RESISTANCE_LONG: int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onUse(player: cn.nukkit.Player,ticksUsed: int): boolean;
    }
}
declare namespace cn.nukkit.event.vehicle{
     class VehicleDamageEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        damage: double;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getDamage(): double;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {double} damage 
         */
        public setDamage(damage: double): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class BanCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item.food{
    abstract class Food extends java.lang.Object{
        /**  */
        suspicious_stew_regeneration: cn.nukkit.item.food.Food;
        /**  */
        honey_bottle: cn.nukkit.item.food.Food;
        /**  */
        fish_cooked: cn.nukkit.item.food.Food;
        /**  */
        fish_raw: cn.nukkit.item.food.Food;
        /**  */
        chorus_fruit: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_blindness: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_jump: cn.nukkit.item.food.Food;
        /**  */
        apple_golden_enchanted: cn.nukkit.item.food.Food;
        /**  */
        mutton_cooked: cn.nukkit.item.food.Food;
        /**  */
        cake_slice: cn.nukkit.item.food.Food;
        /**  */
        porkchop_cooked: cn.nukkit.item.food.Food;
        /**  */
        beef_raw: cn.nukkit.item.food.Food;
        /**  */
        eatingTick: int;
        /**  */
        chicken_raw: cn.nukkit.item.food.Food;
        /**  */
        cookie: cn.nukkit.item.food.Food;
        /**  */
        milk: cn.nukkit.item.food.Food;
        /**  */
        restoreFood: int;
        /**  */
        suspicious_stew_night_vision: cn.nukkit.item.food.Food;
        /**  */
        rabbit_cooked: cn.nukkit.item.food.Food;
        /**  */
        potato_baked: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_saturation: cn.nukkit.item.food.Food;
        /**  */
        mushroom_stew: cn.nukkit.item.food.Food;
        /**  */
        rabbit_raw: cn.nukkit.item.food.Food;
        /**  */
        apple_golden: cn.nukkit.item.food.Food;
        /**  */
        rabbit_stew: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_weakness: cn.nukkit.item.food.Food;
        /**  */
        potato_poisonous: cn.nukkit.item.food.Food;
        /**  */
        registryCustom: java.util.Map;
        /**  */
        chicken_cooked: cn.nukkit.item.food.Food;
        /**  */
        salmon_raw: cn.nukkit.item.food.Food;
        /**  */
        relativeIDs: java.util.List;
        /**  */
        steak: cn.nukkit.item.food.Food;
        /**  */
        registryDefault: java.util.Map;
        /**  */
        sweet_berries: cn.nukkit.item.food.Food;
        /**  */
        clownfish: cn.nukkit.item.food.Food;
        /**  */
        beetroot_soup: cn.nukkit.item.food.Food;
        /**  */
        apple: cn.nukkit.item.food.Food;
        /**  */
        salmon_cooked: cn.nukkit.item.food.Food;
        /**  */
        spider_eye: cn.nukkit.item.food.Food;
        /**  */
        honey: cn.nukkit.item.food.Food;
        /**  */
        potato_raw: cn.nukkit.item.food.Food;
        /**  */
        pumpkin_pie: cn.nukkit.item.food.Food;
        /**  */
        pufferfish: cn.nukkit.item.food.Food;
        /**  */
        bread: cn.nukkit.item.food.Food;
        /**  */
        rotten_flesh: cn.nukkit.item.food.Food;
        /**  */
        dried_kelp: cn.nukkit.item.food.Food;
        /**  */
        porkchop_raw: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_fire_resistance: cn.nukkit.item.food.Food;
        /**  */
        melon_slice: cn.nukkit.item.food.Food;
        /**  */
        beetroot: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_poison: cn.nukkit.item.food.Food;
        /**  */
        suspicious_stew_wither: cn.nukkit.item.food.Food;
        /**  */
        carrot_golden: cn.nukkit.item.food.Food;
        /**  */
        mutton_raw: cn.nukkit.item.food.Food;
        /**  */
        restoreSaturation: float;
        /**  */
        carrot: cn.nukkit.item.food.Food;
        /**
         * 
         * @param {int} eatingTick 
         */
        public setEatingTick(eatingTick: int): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {cn.nukkit.item.food.Food} food 
         * @param {cn.nukkit.item.food.Food.NodeIDMeta} n 
         */
        private static lambda$registerDefaultFood$1(food: cn.nukkit.item.food.Food,n: cn.nukkit.item.food.Food.NodeIDMeta): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        protected onEatenBy(player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} restoreFood 
         */
        public setRestoreFood(restoreFood: int): cn.nukkit.item.food.Food;
        /**
         * 
         */
        public getRestoreFood(): int;
        /**
         * 
         * @param {cn.nukkit.item.food.Food.NodeIDMeta} node 
         */
        private addRelative(node: cn.nukkit.item.food.Food.NodeIDMeta): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {int} relativeID 
         * @param {int} meta 
         */
        public addRelative(relativeID: int,meta: int): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {int} relativeID 
         */
        public addRelative(relativeID: int): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {cn.nukkit.item.food.Food} food 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public static registerFood(food: cn.nukkit.item.food.Food,plugin: cn.nukkit.plugin.Plugin): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {cn.nukkit.item.food.Food} food 
         */
        private static registerDefaultFood(food: cn.nukkit.item.food.Food): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public  eatenBy(player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} relativeID 
         * @param {int} meta 
         * @param {cn.nukkit.item.food.Food[]} result 
         * @param {cn.nukkit.item.food.Food.NodeIDMetaPlugin} n 
         * @param {cn.nukkit.item.food.Food} f 
         */
        private static lambda$getByRelative$2(relativeID: int,meta: int,result: cn.nukkit.item.food.Food[],n: cn.nukkit.item.food.Food.NodeIDMetaPlugin,f: cn.nukkit.item.food.Food): void;
        /**
         * 
         * @param {int} relativeID 
         * @param {int} meta 
         * @param {cn.nukkit.item.food.Food[]} result 
         * @param {cn.nukkit.item.food.Food.NodeIDMeta} n 
         * @param {cn.nukkit.item.food.Food} f 
         */
        private static lambda$getByRelative$3(relativeID: int,meta: int,result: cn.nukkit.item.food.Food[],n: cn.nukkit.item.food.Food.NodeIDMeta,f: cn.nukkit.item.food.Food): void;
        /**
         * 
         * @param {float} restoreSaturation 
         */
        public setRestoreSaturation(restoreSaturation: float): cn.nukkit.item.food.Food;
        /**
         * 
         */
        public getRestoreSaturation(): float;
        /**
         * 
         */
        public getEatingTick(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public static getByRelative(item: cn.nukkit.item.Item): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {int} relativeID 
         * @param {int} meta 
         */
        public static getByRelative(relativeID: int,meta: int): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public static getByRelative(block: cn.nukkit.block.Block): cn.nukkit.item.food.Food;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {cn.nukkit.item.food.Food} food 
         * @param {cn.nukkit.item.food.Food.NodeIDMeta} n 
         */
        private static lambda$registerFood$0(plugin: cn.nukkit.plugin.Plugin,food: cn.nukkit.item.food.Food,n: cn.nukkit.item.food.Food.NodeIDMeta): void;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentMending extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class WaterDripParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
     class BlockBricksRedNether extends cn.nukkit.block.BlockNetherBrick{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.command{
     class PluginCommand extends cn.nukkit.command.Command{
        /**  */
        executor: cn.nukkit.command.CommandExecutor;
        /**  */
        owningPlugin: cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public getPlugin(): cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public getExecutor(): cn.nukkit.command.CommandExecutor;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
        /**
         * 
         * @param {cn.nukkit.command.CommandExecutor} executor 
         */
        public setExecutor(executor: cn.nukkit.command.CommandExecutor): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockObserver extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getWeakPower(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public onNeighborChange(side: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {boolean} powered 
         */
        public setPowered(powered: boolean): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityShootBowEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        force: double;
        /**  */
        bow: cn.nukkit.item.Item;
        /**  */
        projectile: cn.nukkit.entity.projectile.EntityProjectile;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} projectile 
         */
        public setProjectile(projectile: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {double} force 
         */
        public setForce(force: double): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getForce(): double;
        /**
         * 
         */
        public getProjectile(): cn.nukkit.entity.projectile.EntityProjectile;
        /**
         * 
         */
        public  getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.EntityLiving;
        /**
         * 
         */
        public getBow(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemSwordStone extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.level.format.generic{
    abstract class BaseChunk extends cn.nukkit.level.format.generic.BaseFullChunk{
        /**  */
        delayPaletteUpdates: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        sections: cn.nukkit.level.format.ChunkSection[];
        /**
         * 
         * @param {int} sectionY 
         */
        private createChunkSection(sectionY: int): void;
        /**
         * 
         * @param {float} fY 
         */
        public isSectionEmpty(fY: float): boolean;
        /**
         * 
         * @param {int} sectionY 
         */
        private getOrCreateMutableSection(sectionY: int): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockData(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         */
        public setBlock(x: int,y: int,z: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlock(x: int,y: int,z: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public setBlockLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockStateAtLayer(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         */
        public backwardCompatibilityUpdate(level: cn.nukkit.level.Level): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockStateAt(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,layer: int,fullId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,fullId: int): boolean;
        /**
         * 
         * @param {float} fY 
         * @param {cn.nukkit.level.format.ChunkSection} section 
         */
        public setSection(fY: float,section: cn.nukkit.level.format.ChunkSection): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockStateAt(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public isBlockedByBorder(x: int,z: int): boolean;
        /**
         * 
         * @param {float} fY 
         * @param {cn.nukkit.level.format.ChunkSection} section 
         */
        private setInternalSection(fY: float,section: cn.nukkit.level.format.ChunkSection): void;
        /**
         * 
         * @param {float} fY 
         */
        public getSection(fY: float): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         */
        public load(): boolean;
        /**
         * 
         * @param {boolean} generate 
         */
        public load(generate: boolean): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getFullBlock(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public findBorders(x: int,z: int): java.util.List;
        /**
         * 
         * @param {cn.nukkit.level.format.ChunkSection} section 
         */
        private static lambda$scanBlocks$2(section: cn.nukkit.level.format.ChunkSection): boolean;
        /**
         * 
         */
        public getProvider(): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         * @param {int} offsetX 
         * @param {int} offsetZ 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         * @param {cn.nukkit.level.format.ChunkSection} section 
         */
        private lambda$scanBlocks$3(offsetX: int,offsetZ: int,min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate,section: cn.nukkit.level.format.ChunkSection): java.util.List;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         */
        public scanBlocks(min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate): java.util.stream.Stream;
        /**
         * 
         * @param {int} sectionY 
         */
        private lambda$scanBlocks$0(sectionY: int): boolean;
        /**
         * 
         * @param {int} sectionY 
         */
        private lambda$scanBlocks$1(sectionY: int): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         */
        public getBlockLightArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockLight(x: int,y: int,z: int): int;
        /**
         * 
         */
        public getHeightMapArray(): byte[];
        /**
         * 
         */
        public isPaletteUpdatesDelayed(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         */
        public getAndSetBlock(x: int,y: int,z: int,layer: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.block.Block} block 
         */
        public getAndSetBlock(x: int,y: int,z: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public setBlockData(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockId(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public setBlockId(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {boolean} delayPaletteUpdates 
         */
        public setPaletteUpdatesDelayed(delayPaletteUpdates: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public setBlockSkyLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         */
        public delayPaletteUpdates(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public getAndSetBlockState(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getBlockSkyLightArray(): byte[];
        /**
         * 
         */
        public  clone(): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.level.format.generic.BaseChunk;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public isBlockChangeAllowed(x: int,y: int,z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockState(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private removeInvalidTile(x: int,y: int,z: int): void;
        /**
         * 
         */
        public getSections(): cn.nukkit.level.format.ChunkSection[];
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace world{
    /**
     * 清空坐标所在区块
     * @param {cn.nukkit.level.Position} pos 坐标
     */
    function clearChunk(pos: cn.nukkit.level.Position): void;
    /**
     * 在指定坐标根据图片绘制地图画
     * @param {cn.nukkit.level.Position} pos1 地图画绘制起始点
     * @param {cn.nukkit.level.Position} pos2 地图画绘制终点
     * @param {java.lang.String} img 地图画的图片路径
     * @param {int} faceData 单个地图的朝向
     */
    function drawPic(pos1: cn.nukkit.level.Position,pos2: cn.nukkit.level.Position,img: java.lang.String,faceData: int): void;
    /**
     * 
     */
    function dosaveSkyLandGeneratorSettings(): void;
    /**
     * 获取服务器上的所有世界
     */
    function getServerLevels(): java.util.List;
    /**
     * 设置海洋世界生成器参数
     * @param {int} seaLevel 海平面高度y
     */
    function setOceanGenerator(seaLevel: int): void;
    /**
     * 
     */
    function doreloadSkyLandGeneratorSettings(): void;
    /**
     * 
     */
    function doreloadOceanGeneratorSettings(): void;
    /**
     * 
     */
    function dosaveOceanGeneratorSettings(): void;
    /**
     * 跨维度传送玩家(有维度加载动画)
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {cn.nukkit.level.Position} pos 目的地
     */
    function loadScreenTP(player: cn.nukkit.Player,pos: cn.nukkit.level.Position): void;
    /**
     * 跨维度传送玩家(有维度加载动画)
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {cn.nukkit.level.Position} pos 目的地
     * @param {int} loadScreenTick 跨纬度加载界面停留时间(刻)
     */
    function loadScreenTP(player: cn.nukkit.Player,pos: cn.nukkit.level.Position,loadScreenTick: int): void;
    /**
     * 跨维度传送玩家(有维度加载动画)
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {cn.nukkit.level.Position} pos 目的地
     * @param {int} loadScreenTick 跨纬度加载界面停留时间(刻)
     * @param {boolean} finish 是否为最后一阶段
     */
    function loadScreenTP(player: cn.nukkit.Player,pos: cn.nukkit.level.Position,loadScreenTick: int,finish: boolean): void;
    /**
     * 设置镜像天域生成器参数，详见bnwiki#编程开发文档
     * @param {int} seaHeight 
     * @param {int} movey 
     * @param {boolean} enableOre 
     * @param {int} coalcount 
     * @param {int} coalsize 
     * @param {int} coalmin 
     * @param {int} coalmax 
     * @param {int} ironcount 
     * @param {int} ironsize 
     * @param {int} ironmin 
     * @param {int} ironmax 
     * @param {int} redstonecount 
     * @param {int} redstonesize 
     * @param {int} redstonemin 
     * @param {int} redstonemax 
     * @param {int} lapiscount 
     * @param {int} lapissize 
     * @param {int} lapismin 
     * @param {int} lapismax 
     * @param {int} goldcount 
     * @param {int} goldsize 
     * @param {int} goldmin 
     * @param {int} goldmax 
     * @param {int} diamondcount 
     * @param {int} diamondsize 
     * @param {int} diamondmin 
     * @param {int} diamondmax 
     * @param {int} dirtcount 
     * @param {int} dirtsize 
     * @param {int} dirtmin 
     * @param {int} dirtmax 
     * @param {int} gravelcount 
     * @param {int} gravelsize 
     * @param {int} gravelmin 
     * @param {int} gravelmax 
     * @param {int} granitecount 
     * @param {int} granitesize 
     * @param {int} granitemin 
     * @param {int} granitemax 
     * @param {int} dioritecount 
     * @param {int} dioritesize 
     * @param {int} dioritemin 
     * @param {int} dioritemax 
     * @param {int} andesitecount 
     * @param {int} andesitesize 
     * @param {int} andesitemin 
     * @param {int} andesitemax 
     * @param {boolean} enableCave 
     * @param {boolean} enableBiome 
     * @param {boolean} enableOcean 
     */
    function setSkyLandGenerator(seaHeight: int,movey: int,enableOre: boolean,coalcount: int,coalsize: int,coalmin: int,coalmax: int,ironcount: int,ironsize: int,ironmin: int,ironmax: int,redstonecount: int,redstonesize: int,redstonemin: int,redstonemax: int,lapiscount: int,lapissize: int,lapismin: int,lapismax: int,goldcount: int,goldsize: int,goldmin: int,goldmax: int,diamondcount: int,diamondsize: int,diamondmin: int,diamondmax: int,dirtcount: int,dirtsize: int,dirtmin: int,dirtmax: int,gravelcount: int,gravelsize: int,gravelmin: int,gravelmax: int,granitecount: int,granitesize: int,granitemin: int,granitemax: int,dioritecount: int,dioritesize: int,dioritemin: int,dioritemax: int,andesitecount: int,andesitesize: int,andesitemin: int,andesitemax: int,enableCave: boolean,enableBiome: boolean,enableOcean: boolean): void;
    /**
     * 为指定名称的世界加载器绑定世界渲染器
     * @param {java.lang.String} forLevel 世界名
     * @param {java.lang.String} callback 世界渲染器回调函数，参数(cn.nukkit.level.Level世界对象, cn.nukkit.level.format.FullChunk区块对象)
     * @param {int} priority 权重，越高越优先调用
     */
    function defineChunkRenderByName(forLevel: java.lang.String,callback: Fun2<cn.nukkit.level.Level,cn.nukkit.level.format.FullChunk>,priority: int): void;
    /**
     * 为指定名称的世界加载器绑定世界渲染器
     * @param {java.lang.String} forLevel 世界名
     * @param {java.lang.String} callback 世界渲染器回调函数，参数(cn.nukkit.level.Level世界对象, cn.nukkit.level.format.FullChunk区块对象)
     */
    function defineChunkRenderByName(forLevel: java.lang.String,callback: Fun2<cn.nukkit.level.Level,cn.nukkit.level.format.FullChunk>): void;
    /**
     * 生成新世界
     * @param {java.lang.String} name 新世界名
     * @param {long} seed 种子
     * @param {java.lang.String} generator 生成器名称，可选NORMAL/FLAT/NETHER/VOID/OCEAN/SKYLAND
     */
    function genLevel(name: java.lang.String,seed: long,generator: java.lang.String): void;
    /**
     * 为所有世界加载器绑定世界渲染器
     * @param {java.lang.String} callback 世界渲染器回调函数，参数(cn.nukkit.level.Level世界对象, cn.nukkit.level.format.FullChunk区块对象)
     * @param {int} priority 权重，越高越优先调用
     */
    function defineChunkRenderAll(callback: Fun2<cn.nukkit.level.Level,cn.nukkit.level.format.FullChunk>,priority: int): void;
    /**
     * 为所有世界加载器绑定世界渲染器
     * @param {java.lang.String} callback 世界渲染器回调函数，参数(cn.nukkit.level.Level世界对象, cn.nukkit.level.format.FullChunk区块对象)
     */
    function defineChunkRenderAll(callback: Fun2<cn.nukkit.level.Level,cn.nukkit.level.format.FullChunk>): void;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 
     * @param {int} seaHeight 
     * @param {int} movey 
     * @param {boolean} enableOre 
     * @param {int} coalcount 
     * @param {int} coalsize 
     * @param {int} coalmin 
     * @param {int} coalmax 
     * @param {int} ironcount 
     * @param {int} ironsize 
     * @param {int} ironmin 
     * @param {int} ironmax 
     * @param {int} redstonecount 
     * @param {int} redstonesize 
     * @param {int} redstonemin 
     * @param {int} redstonemax 
     * @param {int} lapiscount 
     * @param {int} lapissize 
     * @param {int} lapismin 
     * @param {int} lapismax 
     * @param {int} goldcount 
     * @param {int} goldsize 
     * @param {int} goldmin 
     * @param {int} goldmax 
     * @param {int} diamondcount 
     * @param {int} diamondsize 
     * @param {int} diamondmin 
     * @param {int} diamondmax 
     * @param {int} dirtcount 
     * @param {int} dirtsize 
     * @param {int} dirtmin 
     * @param {int} dirtmax 
     * @param {int} gravelcount 
     * @param {int} gravelsize 
     * @param {int} gravelmin 
     * @param {int} gravelmax 
     * @param {int} granitecount 
     * @param {int} granitesize 
     * @param {int} granitemin 
     * @param {int} granitemax 
     * @param {int} dioritecount 
     * @param {int} dioritesize 
     * @param {int} dioritemin 
     * @param {int} dioritemax 
     * @param {int} andesitecount 
     * @param {int} andesitesize 
     * @param {int} andesitemin 
     * @param {int} andesitemax 
     * @param {boolean} enableCave 
     * @param {boolean} enableBiome 
     * @param {boolean} enableOcean 
     */
    function setSkyLandGeneratorStatic(seaHeight: int,movey: int,enableOre: boolean,coalcount: int,coalsize: int,coalmin: int,coalmax: int,ironcount: int,ironsize: int,ironmin: int,ironmax: int,redstonecount: int,redstonesize: int,redstonemin: int,redstonemax: int,lapiscount: int,lapissize: int,lapismin: int,lapismax: int,goldcount: int,goldsize: int,goldmin: int,goldmax: int,diamondcount: int,diamondsize: int,diamondmin: int,diamondmax: int,dirtcount: int,dirtsize: int,dirtmin: int,dirtmax: int,gravelcount: int,gravelsize: int,gravelmin: int,gravelmax: int,granitecount: int,granitesize: int,granitemin: int,granitemax: int,dioritecount: int,dioritesize: int,dioritemin: int,dioritemax: int,andesitecount: int,andesitesize: int,andesitemin: int,andesitemax: int,enableCave: boolean,enableBiome: boolean,enableOcean: boolean): void;
    /**
     * 重新生成坐标所在区块区块
     * @param {cn.nukkit.level.Position} pos 坐标
     */
    function regenerateChunk(pos: cn.nukkit.level.Position): void;
    /**
     * 强制加载世界
     * @param {java.lang.String} string 世界名
     */
    function loadLevel(string: java.lang.String): void;
}
declare namespace org.java_websocket.handshake{
    abstract class Handshakedata extends java.lang.Object{
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public abstract hasFieldValue(arg0: java.lang.String): boolean;
        /**
         * 
         */
        public abstract iterateHttpFields(): java.util.Iterator;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public abstract getFieldValue(arg0: java.lang.String): java.lang.String;
        /**
         * 
         */
        public abstract getContent(): byte[];
    }
}
declare namespace cn.nukkit.item{
     class ItemBlazeRod extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.inventory{
    abstract class MixRecipe extends java.lang.Object{
        /**  */
        output: cn.nukkit.item.Item;
        /**  */
        input: cn.nukkit.item.Item;
        /**  */
        ingredient: cn.nukkit.item.Item;
        /**
         * 
         */
        public getIngredient(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getResult(): cn.nukkit.item.Item;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getInput(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockWeightedPressurePlateLight extends cn.nukkit.block.BlockPressurePlateBase{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getMaxWeight(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        protected computeRedstoneStrength(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.form.response{
    abstract class FormResponse extends java.lang.Object{
    }
}
declare namespace cn.nukkit.entity.weather{
     class EntityLightning extends cn.nukkit.entity.Entity{
        /**  */
        NETWORK_ID: int;
        /**  */
        isEffect: boolean;
        /**  */
        liveTime: int;
        /**  */
        state: int;
        /**
         * 
         * @param {boolean} e 
         */
        public setEffect(e: boolean): void;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public isEffect(): boolean;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace com.blocklynukkit.loader.script.window{
     class Simple extends java.lang.Object{
        /**  */
        previousButton: cn.nukkit.form.element.ElementButton;
        /**  */
        buttonsMap: java.util.LinkedHashMap;
        /**  */
        context: java.lang.String;
        /**  */
        id: int;
        /**  */
        title: java.lang.String;
        /**
         * 向窗口添加一个按钮
         * @param {java.lang.String} text 按钮文本
         * @param {java.lang.String} img 按钮图片链接，可为材质包内部链接或网络url
         */
        public button(text: java.lang.String,img: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向窗口添加一个按钮
         * @param {java.lang.String} text 按钮文本
         */
        public button(text: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向窗口添加一个按钮
         * @param {java.lang.String} text 按钮文本
         * @param {java.lang.String} img 按钮图片链接，可为材质包内部链接或网络url
         */
        public buildButton(text: java.lang.String,img: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 为上一个添加的按钮绑定点击动作回调
         * @param {java.lang.String} action 回调函数
         */
        public setAction(action: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 设置窗口提示文本
         * @param {java.lang.String} context 窗口提示文本
         */
        public context(context: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 设置窗口提示文本
         * @param {java.lang.String} context 窗口提示文本
         */
        public setContext(context: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         */
        public show(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         */
        public show(p: cn.nukkit.Player): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {boolean} accpetClose 玩家关闭窗口是否触发回调
         */
        public show(p: cn.nukkit.Player,accpetClose: boolean): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public show(p: cn.nukkit.Player,callback: java.lang.String,acceptClose: boolean): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 为上一个添加的按钮绑定点击动作回调
         * @param {java.lang.String} action 回调函数
         */
        public action(action: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 设置窗口标题
         * @param {java.lang.String} title 窗口标题
         */
        public setTitle(title: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 设置窗口标题
         * @param {java.lang.String} title 窗口标题
         */
        public title(title: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         */
        public showToPlayer(p: cn.nukkit.Player): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public showToPlayer(p: cn.nukkit.Player,callback: java.lang.String,acceptClose: boolean): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         */
        public showToPlayer(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Simple;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public showToPlayer(p: cn.nukkit.Player,acceptClose: boolean): com.blocklynukkit.loader.script.window.Simple;
    }
}
declare namespace cn.nukkit.level.generator.object.tree{
    abstract class TreeGenerator extends cn.nukkit.level.generator.object.BasicGenerator{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.BlockVector3} pos 
         */
        protected setDirtAt(level: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.BlockVector3): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        protected setDirtAt(level: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {int} id 
         */
        protected canGrowInto(id: int): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {java.util.Random} random 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public generateSaplings(level: cn.nukkit.level.Level,random: java.util.Random,pos: cn.nukkit.math.Vector3): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityCaveSpider extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorIron extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item{
     class ItemBlock extends cn.nukkit.item.Item{
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public  clone(): cn.nukkit.item.Item;
        /**
         * 
         */
        public clone(): cn.nukkit.item.ItemBlock;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         * @param {java.lang.Integer} meta 
         */
        public setDamage(meta: java.lang.Integer): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockTrapdoor extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        TRAPDOOR_OPEN_BIT: int;
        /**  */
        TRAPDOOR_TOP_BIT: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        manualOverrides: java.util.List;
        /**  */
        boundingBoxDamage: cn.nukkit.math.AxisAlignedBB[];
        /**  */
        TRAPDOOR_DIRECTION: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        THICKNESS: double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} open 
         */
        public setOpen(player: cn.nukkit.Player,open: boolean): boolean;
        /**
         * 
         * @param {boolean} open 
         */
        public setOpen(open: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getManualOverride(): boolean;
        /**
         * 
         */
        public playOpenSound(): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {boolean} top 
         */
        public setTop(top: boolean): void;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {boolean} val 
         */
        public setManualOverride(val: boolean): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public toggle(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         */
        public playOpenCloseSound(): void;
        /**
         * 
         */
        public isOpen(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public isTop(): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public playCloseSound(): void;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        private getRelativeBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getMinY(): double;
    }
}
declare namespace cn.nukkit.block{
     class BlockButtonStone extends cn.nukkit.block.BlockButton{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
    }
}
declare namespace cn.nukkit.item{
     class ItemPickaxeStone extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isPickaxe(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracotta extends cn.nukkit.block.BlockSolidMeta{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.TerracottaColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockJukebox extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityPig extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreedingItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemBootsNetherite extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetDifficultyPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        difficulty: int;
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockFromToEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        to: cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.block.Block} newTo 
         */
        public setTo(newTo: cn.nukkit.block.Block): void;
        /**
         * 
         */
        public getTo(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getFrom(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class FloatTag extends cn.nukkit.nbt.tag.NumberTag{
        /**  */
        data: float;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         * @param {java.lang.Float} data 
         */
        public setData(data: java.lang.Float): void;
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public  setData(data: java.lang.Number): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): java.lang.Float;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public  getData(): java.lang.Number;
        /**
         * 
         */
        public getData(): java.lang.Float;
    }
}
declare namespace cn.nukkit.event.entity{
     class CreeperPowerEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        cause: cn.nukkit.event.entity.CreeperPowerEvent.PowerCause;
        /**  */
        bolt: cn.nukkit.entity.weather.EntityLightningStrike;
        /**
         * 
         */
        public getLightning(): cn.nukkit.entity.weather.EntityLightningStrike;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.mob.EntityCreeper;
        /**
         * 
         */
        public getCause(): cn.nukkit.event.entity.CreeperPowerEvent.PowerCause;
    }
}
declare namespace cn.nukkit.block{
     class BlockSugarcane extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        AGE: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        private isSupportValid(): boolean;
    }
}
declare namespace cn.nukkit.command{
     class ConsoleCommandSender extends java.lang.Object{
        /**  */
        perm: cn.nukkit.permission.PermissibleBase;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         */
        public isPlayer(): boolean;
        /**
         * 
         */
        public getEffectivePermissions(): java.util.Map;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {boolean} value 
         */
        public setOp(value: boolean): void;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public hasPermission(name: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} message 
         */
        public sendMessage(message: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public sendMessage(message: java.lang.String): void;
        /**
         * 
         */
        public isOp(): boolean;
        /**
         * 
         */
        public recalculatePermissions(): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         * @param {java.lang.Boolean} value 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String,value: java.lang.Boolean): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.permission.PermissionAttachment} attachment 
         */
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isPermissionSet(name: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockGlass extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetPlayerGameTypePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        gamemode: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.projectile{
     class EntityEnderPearl extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        private teleport(): void;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        protected getGravity(): float;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerBucketEmptyEvent extends cn.nukkit.event.player.PlayerBucketEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getBucket(): cn.nukkit.item.Item;
        /**
         * 
         */
        public  getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public  setItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public  getBlockClicked(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.block{
    abstract class Block extends cn.nukkit.level.Position{
        /**  */
        diffusesSkyLight: boolean[];
        /**  */
        solid: boolean[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        EMPTY_ARRAY: cn.nukkit.block.Block[];
        /**  */
        MAX_BLOCK_ID: int;
        /**  */
        DATA_SIZE: int;
        /**  */
        initializing: boolean;
        /**  */
        list: java.lang.Class[];
        /**  */
        DATA_MASK: int;
        /**  */
        transparent: boolean[];
        /**  */
        layer: int;
        /**  */
        lightFilter: int[];
        /**  */
        DATA_BITS: int;
        /**  */
        hardness: double[];
        /**  */
        light: int[];
        /**  */
        hasMeta: boolean[];
        /**  */
        mutableState: cn.nukkit.blockstate.MutableBlockState;
        /**  */
        fullList: cn.nukkit.block.Block[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public  canRandomTick(): boolean;
        /**
         * 
         */
        public  getDataStorage(): java.lang.Number;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         * @param {int} meta 
         */
        public setDamage(meta: int): void;
        /**
         * 
         * @param {java.lang.Integer} meta 
         */
        public  setDamage(meta: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Number} storage 
         * @param {boolean} repair 
         * @param {java.util.function.Consumer} callback 
         */
        public setDataStorage(storage: java.lang.Number,repair: boolean,callback: java.util.function.Consumer): boolean;
        /**
         * 
         * @param {java.lang.Number} storage 
         */
        public setDataStorage(storage: java.lang.Number): void;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public onNeighborChange(side: cn.nukkit.math.BlockFace): void;
        /**
         * 
         * @param {java.lang.String} propertyName 
         */
        public getBooleanValue(propertyName: java.lang.String): boolean;
        /**
         * 
         */
        public getLegacyDamage(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getDamage(): int;
        /**
         * 
         */
        public static init(): void;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {int} hasteLoreLevel 
         */
        private static speedRateByHasteLore0(hasteLoreLevel: int): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public isDefaultState(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isGettingPower(): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getWeakPower(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} newBlock 
         * @param {boolean} update 
         */
        public afterRemoval(newBlock: cn.nukkit.block.Block,update: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getMinZ(): double;
        /**
         * 
         */
        public getMinX(): double;
        /**
         * 
         */
        public getMinY(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {int} layer 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public mustDrop(vector: cn.nukkit.math.Vector3,layer: int,face: cn.nukkit.math.BlockFace,item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {int} step 
         * @param {int} layer 
         */
        public south(step: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         */
        public  south(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  south(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public south(): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         */
        public south(step: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public north(): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         */
        public north(step: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         * @param {int} layer 
         */
        public north(step: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         */
        public  north(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  north(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        protected  getMutableState(): cn.nukkit.blockstate.MutableBlockState;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public collidesWithBB(bb: cn.nukkit.math.AxisAlignedBB): boolean;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} collisionBB 
         */
        public collidesWithBB(bb: cn.nukkit.math.AxisAlignedBB,collisionBB: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public  getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public  getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public  getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public  getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.level.Position;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public addVelocityToEntity(entity: cn.nukkit.entity.Entity,vector: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {java.lang.String} propertyName 
         */
        public getPersistenceValue(propertyName: java.lang.String): java.lang.String;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         */
        public static isInitializing(): boolean;
        /**
         * 
         * @param {int} efficiencyLoreLevel 
         */
        private static speedBonusByEfficiencyLore0(efficiencyLoreLevel: int): double;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getItemId(): int;
        /**
         * 
         * @param {double} blockHardness 
         * @param {boolean} correctTool 
         * @param {boolean} canHarvestWithHand 
         * @param {int} blockId 
         * @param {int} toolType 
         * @param {int} toolTier 
         * @param {int} efficiencyLoreLevel 
         * @param {int} hasteEffectLevel 
         * @param {boolean} insideOfWaterWithoutAquaAffinity 
         * @param {boolean} outOfWaterButNotOnGround 
         */
        private static breakTime0(blockHardness: double,correctTool: boolean,canHarvestWithHand: boolean,blockId: int,toolType: int,toolTier: int,efficiencyLoreLevel: int,hasteEffectLevel: int,insideOfWaterWithoutAquaAffinity: boolean,outOfWaterButNotOnGround: boolean): double;
        /**
         * 
         * @param {int} fullId 
         * @param {cn.nukkit.level.Level} level 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public static get(fullId: int,level: cn.nukkit.level.Level,x: int,y: int,z: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} fullId 
         * @param {cn.nukkit.level.Level} level 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public static get(fullId: int,level: cn.nukkit.level.Level,x: int,y: int,z: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {int} data 
         */
        public static get(id: int,data: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {int} meta 
         * @param {cn.nukkit.level.Level} level 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public static get(id: int,meta: int,level: cn.nukkit.level.Level,x: int,y: int,z: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {int} meta 
         * @param {cn.nukkit.level.Level} level 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public static get(id: int,meta: int,level: cn.nukkit.level.Level,x: int,y: int,z: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         */
        public static get(id: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         */
        public static get(id: int,meta: java.lang.Integer): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         * @param {cn.nukkit.level.Position} pos 
         */
        public static get(id: int,meta: java.lang.Integer,pos: cn.nukkit.level.Position): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.Integer} meta 
         * @param {cn.nukkit.level.Position} pos 
         * @param {int} layer 
         */
        public static get(id: int,meta: java.lang.Integer,pos: cn.nukkit.level.Position,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} layer 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public getSideAtLayer(layer: int,face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} layer 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getSideAtLayer(layer: int,face: cn.nukkit.math.BlockFace): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public canBePlaced(): boolean;
        /**
         * 
         * @param {java.lang.String} propertyName 
         * @param {boolean} value 
         */
        public setBooleanValue(propertyName: java.lang.String,value: boolean): void;
        /**
         * 
         */
        public getMaxX(): double;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public hasMetadata(metadataKey: java.lang.String): boolean;
        /**
         * 
         */
        public tickRate(): int;
        /**
         * 
         */
        public getMaxZ(): double;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public setMetadata(metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public isSideFull(face: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} b1 
         * @param {cn.nukkit.block.Block} b2 
         * @param {boolean} checkDamage 
         */
        public static equals(b1: cn.nukkit.block.Block,b2: cn.nukkit.block.Block,checkDamage: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} b1 
         * @param {cn.nukkit.block.Block} b2 
         */
        public static equals(b1: cn.nukkit.block.Block,b2: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {int} storage 
         * @param {boolean} repair 
         * @param {java.util.function.Consumer} callback 
         */
        public setDataStorageFromInt(storage: int,repair: boolean,callback: java.util.function.Consumer): boolean;
        /**
         * 
         * @param {int} storage 
         */
        public setDataStorageFromInt(storage: int): void;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public isSoulSpeedCompatible(): boolean;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         * @param {java.lang.Integer} l 
         */
        private static lambda$calculateBreakTime$0(l: java.lang.Integer): java.lang.Boolean;
        /**
         * 
         */
        public getSignedBigDamage(): int;
        /**
         * 
         */
        public getSaveId(): java.lang.String;
        /**
         * 
         */
        public  down(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public  down(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public down(step: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public down(): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         * @param {int} layer 
         */
        public down(step: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public canBeClimbed(): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} projectile 
         * @param {cn.nukkit.level.Position} position 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public onProjectileHit(projectile: cn.nukkit.entity.Entity,position: cn.nukkit.level.Position,motion: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.blockstate.IBlockState} state 
         */
        public  forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.blockstate.IMutableBlockState;
        /**
         * 
         * @param {cn.nukkit.blockstate.IBlockState} state 
         */
        public forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onActivate(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getItemMaxStackSize(): int;
        /**
         * 
         */
        public isFullBlock(): boolean;
        /**
         * 
         */
        public  west(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public  west(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public west(step: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         * @param {int} layer 
         */
        public west(step: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public west(): cn.nukkit.block.Block;
        /**
         * 
         */
        public  getExactIntStorage(): int;
        /**
         * 
         * @param {int} step 
         */
        public up(step: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public  up(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public  up(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public up(): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         * @param {int} layer 
         */
        public up(step: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public isNormalBlock(): boolean;
        /**
         * 
         */
        public getFrictionFactor(): double;
        /**
         * 
         */
        public diffusesSkyLight(): boolean;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public getMetadata(metadataKey: java.lang.String): java.util.List;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canHarvest(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        private toolBreakTimeBonus0(item: cn.nukkit.item.Item): double;
        /**
         * 
         * @param {int} toolType 
         * @param {int} toolTier 
         * @param {int} blockId 
         */
        private static toolBreakTimeBonus0(toolType: int,toolTier: int,blockId: int): double;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getLocationHash(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public calculateBreakTime(item: cn.nukkit.item.Item,player: cn.nukkit.Player): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public calculateBreakTime(item: cn.nukkit.item.Item): double;
        /**
         * 
         */
        public getHugeDamage(): java.math.BigInteger;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         * @param {java.lang.String} propertyName 
         * @param {java.io.Serializable} value 
         */
        public setPropertyValue(propertyName: java.lang.String,value: java.io.Serializable): void;
        /**
         * 
         */
        public isSimpleBlock(): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Position} v 
         */
        public  position(v: cn.nukkit.level.Position): void;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canBeBrokenWith(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {java.lang.String} propertyName 
         */
        public getIntValue(propertyName: java.lang.String): int;
        /**
         * 
         */
        public getFullId(): int;
        /**
         * 
         */
        public abstract getId(): int;
        /**
         * 
         */
        public getLightFilter(): int;
        /**
         * 
         */
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         * @param {int} step 
         * @param {int} layer 
         */
        public east(step: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} step 
         */
        public east(step: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public  east(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public  east(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public east(): cn.nukkit.block.Block;
        /**
         * 
         */
        public  getBlockId(): int;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public  getCurrentState(): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} startingLayer 
         * @param {java.util.function.Predicate} condition 
         */
        public firstInLayers(startingLayer: int,condition: java.util.function.Predicate): java.util.Optional;
        /**
         * 
         * @param {java.util.function.Predicate} condition 
         */
        public firstInLayers(condition: java.util.function.Predicate): java.util.Optional;
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         * @param {int} blockToolType 
         * @param {cn.nukkit.item.Item} item 
         * @param {int} blockId 
         */
        private static correctTool0(blockToolType: int,item: cn.nukkit.item.Item,blockId: int): boolean;
        /**
         * 
         */
        public  getBlock(): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {int} blockId 
         */
        private static toolType0(item: cn.nukkit.item.Item,blockId: int): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos1 
         * @param {cn.nukkit.math.Vector3} pos2 
         */
        public calculateIntercept(pos1: cn.nukkit.math.Vector3,pos2: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getBigDamage(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getDropExp(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {int} layer 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} setBlockDestroy 
         */
        public isBreakable(vector: cn.nukkit.math.Vector3,layer: int,face: cn.nukkit.math.BlockFace,item: cn.nukkit.item.Item,player: cn.nukkit.Player,setBlockDestroy: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.potion.Effect} e 
         */
        private static lambda$getBreakTime$1(e: cn.nukkit.potion.Effect): java.lang.Integer;
        /**
         * 
         * @param {java.lang.Integer} l 
         */
        private static lambda$getBreakTime$2(l: java.lang.Integer): java.lang.Boolean;
        /**
         * 
         */
        public  canWaterloggingFlowInto(): boolean;
        /**
         * 
         * @param {int} blockId 
         * @param {java.lang.Class} blockClass 
         * @param {java.lang.String} persistenceName 
         * @param {boolean} receivesRandomTick 
         */
        public static registerBlockImplementation(blockId: int,blockClass: java.lang.Class,persistenceName: java.lang.String,receivesRandomTick: boolean): void;
        /**
         * 
         * @param {java.lang.String} propertyName 
         * @param {int} value 
         */
        public setIntValue(propertyName: java.lang.String,value: int): void;
        /**
         * 
         * @param {java.lang.String} propertyName 
         */
        public getPropertyValue(propertyName: java.lang.String): java.io.Serializable;
        /**
         * 
         */
        public  asItemBlock(): cn.nukkit.item.ItemBlock;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {int} layer 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public mustSilkTouch(vector: cn.nukkit.math.Vector3,layer: int,face: cn.nukkit.math.BlockFace,item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public removeMetadata(metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         */
        public  getRuntimeId(): int;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  clone(): cn.nukkit.positiontracking.NamedPosition;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.block.Block;
        /**
         * 
         */
        public  clone(): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.blockstate.IBlockState} state 
         */
        public setState(state: cn.nukkit.blockstate.IBlockState): void;
        /**
         * 
         */
        public  isBlockChangeAllowed(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public  isBlockChangeAllowed(player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getBreakTime(item: cn.nukkit.item.Item): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public getBreakTime(item: cn.nukkit.item.Item,player: cn.nukkit.Player): double;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.event.player.PlayerInteractEvent.Action} action 
         */
        public onTouch(player: cn.nukkit.Player,action: cn.nukkit.event.player.PlayerInteractEvent.Action): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityCow extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemChickenCooked extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.entity.projectile{
     class EntityThrownTrident extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        stuckToBlockPos: cn.nukkit.math.BlockVector3;
        /**  */
        isCreative: boolean;
        /**  */
        defaultStuckToBlockPos: cn.nukkit.math.BlockVector3;
        /**  */
        trident: cn.nukkit.item.Item;
        /**  */
        NETWORK_ID: int;
        /**  */
        DATA_SOURCE_ID: int;
        /**  */
        defaultCollisionPos: cn.nukkit.math.Vector3;
        /**  */
        favoredSlot: int;
        /**  */
        loyaltyLevel: int;
        /**  */
        impalingLevel: int;
        /**  */
        gravity: float;
        /**  */
        collisionPos: cn.nukkit.math.Vector3;
        /**  */
        riptideLevel: int;
        /**  */
        hasChanneling: boolean;
        /**  */
        drag: float;
        /**  */
        player: boolean;
        /**
         * 
         */
        public isPlayer(): boolean;
        /**
         * 
         */
        public isCreative(): boolean;
        /**
         * 
         * @param {int} loyaltyLevel 
         */
        public setLoyaltyLevel(loyaltyLevel: int): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} position 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        protected onCollideWithBlock(position: cn.nukkit.level.Position,motion: cn.nukkit.math.Vector3): void;
        /**
         * 
         */
        public getStuckToBlockPos(): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public getTridentRope(): boolean;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getLoyaltyLevel(): int;
        /**
         * 
         */
        protected getBaseDamage(): double;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {boolean} hasChanneling 
         */
        public setChanneling(hasChanneling: boolean): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setCritical(value: boolean): void;
        /**
         * 
         */
        public setCritical(): void;
        /**
         * 
         */
        public getResultDamage(): int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onCollideWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getDrag(): float;
        /**
         * 
         */
        public getCollisionPos(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {java.lang.Object} type 
         * @param {cn.nukkit.level.Position} source 
         * @param {java.lang.Object[]} args 
         */
        public  create(type: java.lang.Object,source: cn.nukkit.level.Position,...args: java.lang.Object[]): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getGravity(): float;
        /**
         * 
         * @param {int} favoredSlot 
         */
        public setFavoredSlot(favoredSlot: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {boolean} isCreative 
         */
        public setCreative(isCreative: boolean): void;
        /**
         * 
         */
        public canReturnToShooter(): boolean;
        /**
         * 
         * @param {boolean} player 
         */
        public setPlayer(player: boolean): void;
        /**
         * 
         */
        public getRiptideLevel(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} stuckToBlockPos 
         */
        public setStuckToBlockPos(stuckToBlockPos: cn.nukkit.math.BlockVector3): void;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {boolean} tridentRope 
         */
        public setTridentRope(tridentRope: boolean): void;
        /**
         * 
         */
        public getImpalingLevel(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} collisionPos 
         */
        public setCollisionPos(collisionPos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {int} impalingLevel 
         */
        public setImpalingLevel(impalingLevel: int): void;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public isCritical(): boolean;
        /**
         * 
         */
        public getFavoredSlot(): int;
        /**
         * 
         */
        public hasChanneling(): boolean;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {int} riptideLevel 
         */
        public setRiptideLevel(riptideLevel: int): void;
    }
}
declare namespace cn.nukkit.math{
     class Vector2 extends java.lang.Object{
        /**  */
        x: double;
        /**  */
        y: double;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public add(x: double,y: double): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} x 
         */
        public add(x: cn.nukkit.math.Vector2): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {double} x 
         */
        public add(x: double): cn.nukkit.math.Vector2;
        /**
         * 
         */
        public lengthSquared(): double;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public distance(x: double,y: double): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} vector 
         */
        public distance(vector: cn.nukkit.math.Vector2): double;
        /**
         * 
         * @param {double} x 
         */
        public distance(x: double): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} x 
         */
        public subtract(x: cn.nukkit.math.Vector2): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {double} x 
         */
        public subtract(x: double): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public subtract(x: double,y: double): cn.nukkit.math.Vector2;
        /**
         * 
         */
        public length(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} v 
         */
        public dot(v: cn.nukkit.math.Vector2): double;
        /**
         * 
         */
        public getFloorY(): int;
        /**
         * 
         */
        public getFloorX(): int;
        /**
         * 
         */
        public ceil(): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {double} x 
         */
        public distanceSquared(x: double): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} vector 
         */
        public distanceSquared(vector: cn.nukkit.math.Vector2): double;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public distanceSquared(x: double,y: double): double;
        /**
         * 
         */
        public getX(): double;
        /**
         * 
         */
        public abs(): cn.nukkit.math.Vector2;
        /**
         * 
         */
        public getY(): double;
        /**
         * 
         */
        public round(): cn.nukkit.math.Vector2;
        /**
         * 
         */
        public normalize(): cn.nukkit.math.Vector2;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {double} number 
         */
        public divide(number: double): cn.nukkit.math.Vector2;
        /**
         * 
         */
        public floor(): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {double} number 
         */
        public multiply(number: double): cn.nukkit.math.Vector2;
    }
}
declare namespace cn.nukkit.network.protocol{
     class LoginPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        clientUUID: java.util.UUID;
        /**  */
        protocol: int;
        /**  */
        clientId: long;
        /**  */
        NETWORK_ID: byte;
        /**  */
        skin: cn.nukkit.entity.data.Skin;
        /**  */
        username: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         * @param {com.google.gson.JsonObject} object 
         */
        public static getTint(object: com.google.gson.JsonObject): cn.nukkit.utils.PersonaPieceTint;
        /**
         * 
         * @param {com.google.gson.JsonObject} element 
         */
        private static getAnimation(element: com.google.gson.JsonObject): cn.nukkit.utils.SkinAnimation;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getProtocol(): int;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         * @param {com.google.gson.JsonObject} token 
         * @param {java.lang.String} name 
         */
        private static getImage(token: com.google.gson.JsonObject,name: java.lang.String): cn.nukkit.utils.SerializedImage;
        /**
         * 
         */
        private decodeSkinData(): void;
        /**
         * 
         * @param {com.google.gson.JsonObject} object 
         */
        private static getPersonaPiece(object: com.google.gson.JsonObject): cn.nukkit.utils.PersonaPiece;
        /**
         * 
         * @param {java.lang.String} token 
         */
        private decodeToken(token: java.lang.String): com.google.gson.JsonObject;
        /**
         * 
         */
        private decodeChainData(): void;
    }
}
declare namespace cn.nukkit.math{
     class Vector3 extends java.lang.Object{
        /**  */
        x: double;
        /**  */
        y: double;
        /**  */
        z: double;
        /**
         * 
         */
        public getChunkVector(): cn.nukkit.math.ChunkVector2;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {double} ax 
         * @param {double} ay 
         * @param {double} az 
         */
        public setComponentsAdding(x: double,y: double,z: double,ax: double,ay: double,az: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setComponentsAdding(pos: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getFloorY(): int;
        /**
         * 
         * @param {double} x 
         */
        public maxPlainDistance(x: double): double;
        /**
         * 
         * @param {double} x 
         * @param {double} z 
         */
        public maxPlainDistance(x: double,z: double): double;
        /**
         * 
         */
        public maxPlainDistance(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public maxPlainDistance(x: cn.nukkit.math.Vector3): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} vector 
         */
        public maxPlainDistance(vector: cn.nukkit.math.Vector2): double;
        /**
         * 
         */
        public getFloorX(): int;
        /**
         * 
         */
        public down(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public down(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getFloorZ(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public distanceSquared(pos: cn.nukkit.math.Vector3): double;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public distanceSquared(x: double,y: double,z: double): double;
        /**
         * 
         */
        public normalize(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public west(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public west(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public up(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public up(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         * @param {double} y 
         */
        public getIntermediateWithYValue(v: cn.nukkit.math.Vector3,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public add(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public add(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         */
        public add(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public setComponents(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setComponents(pos: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public asBlockVector3(): cn.nukkit.math.BlockVector3;
        /**
         * 
         */
        public getWest(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public subtract(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public subtract(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         */
        public subtract(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public subtract(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public ceil(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         * @param {double} z 
         */
        public getIntermediateWithZValue(v: cn.nukkit.math.Vector3,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getSouth(): double;
        /**
         * 
         */
        public rawHashCode(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public distance(pos: cn.nukkit.math.Vector3): double;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public distance(x: double,y: double,z: double): double;
        /**
         * 
         */
        public south(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public south(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public north(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public north(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         */
        public dot(v: cn.nukkit.math.Vector3): double;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getUp(): double;
        /**
         * 
         */
        public east(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} step 
         */
        public east(step: int): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getChunkSectionY(): int;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {double} number 
         */
        public divide(number: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public floor(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} number 
         */
        public multiply(number: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public lengthSquared(): double;
        /**
         * 
         */
        public length(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         */
        public cross(v: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace.Axis} axis 
         */
        public getAxis(axis: cn.nukkit.math.BlockFace.Axis): double;
        /**
         * 
         */
        public getX(): double;
        /**
         * 
         */
        public abs(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getY(): double;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         * @param {double} x 
         */
        public getIntermediateWithXValue(v: cn.nukkit.math.Vector3,x: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getRight(): double;
        /**
         * 
         */
        public round(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getChunkZ(): int;
        /**
         * 
         */
        public getZ(): double;
        /**
         * 
         */
        public getChunkX(): int;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public clone(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public asVector3f(): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getForward(): double;
    }
}
declare namespace cn.nukkit.network.protocol{
     class CraftingEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        TYPE_SHULKER_BOX: int;
        /**  */
        TYPE_FURNACE_DATA: int;
        /**  */
        TYPE_MULTI: int;
        /**  */
        TYPE_CRAFTING: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        TYPE_SHAPED: int;
        /**  */
        type: int;
        /**  */
        TYPE_WORKBENCH: int;
        /**  */
        windowId: int;
        /**  */
        output: cn.nukkit.item.Item[];
        /**  */
        input: cn.nukkit.item.Item[];
        /**  */
        TYPE_INVENTORY: int;
        /**  */
        TYPE_FURNACE: int;
        /**  */
        id: java.util.UUID;
        /**  */
        TYPE_SHAPELESS: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.inventory{
     class FurnaceBurnEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        burning: boolean;
        /**  */
        furnace: cn.nukkit.blockentity.BlockEntityFurnace;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        fuel: cn.nukkit.item.Item;
        /**  */
        burnTime: short;
        /**
         * 
         * @param {short} burnTime 
         */
        public setBurnTime(burnTime: short): void;
        /**
         * 
         */
        public getFuel(): cn.nukkit.item.Item;
        /**
         * 
         * @param {boolean} burning 
         */
        public setBurning(burning: boolean): void;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getBurnTime(): short;
        /**
         * 
         */
        public getFurnace(): cn.nukkit.blockentity.BlockEntityFurnace;
        /**
         * 
         */
        public isBurning(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemPrismarineShard extends cn.nukkit.item.Item{
    }
}
declare namespace java.net{
    abstract class SocketAddress extends java.lang.Object{
        /**  */
        serialVersionUID: long;
    }
}
declare namespace cn.nukkit.network.protocol{
     class AnimatePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        NETWORK_ID: byte;
        /**  */
        rowingTime: float;
        /**  */
        action: cn.nukkit.network.protocol.AnimatePacket.Action;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class FlameParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.utils{
     class LogLevel extends java.lang.Enum{
        /**  */
        EMERGENCY: cn.nukkit.utils.LogLevel;
        /**  */
        DEFAULT_LEVEL: cn.nukkit.utils.LogLevel;
        /**  */
        NOTICE: cn.nukkit.utils.LogLevel;
        /**  */
        ALERT: cn.nukkit.utils.LogLevel;
        /**  */
        INFO: cn.nukkit.utils.LogLevel;
        /**  */
        WARNING: cn.nukkit.utils.LogLevel;
        /**  */
        DEBUG: cn.nukkit.utils.LogLevel;
        /**  */
        logThrowableTo: org.apache.logging.log4j.util.TriConsumer;
        /**  */
        ERROR: cn.nukkit.utils.LogLevel;
        /**  */
        logTo: java.util.function.BiConsumer;
        /**  */
        NONE: cn.nukkit.utils.LogLevel;
        /**  */
        CRITICAL: cn.nukkit.utils.LogLevel;
        /**  */
        $VALUES: cn.nukkit.utils.LogLevel[];
        /**
         * 
         */
        public getLevel(): int;
        /**
         * 
         * @param {cn.nukkit.utils.MainLogger} logger 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} throwable 
         */
        public log(logger: cn.nukkit.utils.MainLogger,message: java.lang.String,throwable: java.lang.Throwable): void;
        /**
         * 
         * @param {cn.nukkit.utils.MainLogger} logger 
         * @param {java.lang.String} message 
         */
        public log(logger: cn.nukkit.utils.MainLogger,message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.MainLogger} logger 
         * @param {java.lang.String} message 
         */
        private static lambda$static$0(logger: cn.nukkit.utils.MainLogger,message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.utils.LogLevel;
        /**
         * 
         */
        public static values(): cn.nukkit.utils.LogLevel[];
        /**
         * 
         * @param {cn.nukkit.utils.MainLogger} mainLogger 
         * @param {java.lang.String} s 
         * @param {java.lang.Throwable} throwable 
         */
        private static lambda$static$1(mainLogger: cn.nukkit.utils.MainLogger,s: java.lang.String,throwable: java.lang.Throwable): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.beach{
     class ColdBeachBiome extends cn.nukkit.level.biome.type.SandyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isFreezing(): boolean;
        /**
         * 
         */
        public getCoverBlock(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockConcretePowder extends cn.nukkit.block.BlockFallableMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} b 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,b: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemShovelStone extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerToggleSneakEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        isSneaking: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isSneaking(): boolean;
    }
}
declare namespace cn.nukkit.scheduler{
     class AsyncPool extends java.util.concurrent.ThreadPoolExecutor{
        /**  */
        server: cn.nukkit.Server;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         * @param {java.lang.Runnable} runnable 
         */
        private lambda$new$0(runnable: java.lang.Runnable): java.lang.Thread;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {java.lang.Runnable} runnable 
         * @param {java.lang.Throwable} throwable 
         */
        protected afterExecute(runnable: java.lang.Runnable,throwable: java.lang.Throwable): void;
    }
}
declare namespace cn.nukkit.utils{
     class TextFormat extends java.lang.Enum{
        /**  */
        GOLD: cn.nukkit.utils.TextFormat;
        /**  */
        GRAY: cn.nukkit.utils.TextFormat;
        /**  */
        code: char;
        /**  */
        BLUE: cn.nukkit.utils.TextFormat;
        /**  */
        CLEAN_PATTERN: java.util.regex.Pattern;
        /**  */
        OBFUSCATED: cn.nukkit.utils.TextFormat;
        /**  */
        DARK_AQUA: cn.nukkit.utils.TextFormat;
        /**  */
        BY_ID: java.util.Map;
        /**  */
        RESET: cn.nukkit.utils.TextFormat;
        /**  */
        UNDERLINE: cn.nukkit.utils.TextFormat;
        /**  */
        isFormat: boolean;
        /**  */
        MINECOIN_GOLD: cn.nukkit.utils.TextFormat;
        /**  */
        DARK_RED: cn.nukkit.utils.TextFormat;
        /**  */
        LIGHT_PURPLE: cn.nukkit.utils.TextFormat;
        /**  */
        BLACK: cn.nukkit.utils.TextFormat;
        /**  */
        BOLD: cn.nukkit.utils.TextFormat;
        /**  */
        intCode: int;
        /**  */
        $VALUES: cn.nukkit.utils.TextFormat[];
        /**  */
        ITALIC: cn.nukkit.utils.TextFormat;
        /**  */
        AQUA: cn.nukkit.utils.TextFormat;
        /**  */
        WHITE: cn.nukkit.utils.TextFormat;
        /**  */
        BY_CHAR: java.util.Map;
        /**  */
        DARK_BLUE: cn.nukkit.utils.TextFormat;
        /**  */
        GREEN: cn.nukkit.utils.TextFormat;
        /**  */
        ESCAPE: char;
        /**  */
        RED: cn.nukkit.utils.TextFormat;
        /**  */
        DARK_PURPLE: cn.nukkit.utils.TextFormat;
        /**  */
        STRIKETHROUGH: cn.nukkit.utils.TextFormat;
        /**  */
        toString: java.lang.String;
        /**  */
        DARK_GREEN: cn.nukkit.utils.TextFormat;
        /**  */
        YELLOW: cn.nukkit.utils.TextFormat;
        /**  */
        DARK_GRAY: cn.nukkit.utils.TextFormat;
        /**
         * 
         */
        public getChar(): char;
        /**
         * 
         * @param {java.lang.String} input 
         */
        public static getLastColors(input: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} textToTranslate 
         */
        public static colorize(textToTranslate: java.lang.String): java.lang.String;
        /**
         * 
         * @param {char} altFormatChar 
         * @param {java.lang.String} textToTranslate 
         */
        public static colorize(altFormatChar: char,textToTranslate: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.utils.TextFormat;
        /**
         * 
         */
        public isColor(): boolean;
        /**
         * 
         */
        public static values(): cn.nukkit.utils.TextFormat[];
        /**
         * 
         * @param {char} code 
         */
        public static getByChar(code: char): cn.nukkit.utils.TextFormat;
        /**
         * 
         * @param {java.lang.String} code 
         */
        public static getByChar(code: java.lang.String): cn.nukkit.utils.TextFormat;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} input 
         */
        public static clean(input: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} input 
         * @param {boolean} recursive 
         */
        public static clean(input: java.lang.String,recursive: boolean): java.lang.String;
        /**
         * 
         */
        public isFormat(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockFence extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        FENCE_OAK: int;
        /**  */
        FENCE_JUNGLE: int;
        /**  */
        FENCE_ACACIA: int;
        /**  */
        FENCE_SPRUCE: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        FENCE_BIRCH: int;
        /**  */
        FENCE_DARK_OAK: int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} woodType 
         */
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getWoodType(): java.util.Optional;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public canConnect(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace java.lang{
     class Math extends java.lang.Object{
        /**  */
        twoToTheDoubleScaleUp: double;
        /**  */
        E: double;
        /**  */
        twoToTheDoubleScaleDown: double;
        /**  */
        negativeZeroDoubleBits: long;
        /**  */
        PI: double;
        /**  */
        $assertionsDisabled: boolean;
        /**  */
        negativeZeroFloatBits: long;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static copySign(arg0: double,arg1: double): double;
        /**
         * 
         * @param {float} arg0 
         * @param {float} arg1 
         */
        public static copySign(arg0: float,arg1: float): float;
        /**
         * 
         * @param {double} arg0 
         */
        public static cos(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static expm1(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static log1p(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static rint(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static atan(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static nextUp(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static nextUp(arg0: float): float;
        /**
         * 
         * @param {double} arg0 
         */
        public static sqrt(arg0: double): double;
        /**
         * 
         * @param {int} arg0 
         */
        public static decrementExact(arg0: int): int;
        /**
         * 
         * @param {long} arg0 
         */
        public static decrementExact(arg0: long): long;
        /**
         * 
         * @param {double} arg0 
         */
        public static exp(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static atan2(arg0: double,arg1: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static tan(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static signum(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static signum(arg0: float): float;
        /**
         * 
         * @param {double} arg0 
         */
        public static sinh(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static toDegrees(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static acos(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static ceil(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static getExponent(arg0: float): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static getExponent(arg0: double): int;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static addExact(arg0: long,arg1: long): long;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static addExact(arg0: int,arg1: int): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static ulp(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static ulp(arg0: float): float;
        /**
         * 
         * @param {double} arg0 
         * @param {int} arg1 
         */
        public static scalb(arg0: double,arg1: int): double;
        /**
         * 
         * @param {float} arg0 
         * @param {int} arg1 
         */
        public static scalb(arg0: float,arg1: int): float;
        /**
         * 
         * @param {double} arg0 
         */
        public static log(arg0: double): double;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static floorMod(arg0: int,arg1: int): int;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static floorMod(arg0: long,arg1: long): long;
        /**
         * 
         * @param {double} arg0 
         */
        public static log10(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         * @param {double} arg1 
         */
        public static nextAfter(arg0: float,arg1: double): float;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static nextAfter(arg0: double,arg1: double): double;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static multiplyExact(arg0: long,arg1: long): long;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static multiplyExact(arg0: int,arg1: int): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static cbrt(arg0: double): double;
        /**
         * 
         */
        public static random(): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static tanh(arg0: double): double;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static min(arg0: long,arg1: long): long;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static min(arg0: double,arg1: double): double;
        /**
         * 
         * @param {float} arg0 
         * @param {float} arg1 
         */
        public static min(arg0: float,arg1: float): float;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static min(arg0: int,arg1: int): int;
        /**
         * 
         * @param {int} arg0 
         */
        public static negateExact(arg0: int): int;
        /**
         * 
         * @param {long} arg0 
         */
        public static negateExact(arg0: long): long;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static hypot(arg0: double,arg1: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static sin(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static pow(arg0: double,arg1: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static floor(arg0: double): double;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static subtractExact(arg0: int,arg1: int): int;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static subtractExact(arg0: long,arg1: long): long;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static max(arg0: double,arg1: double): double;
        /**
         * 
         * @param {float} arg0 
         * @param {float} arg1 
         */
        public static max(arg0: float,arg1: float): float;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static max(arg0: long,arg1: long): long;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static max(arg0: int,arg1: int): int;
        /**
         * 
         * @param {long} arg0 
         */
        public static toIntExact(arg0: long): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static nextDown(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static nextDown(arg0: float): float;
        /**
         * 
         * @param {double} arg0 
         */
        public static toRadians(arg0: double): double;
        /**
         * 
         * @param {double} arg0 
         * @param {double} arg1 
         */
        public static IEEEremainder(arg0: double,arg1: double): double;
        /**
         * 
         * @param {double} arg0 
         */
        public static cosh(arg0: double): double;
        /**
         * 
         * @param {int} arg0 
         */
        static powerOfTwoF(arg0: int): float;
        /**
         * 
         * @param {int} arg0 
         */
        public static abs(arg0: int): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static abs(arg0: double): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static abs(arg0: float): float;
        /**
         * 
         * @param {long} arg0 
         */
        public static abs(arg0: long): long;
        /**
         * 
         * @param {int} arg0 
         */
        static powerOfTwoD(arg0: int): double;
        /**
         * 
         * @param {float} arg0 
         */
        public static round(arg0: float): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static round(arg0: double): long;
        /**
         * 
         * @param {long} arg0 
         */
        public static incrementExact(arg0: long): long;
        /**
         * 
         * @param {int} arg0 
         */
        public static incrementExact(arg0: int): int;
        /**
         * 
         * @param {long} arg0 
         * @param {long} arg1 
         */
        public static floorDiv(arg0: long,arg1: long): long;
        /**
         * 
         * @param {int} arg0 
         * @param {int} arg1 
         */
        public static floorDiv(arg0: int,arg1: int): int;
        /**
         * 
         * @param {double} arg0 
         */
        public static asin(arg0: double): double;
    }
}
declare namespace cn.nukkit.event.server{
     class QueryRegenerateEvent extends cn.nukkit.event.server.ServerEvent{
        /**  */
        gameType: java.lang.String;
        /**  */
        listPlugins: boolean;
        /**  */
        maxPlayers: int;
        /**  */
        extraData: java.util.Map;
        /**  */
        plugins: cn.nukkit.plugin.Plugin[];
        /**  */
        players: cn.nukkit.Player[];
        /**  */
        ip: java.lang.String;
        /**  */
        serverName: java.lang.String;
        /**  */
        GAME_ID: java.lang.String;
        /**  */
        whitelist: java.lang.String;
        /**  */
        version: java.lang.String;
        /**  */
        timeout: int;
        /**  */
        numPlayers: int;
        /**  */
        server_engine: java.lang.String;
        /**  */
        port: int;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        map: java.lang.String;
        /**
         * 
         */
        public getWorld(): java.lang.String;
        /**
         * 
         */
        public getMaxPlayerCount(): int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPlayerCount(): int;
        /**
         * 
         */
        public getExtraData(): java.util.Map;
        /**
         * 
         * @param {int} count 
         */
        public setPlayerCount(count: int): void;
        /**
         * 
         */
        public getServerName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public setPlayerList(players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {byte[]} buffer 
         */
        public getShortQuery(buffer: byte[]): byte[];
        /**
         * 
         * @param {int} timeout 
         */
        public setTimeout(timeout: int): void;
        /**
         * 
         * @param {int} count 
         */
        public setMaxPlayerCount(count: int): void;
        /**
         * 
         */
        public getTimeout(): int;
        /**
         * 
         * @param {java.util.Map} extraData 
         */
        public setExtraData(extraData: java.util.Map): void;
        /**
         * 
         */
        public getPlugins(): cn.nukkit.plugin.Plugin[];
        /**
         * 
         */
        public canListPlugins(): boolean;
        /**
         * 
         * @param {boolean} listPlugins 
         */
        public setListPlugins(listPlugins: boolean): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin[]} plugins 
         */
        public setPlugins(plugins: cn.nukkit.plugin.Plugin[]): void;
        /**
         * 
         * @param {java.lang.String} serverName 
         */
        public setServerName(serverName: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} world 
         */
        public setWorld(world: java.lang.String): void;
        /**
         * 
         */
        public getPlayerList(): cn.nukkit.Player[];
        /**
         * 
         * @param {byte[]} buffer 
         */
        public getLongQuery(buffer: byte[]): byte[];
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentBindingCurse extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemHopper extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.utils{
     class ThreadCache extends java.lang.Object{
        /**  */
        dataArray: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        intCache256: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        idArray: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        fbaos: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        charCache4096: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        charCache4096v2: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        boolCache4096: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        byteCache6144: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        binaryStream: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        byteCache256: cn.nukkit.utils.IterableThreadLocal;
        /**
         * 
         */
        public static clean(): void;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerServerSettingsRequestEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        settings: java.util.Map;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {int} id 
         * @param {cn.nukkit.form.window.FormWindow} window 
         */
        public setSettings(id: int,window: cn.nukkit.form.window.FormWindow): void;
        /**
         * 
         * @param {java.util.Map} settings 
         */
        public setSettings(settings: java.util.Map): void;
        /**
         * 
         */
        public getSettings(): java.util.Map;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerInputPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        jumping: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        motionY: float;
        /**  */
        motionX: float;
        /**  */
        sneaking: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockBedrockInvisible extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ClientCacheStatusPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        supported: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityCreeper extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        DATA_SWELL_DIRECTION: int;
        /**  */
        NETWORK_ID: int;
        /**  */
        DATA_POWERED: int;
        /**  */
        DATA_SWELL: int;
        /**  */
        DATA_SWELL_OLD: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onStruckByLightning(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.weather.EntityLightningStrike} bolt 
         */
        public setPowered(bolt: cn.nukkit.entity.weather.EntityLightningStrike): void;
        /**
         * 
         * @param {boolean} powered 
         */
        public setPowered(powered: boolean): void;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntitySkull extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        mouthMoving: boolean;
        /**  */
        mouthTickCount: int;
        /**
         * 
         */
        public getMouthTickCount(): int;
        /**
         * 
         * @param {boolean} mouthMoving 
         */
        public setMouthMoving(mouthMoving: boolean): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {int} mouthTickCount 
         */
        public setMouthTickCount(mouthTickCount: int): void;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public isMouthMoving(): boolean;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public isObservable(): boolean;
        /**
         * 
         */
        public onUpdate(): boolean;
        /**
         * 
         */
        public setDirty(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockDandelion extends cn.nukkit.block.BlockFlower{
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.SmallFlowerType} flowerType 
         */
        public setFlowerType(flowerType: cn.nukkit.blockproperty.value.SmallFlowerType): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getFlowerType(): cn.nukkit.blockproperty.value.SmallFlowerType;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        protected getUncommonFlower(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemEdible extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onUse(player: cn.nukkit.Player,ticksUsed: int): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentSilkTouch extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.plugin{
     class JavaPluginLoader extends java.lang.Object{
        /**  */
        server: cn.nukkit.Server;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        classes: java.util.Map;
        /**  */
        classLoaders: java.util.Map;
        /**
         * 
         */
        public getPluginFilters(): java.util.regex.Pattern[];
        /**
         * 
         * @param {cn.nukkit.plugin.PluginBase} plugin 
         * @param {cn.nukkit.plugin.PluginDescription} description 
         * @param {java.io.File} dataFolder 
         * @param {java.io.File} file 
         */
        private initPlugin(plugin: cn.nukkit.plugin.PluginBase,description: cn.nukkit.plugin.PluginDescription,dataFolder: java.io.File,file: java.io.File): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public enablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public disablePlugin(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
         getClassByName(name: java.lang.String): java.lang.Class;
        /**
         * 
         * @param {java.lang.String} name 
         */
        private removeClass(name: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public getPluginDescription(filename: java.lang.String): cn.nukkit.plugin.PluginDescription;
        /**
         * 
         * @param {java.io.File} file 
         */
        public getPluginDescription(file: java.io.File): cn.nukkit.plugin.PluginDescription;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.Class} clazz 
         */
         setClass(name: java.lang.String,clazz: java.lang.Class): void;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public loadPlugin(filename: java.lang.String): cn.nukkit.plugin.Plugin;
        /**
         * 
         * @param {java.io.File} file 
         */
        public loadPlugin(file: java.io.File): cn.nukkit.plugin.Plugin;
    }
}
declare namespace cn.nukkit.network.protocol{
     class NetworkChunkPublisherUpdatePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        position: cn.nukkit.math.BlockVector3;
        /**  */
        radius: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemHorseArmorLeather extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.event{
     class HandlerList extends java.lang.Object{
        /**  */
        handlers: cn.nukkit.plugin.RegisteredListener[];
        /**  */
        allLists: java.util.ArrayList;
        /**  */
        handlerslots: java.util.EnumMap;
        /**
         * 
         */
        public static bakeAll(): void;
        /**
         * 
         * @param {java.util.Collection} listeners 
         */
        public registerAll(listeners: java.util.Collection): void;
        /**
         * 
         */
        public  bake(): void;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public  unregister(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {cn.nukkit.event.Listener} listener 
         */
        public  unregister(listener: cn.nukkit.event.Listener): void;
        /**
         * 
         * @param {cn.nukkit.plugin.RegisteredListener} listener 
         */
        public  unregister(listener: cn.nukkit.plugin.RegisteredListener): void;
        /**
         * 
         */
        public getRegisteredListeners(): cn.nukkit.plugin.RegisteredListener[];
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public static getRegisteredListeners(plugin: cn.nukkit.plugin.Plugin): java.util.ArrayList;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public static unregisterAll(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         */
        public static unregisterAll(): void;
        /**
         * 
         * @param {cn.nukkit.event.Listener} listener 
         */
        public static unregisterAll(listener: cn.nukkit.event.Listener): void;
        /**
         * 
         */
        public static getHandlerLists(): java.util.ArrayList;
        /**
         * 
         * @param {cn.nukkit.plugin.RegisteredListener} listener 
         */
        public  register(listener: cn.nukkit.plugin.RegisteredListener): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockWheat extends cn.nukkit.block.BlockCrops{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace java.net{
     class InetSocketAddress extends java.net.SocketAddress{
        /**  */
        serialPersistentFields: java.io.ObjectStreamField[];
        /**  */
        serialVersionUID: long;
        /**  */
        holder: java.net.InetSocketAddress.InetSocketAddressHolder;
        /**  */
        UNSAFE: sun.misc.Unsafe;
        /**  */
        FIELDS_OFFSET: long;
        /**
         * 
         */
        private readObjectNoData(): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {int} arg1 
         */
        public static createUnresolved(arg0: java.lang.String,arg1: int): java.net.InetSocketAddress;
        /**
         * 
         */
        public  getHostName(): java.lang.String;
        /**
         * 
         * @param {java.io.ObjectOutputStream} arg0 
         */
        private writeObject(arg0: java.io.ObjectOutputStream): void;
        /**
         * 
         * @param {int} arg0 
         */
        private static checkPort(arg0: int): int;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private static checkHost(arg0: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.io.ObjectInputStream} arg0 
         */
        private readObject(arg0: java.io.ObjectInputStream): void;
        /**
         * 
         */
        public  isUnresolved(): boolean;
        /**
         * 
         */
        public  getPort(): int;
        /**
         * 
         */
        public  hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public  getHostString(): java.lang.String;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public  getAddress(): java.net.InetAddress;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityEnderDragon extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public applyNameTag(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         */
        protected applyNameTag(player: cn.nukkit.Player,item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.command.simple{
     class SimpleCommand extends cn.nukkit.command.Command{
        /**  */
        method: java.lang.reflect.Method;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        forbidConsole: boolean;
        /**  */
        maxArgs: int;
        /**  */
        minArgs: int;
        /**  */
        object: java.lang.Object;
        /**
         * 
         * @param {int} minArgs 
         */
        public setMinArgs(minArgs: int): void;
        /**
         * 
         * @param {int} maxArgs 
         */
        public setMaxArgs(maxArgs: int): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
        /**
         * 
         * @param {boolean} forbidConsole 
         */
        public setForbidConsole(forbidConsole: boolean): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         */
        public sendInGameMessage(sender: cn.nukkit.command.CommandSender): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         */
        public sendUsageMessage(sender: cn.nukkit.command.CommandSender): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntitySheep extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        sheared: boolean;
        /**  */
        color: int;
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        private randomColor(): int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {int} color 
         */
        public setColor(color: int): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public shear(): boolean;
        /**
         * 
         */
        public getColor(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.entity.data{
    abstract class EntityData extends java.lang.Object{
        /**  */
        id: int;
        /**  */
        KNOWN_ENTITY_DATA: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**  */
        KNOWN_ENTITY_FLAGS: it.unimi.dsi.fastutil.ints.Int2ObjectMap;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$9(it: java.lang.reflect.Field): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public abstract setData(data: java.lang.Object): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {int} offset 
         * @param {long} flags 
         */
        private readFlags(offset: int,flags: long): java.util.SortedSet;
        /**
         * 
         */
        public abstract getType(): int;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$0(it: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$3(it: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {int} id 
         */
        public setId(id: int): cn.nukkit.entity.data.EntityData;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$4(it: java.lang.reflect.Field): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$1(it: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$2(it: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$7(it: java.lang.reflect.Field): boolean;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$8(it: java.lang.reflect.Field): boolean;
        /**
         * 
         */
        public abstract getData(): java.lang.Object;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$5(it: java.lang.reflect.Field): void;
        /**
         * 
         * @param {java.lang.reflect.Field} it 
         */
        private static lambda$static$6(it: java.lang.reflect.Field): boolean;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityParrot extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockCrops extends cn.nukkit.block.BlockFlowable{
        /**  */
        MINIMUM_LIGHT_LEVEL: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        GROWTH: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public getMinimumLightLevel(): int;
        /**
         * 
         * @param {int} growth 
         */
        public setGrowth(growth: int): void;
        /**
         * 
         */
        public getMaxGrowth(): int;
        /**
         * 
         */
        public isFullyGrown(): boolean;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getGrowth(): int;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.command.defaults{
     class SetWorldSpawnCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityStrider extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemTotem extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.level.biome.impl.ocean{
     class FrozenOceanBiome extends cn.nukkit.level.biome.impl.ocean.OceanBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isFreezing(): boolean;
    }
}
declare namespace cn.nukkit.utils{
     class Config extends java.lang.Object{
        /**  */
        ENUM: int;
        /**  */
        PROPERTIES: int;
        /**  */
        correct: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        format: java.util.Map;
        /**  */
        ENUMERATION: int;
        /**  */
        JSON: int;
        /**  */
        type: int;
        /**  */
        YAML: int;
        /**  */
        file: java.io.File;
        /**  */
        CNF: int;
        /**  */
        config: cn.nukkit.utils.ConfigSection;
        /**  */
        DETECT: int;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getLongList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getBooleanList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {cn.nukkit.utils.ConfigSection} defaultMap 
         * @param {cn.nukkit.utils.ConfigSection} data 
         */
        private fillDefaults(defaultMap: cn.nukkit.utils.ConfigSection,data: cn.nukkit.utils.ConfigSection): cn.nukkit.utils.ConfigSection;
        /**
         * 
         */
        public save(): boolean;
        /**
         * 
         * @param {java.lang.Boolean} async 
         */
        public save(async: java.lang.Boolean): boolean;
        /**
         * 
         * @param {java.io.File} file 
         * @param {boolean} async 
         */
        public save(file: java.io.File,async: boolean): boolean;
        /**
         * 
         * @param {java.io.File} file 
         */
        public save(file: java.io.File): boolean;
        /**
         * 
         * @param {java.lang.String} content 
         */
        private parseList(content: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {double} defaultValue 
         */
        public getDouble(key: java.lang.String,defaultValue: double): double;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getDouble(key: java.lang.String): double;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getMapList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getShortList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isList(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public remove(key: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} content 
         */
        private parseProperties(content: java.lang.String): void;
        /**
         * 
         */
        public getRootSection(): cn.nukkit.utils.ConfigSection;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isBoolean(key: java.lang.String): boolean;
        /**
         * 
         */
        public reload(): void;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getSection(key: java.lang.String): cn.nukkit.utils.ConfigSection;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         */
        public load(inputStream: java.io.InputStream): boolean;
        /**
         * 
         * @param {java.lang.String} file 
         */
        public load(file: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} file 
         * @param {int} type 
         */
        public load(file: java.lang.String,type: int): boolean;
        /**
         * 
         * @param {java.lang.String} file 
         * @param {int} type 
         * @param {cn.nukkit.utils.ConfigSection} defaultMap 
         */
        public load(file: java.lang.String,type: int,defaultMap: cn.nukkit.utils.ConfigSection): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.util.List} defaultList 
         */
        public getList(key: java.lang.String,defaultList: java.util.List): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public get(key: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.Object} defaultValue 
         */
        public get(key: java.lang.String,defaultValue: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isInt(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isString(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getBoolean(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {boolean} defaultValue 
         */
        public getBoolean(key: java.lang.String,defaultValue: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getCharacterList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.util.LinkedHashMap} map 
         */
        public setAll(map: java.util.LinkedHashMap): void;
        /**
         * 
         * @param {cn.nukkit.utils.ConfigSection} section 
         */
        public setAll(section: cn.nukkit.utils.ConfigSection): void;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public removeNested(key: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} content 
         */
        private parseContent(content: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.Object} value 
         */
        public set(key: java.lang.String,value: java.lang.Object): void;
        /**
         * 
         */
        public getAll(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isLong(key: java.lang.String): boolean;
        /**
         * 
         */
        private writeProperties(): java.lang.String;
        /**
         * 
         * @param {boolean} child 
         */
        public getKeys(child: boolean): java.util.Set;
        /**
         * 
         */
        public getKeys(): java.util.Set;
        /**
         * 
         */
        public check(): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.String} defaultValue 
         */
        public getString(key: java.lang.String,defaultValue: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getString(key: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.util.LinkedHashMap} map 
         */
        public setDefault(map: java.util.LinkedHashMap): int;
        /**
         * 
         * @param {cn.nukkit.utils.ConfigSection} map 
         */
        public setDefault(map: cn.nukkit.utils.ConfigSection): int;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getDoubleList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getLong(key: java.lang.String): long;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {long} defaultValue 
         */
        public getLong(key: java.lang.String,defaultValue: long): long;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {int} defaultValue 
         */
        public getInt(key: java.lang.String,defaultValue: int): int;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getInt(key: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getFloatList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getIntegerList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getByteList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public exists(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {boolean} ignoreCase 
         */
        public exists(key: java.lang.String,ignoreCase: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isSection(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.Object} defaultValue 
         */
        public getNested(key: java.lang.String,defaultValue: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getNested(key: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getStringList(key: java.lang.String): java.util.List;
        /**
         * 
         */
        public getSections(): cn.nukkit.utils.ConfigSection;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getSections(key: java.lang.String): cn.nukkit.utils.ConfigSection;
        /**
         * 
         */
        public isCorrect(): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.Class} type 
         */
        public getNestedAs(key: java.lang.String,type: java.lang.Class): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isDouble(key: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.level{
     class MovingObjectPosition extends java.lang.Object{
        /**  */
        sideHit: int;
        /**  */
        blockX: int;
        /**  */
        entityHit: cn.nukkit.entity.Entity;
        /**  */
        blockY: int;
        /**  */
        hitVector: cn.nukkit.math.Vector3;
        /**  */
        blockZ: int;
        /**  */
        typeOfHit: int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.math.Vector3} hitVector 
         */
        public static fromBlock(x: int,y: int,z: int,face: cn.nukkit.math.BlockFace,hitVector: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} side 
         * @param {cn.nukkit.math.Vector3} hitVector 
         */
        public static fromBlock(x: int,y: int,z: int,side: int,hitVector: cn.nukkit.math.Vector3): cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         */
        public getFaceHit(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public static fromEntity(entity: cn.nukkit.entity.Entity): cn.nukkit.level.MovingObjectPosition;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setFaceHit(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public toString(): java.lang.String;
    }
}
declare namespace cn.nukkit{
     class AdventureSettings extends java.lang.Object{
        /**  */
        PERMISSION_NORMAL: int;
        /**  */
        PERMISSION_HOST: int;
        /**  */
        values: java.util.Map;
        /**  */
        PERMISSION_OPERATOR: int;
        /**  */
        PERMISSION_ADMIN: int;
        /**  */
        PERMISSION_AUTOMATION: int;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         * @param {cn.nukkit.AdventureSettings.Type} type 
         * @param {boolean} value 
         */
        public set(type: cn.nukkit.AdventureSettings.Type,value: boolean): cn.nukkit.AdventureSettings;
        /**
         * 
         * @param {cn.nukkit.AdventureSettings.Type} type 
         */
        public get(type: cn.nukkit.AdventureSettings.Type): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} newPlayer 
         */
        public clone(newPlayer: cn.nukkit.Player): cn.nukkit.AdventureSettings;
        /**
         * 
         */
        public update(): void;
    }
}
declare namespace cn.nukkit.level.particle{
     class EnchantmentTableParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockFlowable extends cn.nukkit.block.BlockTransparentMeta{
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockNetherWartBlock extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockTNT extends cn.nukkit.block.BlockSolid{
        /**  */
        EXPLODE_ON_BREAK: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        ALLOW_UNDERWATER: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {int} fuse 
         * @param {cn.nukkit.entity.Entity} source 
         */
        public prime(fuse: int,source: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public prime(): void;
        /**
         * 
         * @param {int} fuse 
         */
        public prime(fuse: int): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} projectile 
         * @param {cn.nukkit.level.Position} position 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public onProjectileHit(projectile: cn.nukkit.entity.Entity,position: cn.nukkit.level.Position,motion: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace org.java_websocket.client{
    abstract class WebSocketClient extends org.java_websocket.AbstractWebSocket{
        /**  */
        headers: java.util.Map;
        /**  */
        socketFactory: javax.net.SocketFactory;
        /**  */
        ostream: java.io.OutputStream;
        /**  */
        closeLatch: java.util.concurrent.CountDownLatch;
        /**  */
        dnsResolver: org.java_websocket.client.DnsResolver;
        /**  */
        uri: java.net.URI;
        /**  */
        proxy: java.net.Proxy;
        /**  */
        writeThread: java.lang.Thread;
        /**  */
        engine: org.java_websocket.WebSocketImpl;
        /**  */
        draft: org.java_websocket.drafts.Draft;
        /**  */
        connectTimeout: int;
        /**  */
        socket: java.net.Socket;
        /**  */
        connectLatch: java.util.concurrent.CountDownLatch;
        /**  */
        connectReadThread: java.lang.Thread;
        /**
         * 
         */
        public clearHeaders(): void;
        /**
         * 
         */
        public run(): void;
        /**
         * 
         * @param {java.io.IOException} arg0 
         */
        private handleIOException(arg0: java.io.IOException): void;
        /**
         * 
         */
        public reconnectBlocking(): boolean;
        /**
         * 
         */
        public hasSSLSupport(): boolean;
        /**
         * 
         */
        private prepareSocket(): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         * @param {boolean} arg2 
         */
        public onClosing(arg0: int,arg1: java.lang.String,arg2: boolean): void;
        /**
         * 
         */
        public getAttachment(): java.lang.Object;
        /**
         * 
         * @param {java.net.Socket} arg0 
         */
        public setSocket(arg0: java.net.Socket): void;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         */
        public onCloseInitiated(arg0: int,arg1: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.client.WebSocketClient} arg0 
         */
        static access$400(arg0: org.java_websocket.client.WebSocketClient): java.net.Socket;
        /**
         * 
         * @param {org.java_websocket.client.WebSocketClient} arg0 
         */
        static access$200(arg0: org.java_websocket.client.WebSocketClient): org.java_websocket.WebSocketImpl;
        /**
         * 
         * @param {org.java_websocket.client.WebSocketClient} arg0 
         * @param {java.io.IOException} arg1 
         */
        static access$000(arg0: org.java_websocket.client.WebSocketClient,arg1: java.io.IOException): void;
        /**
         * 
         * @param {java.net.Proxy} arg0 
         */
        public setProxy(arg0: java.net.Proxy): void;
        /**
         * 
         */
        public isFlushAndClose(): boolean;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         */
        public closeConnection(arg0: int,arg1: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public removeHeader(arg0: java.lang.String): java.lang.String;
        /**
         * 
         */
        public getSSLSession(): javax.net.ssl.SSLSession;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         * @param {boolean} arg2 
         */
        public abstract onClose(arg0: int,arg1: java.lang.String,arg2: boolean): void;
        /**
         * 
         */
        public isOpen(): boolean;
        /**
         * 
         */
        public connectBlocking(): boolean;
        /**
         * 
         * @param {long} arg0 
         * @param {java.util.concurrent.TimeUnit} arg1 
         */
        public connectBlocking(arg0: long,arg1: java.util.concurrent.TimeUnit): boolean;
        /**
         * 
         */
        private reset(): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public abstract onMessage(arg0: java.lang.String): void;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        public onMessage(arg0: java.nio.ByteBuffer): void;
        /**
         * 
         */
        public isClosing(): boolean;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        public send(arg0: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public send(arg0: java.lang.String): void;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public send(arg0: byte[]): void;
        /**
         * 
         * @param {javax.net.SocketFactory} arg0 
         */
        public setSocketFactory(arg0: javax.net.SocketFactory): void;
        /**
         * 
         */
        public getURI(): java.net.URI;
        /**
         * 
         */
        protected getConnections(): java.util.Collection;
        /**
         * 
         */
        public getRemoteSocketAddress(): java.net.InetSocketAddress;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public getRemoteSocketAddress(arg0: org.java_websocket.WebSocket): java.net.InetSocketAddress;
        /**
         * 
         */
        public getDraft(): org.java_websocket.drafts.Draft;
        /**
         * 
         */
        private sendHandshake(): void;
        /**
         * 
         */
        public sendPing(): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         */
        public  onWebsocketMessage(arg0: org.java_websocket.WebSocket,arg1: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.String} arg1 
         */
        public  onWebsocketMessage(arg0: org.java_websocket.WebSocket,arg1: java.lang.String): void;
        /**
         * 
         */
        public getResourceDescriptor(): java.lang.String;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.Exception} arg1 
         */
        public  onWebsocketError(arg0: org.java_websocket.WebSocket,arg1: java.lang.Exception): void;
        /**
         * 
         */
        public closeBlocking(): void;
        /**
         * 
         */
        public getConnection(): org.java_websocket.WebSocket;
        /**
         * 
         */
        public reconnect(): void;
        /**
         * 
         * @param {org.java_websocket.enums.Opcode} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         * @param {boolean} arg2 
         */
        public sendFragmentedFrame(arg0: org.java_websocket.enums.Opcode,arg1: java.nio.ByteBuffer,arg2: boolean): void;
        /**
         * 
         * @param {org.java_websocket.handshake.ServerHandshake} arg0 
         */
        public abstract onOpen(arg0: org.java_websocket.handshake.ServerHandshake): void;
        /**
         * 
         */
        public hasBufferedData(): boolean;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public onWebsocketClosing(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public  onWebsocketClose(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         */
        public getReadyState(): org.java_websocket.enums.ReadyState;
        /**
         * 
         * @param {int} arg0 
         */
        public close(arg0: int): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {int} arg0 
         * @param {java.lang.String} arg1 
         */
        public close(arg0: int,arg1: java.lang.String): void;
        /**
         * 
         */
        public connect(): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.String} arg1 
         */
        public addHeader(arg0: java.lang.String,arg1: java.lang.String): void;
        /**
         * 
         * @param {java.lang.Exception} arg0 
         */
        public abstract onError(arg0: java.lang.Exception): void;
        /**
         * 
         * @param {org.java_websocket.client.WebSocketClient} arg0 
         */
        static access$300(arg0: org.java_websocket.client.WebSocketClient): java.io.OutputStream;
        /**
         * 
         * @param {org.java_websocket.client.WebSocketClient} arg0 
         * @param {java.lang.Thread} arg1 
         */
        static access$102(arg0: org.java_websocket.client.WebSocketClient,arg1: java.lang.Thread): java.lang.Thread;
        /**
         * 
         */
        public getLocalSocketAddress(): java.net.InetSocketAddress;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public getLocalSocketAddress(arg0: org.java_websocket.WebSocket): java.net.InetSocketAddress;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.Handshakedata} arg1 
         */
        public  onWebsocketOpen(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.Handshakedata): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public  onWriteDemand(arg0: org.java_websocket.WebSocket): void;
        /**
         * 
         */
        public getProtocol(): org.java_websocket.protocols.IProtocol;
        /**
         * 
         * @param {org.java_websocket.client.DnsResolver} arg0 
         */
        public setDnsResolver(arg0: org.java_websocket.client.DnsResolver): void;
        /**
         * 
         * @param {javax.net.ssl.SSLParameters} arg0 
         */
        protected onSetSSLParameters(arg0: javax.net.ssl.SSLParameters): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         */
        public onWebsocketCloseInitiated(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String): void;
        /**
         * 
         */
        private getPort(): int;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public sendFrame(arg0: java.util.Collection): void;
        /**
         * 
         * @param {org.java_websocket.framing.Framedata} arg0 
         */
        public sendFrame(arg0: org.java_websocket.framing.Framedata): void;
        /**
         * 
         */
        public isClosed(): boolean;
        /**
         * 
         */
        public getSocket(): java.net.Socket;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public setAttachment(arg0: java.lang.Object): void;
        /**
         * 
         */
        private upgradeSocketToSSL(): void;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityDamageByChildEntityEvent extends cn.nukkit.event.entity.EntityDamageByEntityEvent{
        /**  */
        childEntity: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getChild(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityBanner extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        color: int;
        /**
         * 
         */
        public getBaseColor(): int;
        /**
         * 
         * @param {cn.nukkit.utils.DyeColor} color 
         */
        public setBaseColor(color: cn.nukkit.utils.DyeColor): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         * @param {int} type 
         */
        public setType(type: int): void;
        /**
         * 
         */
        public getPatternsSize(): int;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         * @param {int} index 
         */
        public removePattern(index: int): void;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.utils.BannerPattern} pattern 
         */
        public addPattern(pattern: cn.nukkit.utils.BannerPattern): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         * @param {int} index 
         */
        public getPattern(index: int): cn.nukkit.utils.BannerPattern;
    }
}
declare namespace cn.nukkit.item{
     class ItemChorusFruit extends cn.nukkit.item.ItemEdible{
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {int} ticksUsed 
         */
        public onUse(player: cn.nukkit.Player,ticksUsed: int): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemSwordWood extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockMobSpawner extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
    }
}
declare namespace cn.nukkit.block{
     class BlockTrappedChest extends cn.nukkit.block.BlockChest{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getWeakPower(face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryClickEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        sourceItem: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        heldItem: cn.nukkit.item.Item;
        /**  */
        slot: int;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getSlot(): int;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getHeldItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getSourceItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.level.biome.impl.plains{
     class SunflowerPlainsBiome extends cn.nukkit.level.biome.impl.plains.PlainsBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level{
     class Position extends cn.nukkit.positiontracking.NamedPosition{
        /**  */
        level: cn.nukkit.level.Level;
        /**
         * 
         */
        public getLocation(): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Level} level 
         */
        public static fromObject(pos: cn.nukkit.math.Vector3,level: cn.nukkit.level.Level): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public static fromObject(pos: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public  getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {int} step 
         */
        public getSide(face: cn.nukkit.math.BlockFace,step: int): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public  getSide(face: cn.nukkit.math.BlockFace): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {java.lang.Class} type 
         */
        public  getTypedBlockEntity(type: java.lang.Class): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public getLevelName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         */
        public setLevel(level: cn.nukkit.level.Level): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} number 
         */
        public  divide(number: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} number 
         */
        public divide(number: double): cn.nukkit.level.Position;
        /**
         * 
         */
        public  floor(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public floor(): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} number 
         */
        public multiply(number: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} number 
         */
        public  multiply(number: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public add(x: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         */
        public add(x: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public add(x: double,y: double,z: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public add(x: double,y: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         */
        public  add(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public  add(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  add(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public  add(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setComponents(pos: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public  setComponents(pos: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  setComponents(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public setComponents(x: double,y: double,z: double): cn.nukkit.level.Position;
        /**
         * 
         */
        public getLevelBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getLevelBlockEntity(): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public isValid(): boolean;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public  subtract(x: double,y: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         */
        public  subtract(x: double): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public  subtract(x: double,y: double,z: double): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  subtract(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public  subtract(x: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public subtract(): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         */
        public subtract(x: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public subtract(x: double,y: double,z: double): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} x 
         */
        public subtract(x: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         */
        public subtract(x: double,y: double): cn.nukkit.level.Position;
        /**
         * 
         */
        public  getValidLevel(): cn.nukkit.level.Level;
        /**
         * 
         */
        public  ceil(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public ceil(): cn.nukkit.level.Position;
        /**
         * 
         */
        public setWeak(): boolean;
        /**
         * 
         */
        public getLevel(): cn.nukkit.level.Level;
        /**
         * 
         * @param {int} layer 
         */
        public getLevelBlockAtLayer(layer: int): cn.nukkit.block.Block;
        /**
         * 
         */
        public  abs(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public abs(): cn.nukkit.level.Position;
        /**
         * 
         * @param {int} layer 
         */
        public getLevelBlockState(layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getLevelBlockState(): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public round(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  round(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public getChunk(): cn.nukkit.level.format.FullChunk;
        /**
         * 
         */
        public  clone(): cn.nukkit.positiontracking.NamedPosition;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public clone(): cn.nukkit.level.Position;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public setStrong(): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.savanna{
     class SavannaBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isDry(): boolean;
    }
}
declare namespace cn.nukkit.utils{
     class VarInt extends java.lang.Object{
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         * @param {int} maxSize 
         */
        private static read(stream: cn.nukkit.utils.BinaryStream,maxSize: int): long;
        /**
         * 
         * @param {java.io.InputStream} stream 
         * @param {int} maxSize 
         */
        private static read(stream: java.io.InputStream,maxSize: int): long;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         * @param {long} value 
         */
        public static writeVarLong(stream: cn.nukkit.utils.BinaryStream,value: long): void;
        /**
         * 
         * @param {java.io.OutputStream} stream 
         * @param {long} value 
         */
        public static writeVarLong(stream: java.io.OutputStream,value: long): void;
        /**
         * 
         * @param {long} v 
         */
        public static decodeZigZag32(v: long): int;
        /**
         * 
         * @param {long} v 
         */
        public static decodeZigZag64(v: long): long;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         * @param {long} value 
         */
        public static writeUnsignedVarLong(stream: cn.nukkit.utils.BinaryStream,value: long): void;
        /**
         * 
         * @param {java.io.OutputStream} stream 
         * @param {long} value 
         */
        public static writeUnsignedVarLong(stream: java.io.OutputStream,value: long): void;
        /**
         * 
         * @param {long} v 
         */
        public static encodeZigZag64(v: long): long;
        /**
         * 
         * @param {int} v 
         */
        public static encodeZigZag32(v: int): long;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         * @param {long} value 
         */
        public static writeUnsignedVarInt(stream: cn.nukkit.utils.BinaryStream,value: long): void;
        /**
         * 
         * @param {java.io.OutputStream} stream 
         * @param {long} value 
         */
        public static writeUnsignedVarInt(stream: java.io.OutputStream,value: long): void;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public static readUnsignedVarLong(stream: cn.nukkit.utils.BinaryStream): long;
        /**
         * 
         * @param {java.io.InputStream} stream 
         */
        public static readUnsignedVarLong(stream: java.io.InputStream): long;
        /**
         * 
         * @param {java.io.InputStream} stream 
         */
        public static readVarLong(stream: java.io.InputStream): long;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public static readVarLong(stream: cn.nukkit.utils.BinaryStream): long;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public static readUnsignedVarInt(stream: cn.nukkit.utils.BinaryStream): long;
        /**
         * 
         * @param {java.io.InputStream} stream 
         */
        public static readUnsignedVarInt(stream: java.io.InputStream): long;
        /**
         * 
         * @param {java.io.OutputStream} stream 
         * @param {int} value 
         */
        public static writeVarInt(stream: java.io.OutputStream,value: int): void;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         * @param {int} value 
         */
        public static writeVarInt(stream: cn.nukkit.utils.BinaryStream,value: int): void;
        /**
         * 
         * @param {java.io.OutputStream} stream 
         * @param {long} value 
         */
        private static write(stream: java.io.OutputStream,value: long): void;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         * @param {long} value 
         */
        private static write(stream: cn.nukkit.utils.BinaryStream,value: long): void;
        /**
         * 
         * @param {java.io.InputStream} stream 
         */
        public static readVarInt(stream: java.io.InputStream): int;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public static readVarInt(stream: cn.nukkit.utils.BinaryStream): int;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class CompoundTag extends cn.nukkit.nbt.tag.Tag{
        /**  */
        tags: java.util.Map;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getCompound(name: java.lang.String): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getByte(name: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsList(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {byte} type 
         */
        public containsList(name: java.lang.String,type: byte): boolean;
        /**
         * 
         */
        public getTags(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        public put(name: java.lang.String,tag: cn.nukkit.nbt.tag.Tag): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsByte(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsNumber(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.Class} type 
         */
        public getList(name: java.lang.String,type: java.lang.Class): cn.nukkit.nbt.tag.ListTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getList(name: java.lang.String): cn.nukkit.nbt.tag.ListTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsIntArray(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.nbt.tag.CompoundTag} value 
         */
        public putCompound(name: java.lang.String,value: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} string 
         * @param {boolean} val 
         */
        public putBoolean(string: java.lang.String,val: boolean): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
        public write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {java.lang.String} key 
         * @param {cn.nukkit.nbt.tag.Tag} value 
         */
        private static lambda$clone$1(nbt: cn.nukkit.nbt.tag.CompoundTag,key: java.lang.String,value: cn.nukkit.nbt.tag.Tag): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {int} value 
         */
        public putInt(name: java.lang.String,value: int): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsCompound(name: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.ListTag} listTag 
         */
        public putList(listTag: cn.nukkit.nbt.tag.ListTag): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsDouble(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public removeAndGet(name: java.lang.String): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public exist(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getInt(name: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {float} value 
         */
        public putFloat(name: java.lang.String,value: float): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public contains(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsInt(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.util.StringJoiner} joiner 
         * @param {java.lang.String} key 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        private static lambda$toString$0(joiner: java.util.StringJoiner,key: java.lang.String,tag: cn.nukkit.nbt.tag.Tag): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsFloat(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsString(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getDouble(name: java.lang.String): double;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {double} value 
         */
        public putDouble(name: java.lang.String,value: double): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public getAllTags(): java.util.Collection;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getFloat(name: java.lang.String): float;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {long} value 
         */
        public putLong(name: java.lang.String,value: long): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public remove(name: java.lang.String): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {int} value 
         */
        public putByte(name: java.lang.String,value: int): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
        public load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsByteArray(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public get(name: java.lang.String): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {int[]} value 
         */
        public putIntArray(name: java.lang.String,value: int[]): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getBoolean(name: java.lang.String): boolean;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public  copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {int} value 
         */
        public putShort(name: java.lang.String,value: int): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getShort(name: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.String} value 
         */
        public putString(name: java.lang.String,value: java.lang.String): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public containsShort(name: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getString(name: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {byte[]} value 
         */
        public putByteArray(name: java.lang.String,value: byte[]): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getLong(name: java.lang.String): long;
        /**
         * 
         * @param {java.lang.String} prefix 
         * @param {java.io.PrintStream} out 
         */
        public print(prefix: java.lang.String,out: java.io.PrintStream): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public clone(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getByteArray(name: java.lang.String): byte[];
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         */
        public parseValue(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getIntArray(name: java.lang.String): int[];
    }
}
declare namespace cn.nukkit.level.biome.impl.swamp{
     class SwamplandMBiome extends cn.nukkit.level.biome.impl.swamp.SwampBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockGold extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.format.generic{
     class EmptyChunkSection extends java.lang.Object{
        /**  */
        EMPTY_SKY_LIGHT_ARR: byte[];
        /**  */
        EMPTY_LIGHT_ARR: byte[];
        /**  */
        EMPTY_ID_ARRAY: byte[];
        /**  */
        EMPTY_DATA_ARRAY: byte[];
        /**  */
        y: int;
        /**  */
        EMPTY_CHUNK_DATA: byte[];
        /**  */
        EMPTY: cn.nukkit.level.format.generic.EmptyChunkSection[];
        /**  */
        MODIFICATION_ERROR_MESSAGE: java.lang.String;
        /**  */
        EMPTY_2KB: byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public  getBlockData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockData(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlock(x: int,y: int,z: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         */
        public setBlock(x: int,y: int,z: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public setBlockLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockStateAtLayer(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,fullId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,layer: int,fullId: int): boolean;
        /**
         * 
         * @param {int} contentVersion 
         */
        public setContentVersion(contentVersion: int): void;
        /**
         * 
         */
        public toNBT(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getFullBlock(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public  getBlockId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         * @param {int} offsetX 
         * @param {int} offsetZ 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         */
        public scanBlocks(provider: cn.nukkit.level.format.LevelProvider,offsetX: int,offsetZ: int,min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate): java.util.List;
        /**
         * 
         */
        public  copy(): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         */
        public copy(): cn.nukkit.level.format.generic.EmptyChunkSection;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockChangeStateAbove(x: int,y: int,z: int): int;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         */
        public getAndSetBlock(x: int,y: int,z: int,layer: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.block.Block} block 
         */
        public getAndSetBlock(x: int,y: int,z: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public setBlockData(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         */
        public getContentVersion(): int;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public  setBlockId(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public setBlockId(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public setBlockSkyLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         */
        public getY(): int;
        /**
         * 
         */
        public getLightArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public getAndSetBlockState(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getMaximumLayer(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         */
        public setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockState(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getSkyLightArray(): byte[];
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockRedstoneDiode extends cn.nukkit.block.BlockFlowable{
        /**  */
        isPowered: boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        protected abstract getDelay(): int;
        /**
         * 
         */
        protected abstract getPowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        protected shouldBePowered(): boolean;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         */
        protected getPowerOnSides(): int;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public isLocked(): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public static isDiode(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public updateState(): void;
        /**
         * 
         */
        protected getRedstoneSignal(): int;
        /**
         * 
         */
        protected abstract getUnpowered(): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        protected getPowerOnSide(pos: cn.nukkit.math.Vector3,side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public isFacingTowardsRepeater(): boolean;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        protected calculateInputStrength(): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public abstract getFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        protected isAlternateInput(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} support 
         */
        protected isSupportValid(support: cn.nukkit.block.Block): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.extremehills{
     class ExtremeHillsPlusBiome extends cn.nukkit.level.biome.impl.extremehills.ExtremeHillsBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityPortalEnterEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        type: cn.nukkit.event.entity.EntityPortalEnterEvent.PortalType;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPortalType(): cn.nukkit.event.entity.EntityPortalEnterEvent.PortalType;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityMinecartHopper extends cn.nukkit.entity.item.EntityMinecartAbstract{
        /**  */
        NETWORK_ID: int;
        /**  */
        inventory: cn.nukkit.inventory.MinecartHopperInventory;
        /**
         * 
         */
        public dropItem(): void;
        /**
         * 
         */
        public isRideable(): boolean;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getType(): cn.nukkit.utils.MinecartType;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {byte} mode 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity,mode: byte): boolean;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.MinecartHopperInventory;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockBeacon extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public canBePulled(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityPillager extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemGlassBottle extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityDamageByEntityEvent extends cn.nukkit.event.entity.EntityDamageEvent{
        /**  */
        damager: cn.nukkit.entity.Entity;
        /**  */
        knockBack: float;
        /**
         * 
         * @param {float} knockBack 
         */
        public setKnockBack(knockBack: float): void;
        /**
         * 
         */
        public getKnockBack(): float;
        /**
         * 
         */
        public getDamager(): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} damager 
         */
        protected addAttackerModifiers(damager: cn.nukkit.entity.Entity): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockGravel extends cn.nukkit.block.BlockFallable{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PacketViolationWarningPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        severity: cn.nukkit.network.protocol.PacketViolationWarningPacket.PacketViolationSeverity;
        /**  */
        packetId: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        context: java.lang.String;
        /**  */
        type: cn.nukkit.network.protocol.PacketViolationWarningPacket.PacketViolationType;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockTripWire extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        ATTACHED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        SUSPENDED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        DISARMED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         * @param {boolean} value 
         */
        public setAttached(value: boolean): void;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isPowered(): boolean;
        /**
         * 
         */
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {boolean} value 
         */
        public setDisarmed(value: boolean): void;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        protected recalculateCollisionBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public isDisarmed(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public isAttached(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {boolean} scheduleUpdate 
         */
        private updateHook(scheduleUpdate: boolean): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setPowered(value: boolean): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockBricksEndStone extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemRedstone extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.command.defaults{
     class KickCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemMinecart extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockSand extends cn.nukkit.block.BlockFallableMeta{
        /**  */
        RED: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        SAND_TYPE: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        DEFAULT: int;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemSeedsMelon extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.metadata{
    abstract class Metadatable extends java.lang.Object{
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public abstract setMetadata(metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public abstract getMetadata(metadataKey: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public abstract removeMetadata(metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public abstract hasMetadata(metadataKey: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetEntityMotionPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        motionZ: float;
        /**  */
        NETWORK_ID: byte;
        /**  */
        motionY: float;
        /**  */
        motionX: float;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityCombustByEntityEvent extends cn.nukkit.event.entity.EntityCombustEvent{
        /**  */
        combuster: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getCombuster(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.network.protocol{
     class BookEditPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        xuid: java.lang.String;
        /**  */
        pageNumber: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        secondaryPageNumber: int;
        /**  */
        author: java.lang.String;
        /**  */
        action: cn.nukkit.network.protocol.BookEditPacket.Action;
        /**  */
        inventorySlot: int;
        /**  */
        text: java.lang.String;
        /**  */
        photoName: java.lang.String;
        /**  */
        title: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class RemoveEntityPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        NETWORK_ID: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemCarrot extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.item{
     class ItemHelmetGold extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace org.java_websocket.server{
    abstract class WebSocketServer extends org.java_websocket.AbstractWebSocket{
        /**  */
        server: java.nio.channels.ServerSocketChannel;
        /**  */
        address: java.net.InetSocketAddress;
        /**  */
        maxPendingConnections: int;
        /**  */
        log: org.slf4j.Logger;
        /**  */
        buffers: java.util.concurrent.BlockingQueue;
        /**  */
        drafts: java.util.List;
        /**  */
        decoders: java.util.List;
        /**  */
        isclosed: java.util.concurrent.atomic.AtomicBoolean;
        /**  */
        wsf: org.java_websocket.WebSocketServerFactory;
        /**  */
        AVAILABLE_PROCESSORS: int;
        /**  */
        queuesize: java.util.concurrent.atomic.AtomicInteger;
        /**  */
        iqueue: java.util.List;
        /**  */
        queueinvokes: int;
        /**  */
        selector: java.nio.channels.Selector;
        /**  */
        selectorthread: java.lang.Thread;
        /**  */
        connections: java.util.Collection;
        /**
         * 
         * @param {int} arg0 
         */
        public setMaxPendingConnections(arg0: int): void;
        /**
         * 
         */
        public run(): void;
        /**
         * 
         * @param {java.nio.channels.SelectionKey} arg0 
         * @param {org.java_websocket.WebSocket} arg1 
         * @param {java.io.IOException} arg2 
         */
        private handleIOException(arg0: java.nio.channels.SelectionKey,arg1: org.java_websocket.WebSocket,arg2: java.io.IOException): void;
        /**
         * 
         */
        public abstract onStart(): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public onClosing(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         */
        private doAdditionalRead(): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.Exception} arg1 
         */
        private handleFatal(arg0: org.java_websocket.WebSocket,arg1: java.lang.Exception): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         */
        public onCloseInitiated(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.server.WebSocketServer} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         */
        static access$200(arg0: org.java_websocket.server.WebSocketServer,arg1: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {java.nio.channels.SelectionKey} arg0 
         * @param {java.util.Iterator} arg1 
         */
        private doRead(arg0: java.nio.channels.SelectionKey,arg1: java.util.Iterator): boolean;
        /**
         * 
         * @param {java.nio.channels.SelectionKey} arg0 
         * @param {java.util.Iterator} arg1 
         */
        private doAccept(arg0: java.nio.channels.SelectionKey,arg1: java.util.Iterator): void;
        /**
         * 
         * @param {org.java_websocket.server.WebSocketServer} arg0 
         */
        static access$000(arg0: org.java_websocket.server.WebSocketServer): org.slf4j.Logger;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        protected addConnection(arg0: org.java_websocket.WebSocket): boolean;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        private pushBuffer(arg0: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public abstract onClose(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         * @param {int} arg0 
         */
        public stop(arg0: int): void;
        /**
         * 
         */
        public stop(): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.String} arg1 
         */
        public abstract onMessage(arg0: org.java_websocket.WebSocket,arg1: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         */
        public onMessage(arg0: org.java_websocket.WebSocket,arg1: java.nio.ByteBuffer): void;
        /**
         * 
         */
        public getConnections(): java.util.Collection;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public getRemoteSocketAddress(arg0: org.java_websocket.WebSocket): java.net.InetSocketAddress;
        /**
         * 
         */
        public getDraft(): java.util.List;
        /**
         * 
         * @param {byte[]} arg0 
         */
        public broadcast(arg0: byte[]): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.util.Collection} arg1 
         */
        public broadcast(arg0: java.lang.String,arg1: java.util.Collection): void;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         * @param {java.util.Collection} arg1 
         */
        public broadcast(arg0: java.nio.ByteBuffer,arg1: java.util.Collection): void;
        /**
         * 
         * @param {byte[]} arg0 
         * @param {java.util.Collection} arg1 
         */
        public broadcast(arg0: byte[],arg1: java.util.Collection): void;
        /**
         * 
         * @param {java.nio.ByteBuffer} arg0 
         */
        public broadcast(arg0: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public broadcast(arg0: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.String} arg1 
         */
        public  onWebsocketMessage(arg0: org.java_websocket.WebSocket,arg1: java.lang.String): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.nio.ByteBuffer} arg1 
         */
        public  onWebsocketMessage(arg0: org.java_websocket.WebSocket,arg1: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {org.java_websocket.WebSocketServerFactory} arg0 
         */
        public  setWebSocketFactory(arg0: org.java_websocket.WebSocketServerFactory): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.Exception} arg1 
         */
        public  onWebsocketError(arg0: org.java_websocket.WebSocket,arg1: java.lang.Exception): void;
        /**
         * 
         */
        public createBuffer(): java.nio.ByteBuffer;
        /**
         * 
         * @param {java.nio.channels.SelectionKey} arg0 
         */
        private doWrite(arg0: java.nio.channels.SelectionKey): void;
        /**
         * 
         */
        private takeBuffer(): java.nio.ByteBuffer;
        /**
         * 
         * @param {java.nio.channels.SelectionKey} arg0 
         */
        protected onConnect(arg0: java.nio.channels.SelectionKey): boolean;
        /**
         * 
         * @param {org.java_websocket.drafts.Draft} arg0 
         * @param {java.util.Map} arg1 
         * @param {java.lang.String} arg2 
         * @param {java.nio.ByteBuffer} arg3 
         */
        private fillFrames(arg0: org.java_websocket.drafts.Draft,arg1: java.util.Map,arg2: java.lang.String,arg3: java.nio.ByteBuffer): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.ClientHandshake} arg1 
         */
        public abstract onOpen(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.ClientHandshake): void;
        /**
         * 
         */
        private doServerShutdown(): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.Collection} arg1 
         */
        private doBroadcast(arg0: java.lang.Object,arg1: java.util.Collection): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        protected allocateBuffers(arg0: org.java_websocket.WebSocket): void;
        /**
         * 
         */
        public getAddress(): java.net.InetSocketAddress;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public onWebsocketClosing(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         * @param {boolean} arg3 
         */
        public  onWebsocketClose(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String,arg3: boolean): void;
        /**
         * 
         */
        public getMaxPendingConnections(): int;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {java.lang.Exception} arg1 
         */
        public abstract onError(arg0: org.java_websocket.WebSocket,arg1: java.lang.Exception): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public getLocalSocketAddress(arg0: org.java_websocket.WebSocket): java.net.InetSocketAddress;
        /**
         * 
         * @param {org.java_websocket.server.WebSocketServer} arg0 
         * @param {org.java_websocket.WebSocket} arg1 
         * @param {java.lang.Exception} arg2 
         */
        static access$100(arg0: org.java_websocket.server.WebSocketServer,arg1: org.java_websocket.WebSocket,arg2: java.lang.Exception): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.Handshakedata} arg1 
         */
        public  onWebsocketOpen(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.Handshakedata): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public  onWriteDemand(arg0: org.java_websocket.WebSocket): void;
        /**
         * 
         */
        public start(): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {int} arg1 
         * @param {java.lang.String} arg2 
         */
        public onWebsocketCloseInitiated(arg0: org.java_websocket.WebSocket,arg1: int,arg2: java.lang.String): void;
        /**
         * 
         */
        public getPort(): int;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        protected releaseBuffers(arg0: org.java_websocket.WebSocket): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        protected removeConnection(arg0: org.java_websocket.WebSocket): boolean;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        private getSocket(arg0: org.java_websocket.WebSocket): java.net.Socket;
        /**
         * 
         */
        public  getWebSocketFactory(): org.java_websocket.WebSocketFactory;
        /**
         * 
         */
        private doEnsureSingleThread(): boolean;
        /**
         * 
         * @param {org.java_websocket.WebSocketImpl} arg0 
         */
        protected queue(arg0: org.java_websocket.WebSocketImpl): void;
        /**
         * 
         */
        private doSetupSelectorAndServerThread(): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class OnScreenTextureAnimationPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        effectId: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockSkull extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        NO_DROP: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeFlowedInto(): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockPressurePlateStone extends cn.nukkit.block.BlockPressurePlateBase{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        protected computeRedstoneStrength(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityHoglin extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public isBaby(): boolean;
        /**
         * 
         * @param {boolean} baby 
         */
        public setBaby(baby: boolean): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockPrismarine extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        BRICKS: int;
        /**  */
        PRISMARINE_BLOCK_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        DARK: int;
        /**  */
        NORMAL: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.PrismarineBlockType} prismarineBlockType 
         */
        public setPrismarineBlockType(prismarineBlockType: cn.nukkit.blockproperty.value.PrismarineBlockType): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getPrismarineBlockType(): cn.nukkit.blockproperty.value.PrismarineBlockType;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityDamageByBlockEvent extends cn.nukkit.event.entity.EntityDamageEvent{
        /**  */
        damager: cn.nukkit.block.Block;
        /**
         * 
         */
        public getDamager(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityShulker extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockUndyedShulkerBox extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getItemMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemPotatoBaked extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace java.util{
    abstract class Map extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public getOrDefault(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         */
        public abstract entrySet(): java.util.Set;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract containsKey(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.util.function.BiConsumer} arg0 
         */
        public forEach(arg0: java.util.function.BiConsumer): void;
        /**
         * 
         */
        public abstract values(): java.util.Collection;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.function.Function} arg1 
         */
        public computeIfAbsent(arg0: java.lang.Object,arg1: java.util.function.Function): java.lang.Object;
        /**
         * 
         */
        public abstract clear(): void;
        /**
         * 
         */
        public abstract isEmpty(): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public replace(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         * @param {java.lang.Object} arg2 
         */
        public replace(arg0: java.lang.Object,arg1: java.lang.Object,arg2: java.lang.Object): boolean;
        /**
         * 
         * @param {java.util.function.BiFunction} arg0 
         */
        public replaceAll(arg0: java.util.function.BiFunction): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract remove(arg0: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public remove(arg0: java.lang.Object,arg1: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public abstract put(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract containsValue(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public compute(arg0: java.lang.Object,arg1: java.util.function.BiFunction): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public computeIfPresent(arg0: java.lang.Object,arg1: java.util.function.BiFunction): java.lang.Object;
        /**
         * 
         */
        public abstract size(): int;
        /**
         * 
         */
        public abstract hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract get(arg0: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract equals(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.util.Map} arg0 
         */
        public abstract putAll(arg0: java.util.Map): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         * @param {java.util.function.BiFunction} arg2 
         */
        public merge(arg0: java.lang.Object,arg1: java.lang.Object,arg2: java.util.function.BiFunction): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public putIfAbsent(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         */
        public abstract keySet(): java.util.Set;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorJungle extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockEndGateway extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public hasEntityCollision(): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isBreakable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemCookie extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.level.biome.impl.mushroom{
     class MushroomIslandBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         * @param {int} y 
         */
        public getSurfaceBlock(y: int): int;
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MapCreateLockedCopyPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        newMapId: long;
        /**  */
        originalMapId: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class MeCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerKickEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        reason: cn.nukkit.event.player.PlayerKickEvent.Reason;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        reasonString: java.lang.String;
        /**  */
        quitMessage: cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public getQuitMessage(): cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public getReason(): java.lang.String;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getReasonEnum(): cn.nukkit.event.player.PlayerKickEvent.Reason;
        /**
         * 
         * @param {java.lang.String} joinMessage 
         */
        public setQuitMessage(joinMessage: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} quitMessage 
         */
        public setQuitMessage(quitMessage: cn.nukkit.lang.TextContainer): void;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockSlab extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        TOP_SLOT_PROPERTY: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        doubleSlab: int;
        /**  */
        SIMPLE_SLAB_PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public isOnTop(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.block.BlockSlab} slab 
         */
        public abstract isSameType(slab: cn.nukkit.block.BlockSlab): boolean;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public abstract getSlabName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getMinY(): double;
        /**
         * 
         * @param {boolean} top 
         */
        public setOnTop(top: boolean): void;
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemArmor extends cn.nukkit.item.Item{
        /**  */
        TIER_LEATHER: int;
        /**  */
        TIER_IRON: int;
        /**  */
        TIER_NETHERITE: int;
        /**  */
        TIER_OTHER: int;
        /**  */
        TIER_GOLD: int;
        /**  */
        TIER_DIAMOND: int;
        /**  */
        TIER_CHAIN: int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.math.Vector3} directionVector 
         */
        public onClickAir(player: cn.nukkit.Player,directionVector: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public isArmor(): boolean;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public isUnbreakable(): boolean;
        /**
         * 
         */
        public getEnchantAbility(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class LevelChunkPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        subChunkCount: int;
        /**  */
        cacheEnabled: boolean;
        /**  */
        data: byte[];
        /**  */
        NETWORK_ID: byte;
        /**  */
        chunkX: int;
        /**  */
        blobIds: long[];
        /**  */
        chunkZ: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerChangeSkinEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        skin: cn.nukkit.entity.data.Skin;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSkin(): cn.nukkit.entity.data.Skin;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ScriptCustomEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eventData: byte[];
        /**  */
        eventName: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class ListCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.item.enchantment.loot{
     class EnchantmentLootWeapon extends cn.nukkit.item.enchantment.loot.EnchantmentLoot{
    }
}
declare namespace cn.nukkit.level.format{
    abstract class LevelProvider extends java.lang.Object{
        /**  */
        ORDER_YZX: byte;
        /**  */
        ORDER_ZXY: byte;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         */
        public abstract getTime(): long;
        /**
         * 
         * @param {long} time 
         */
        public doGarbageCollection(time: long): void;
        /**
         * 
         */
        public abstract doGarbageCollection(): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract requestChunkTask(X: int,Z: int): cn.nukkit.scheduler.AsyncTask;
        /**
         * 
         */
        public abstract getRainTime(): int;
        /**
         * 
         * @param {boolean} raining 
         */
        public abstract setRaining(raining: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public abstract setSpawn(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract isChunkPopulated(X: int,Z: int): boolean;
        /**
         * 
         */
        public abstract getGeneratorOptions(): java.util.Map;
        /**
         * 
         */
        public abstract saveChunks(): void;
        /**
         * 
         */
        public abstract saveLevelData(): void;
        /**
         * 
         */
        public abstract getGenerator(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.level.GameRules} rules 
         */
        public abstract setGameRules(rules: cn.nukkit.level.GameRules): void;
        /**
         * 
         */
        public abstract getThunderTime(): int;
        /**
         * 
         */
        public abstract getPath(): java.lang.String;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract getEmptyChunk(x: int,z: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract saveChunk(X: int,Z: int,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract saveChunk(X: int,Z: int): void;
        /**
         * 
         * @param {long} hash 
         */
        public abstract getLoadedChunk(hash: long): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract getLoadedChunk(X: int,Z: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public abstract close(): void;
        /**
         * 
         * @param {long} value 
         */
        public abstract setTime(value: long): void;
        /**
         * 
         */
        public abstract getSeed(): long;
        /**
         * 
         */
        public abstract getSpawn(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         * @param {boolean} create 
         */
        public abstract loadChunk(X: int,Z: int,create: boolean): boolean;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract loadChunk(X: int,Z: int): boolean;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public abstract setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {long} currentTick 
         */
        public abstract setCurrentTick(currentTick: long): void;
        /**
         * 
         */
        public abstract unloadChunks(): void;
        /**
         * 
         */
        public abstract getGamerules(): cn.nukkit.level.GameRules;
        /**
         * 
         */
        public abstract getLoadedChunks(): java.util.Map;
        /**
         * 
         */
        public abstract getCurrentTick(): long;
        /**
         * 
         * @param {long} hash 
         */
        public abstract isChunkLoaded(hash: long): boolean;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract isChunkLoaded(X: int,Z: int): boolean;
        /**
         * 
         */
        public abstract getLevel(): cn.nukkit.level.Level;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract isChunkGenerated(X: int,Z: int): boolean;
        /**
         * 
         * @param {int} rainTime 
         */
        public abstract setRainTime(rainTime: int): void;
        /**
         * 
         */
        public getMaximumLayer(): int;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         * @param {boolean} create 
         */
        public abstract getChunk(X: int,Z: int,create: boolean): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract getChunk(X: int,Z: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public abstract isThundering(): boolean;
        /**
         * 
         * @param {boolean} thundering 
         */
        public abstract setThundering(thundering: boolean): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public abstract unloadChunk(X: int,Z: int): boolean;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         * @param {boolean} safe 
         */
        public abstract unloadChunk(X: int,Z: int,safe: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public abstract updateLevelName(name: java.lang.String): void;
        /**
         * 
         * @param {long} value 
         */
        public abstract setSeed(value: long): void;
        /**
         * 
         */
        public abstract isRaining(): boolean;
        /**
         * 
         * @param {int} thunderTime 
         */
        public abstract setThunderTime(thunderTime: int): void;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityExplosive extends java.lang.Object{
        /**
         * 
         */
        public abstract explode(): void;
    }
}
declare namespace cn.nukkit.item.randomitem{
     class RandomItem extends java.lang.Object{
        /**  */
        ROOT: cn.nukkit.item.randomitem.Selector;
        /**  */
        selectors: java.util.Map;
        /**
         * 
         * @param {cn.nukkit.item.randomitem.Selector} selector 
         */
        static selectFrom(selector: cn.nukkit.item.randomitem.Selector): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.item.randomitem.Selector} selector 
         * @param {java.util.Map} child 
         * @param {cn.nukkit.item.randomitem.Selector} s 
         * @param {java.lang.Float} f 
         */
        private static lambda$selectFrom$0(selector: cn.nukkit.item.randomitem.Selector,child: java.util.Map,s: cn.nukkit.item.randomitem.Selector,f: java.lang.Float): void;
        /**
         * 
         * @param {cn.nukkit.item.randomitem.Selector} selector 
         */
        public static putSelector(selector: cn.nukkit.item.randomitem.Selector): cn.nukkit.item.randomitem.Selector;
        /**
         * 
         * @param {cn.nukkit.item.randomitem.Selector} selector 
         * @param {float} chance 
         */
        public static putSelector(selector: cn.nukkit.item.randomitem.Selector,chance: float): cn.nukkit.item.randomitem.Selector;
    }
}
declare namespace cn.nukkit.network{
    abstract class AdvancedSourceInterface extends java.lang.Object{
        /**
         * 
         * @param {java.net.InetAddress} address 
         */
        public abstract unblockAddress(address: java.net.InetAddress): void;
        /**
         * 
         * @param {cn.nukkit.network.Network} network 
         */
        public abstract setNetwork(network: cn.nukkit.network.Network): void;
        /**
         * 
         * @param {java.net.InetSocketAddress} socketAddress 
         * @param {io.netty.buffer.ByteBuf} payload 
         */
        public abstract sendRawPacket(socketAddress: java.net.InetSocketAddress,payload: io.netty.buffer.ByteBuf): void;
        /**
         * 
         * @param {java.net.InetAddress} address 
         */
        public abstract blockAddress(address: java.net.InetAddress): void;
        /**
         * 
         * @param {java.net.InetAddress} address 
         * @param {int} timeout 
         */
        public abstract blockAddress(address: java.net.InetAddress,timeout: int): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemHelmetLeather extends cn.nukkit.item.ItemColorArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.event.vehicle{
     class VehicleMoveEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        from: cn.nukkit.level.Location;
        /**  */
        to: cn.nukkit.level.Location;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getTo(): cn.nukkit.level.Location;
        /**
         * 
         */
        public getFrom(): cn.nukkit.level.Location;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneRepeaterUnpowered extends cn.nukkit.block.BlockRedstoneRepeater{
        /**
         * 
         */
        protected getUnpowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        protected getPowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class UpdateSoftEnumPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        values: java.lang.String[];
        /**  */
        name: java.lang.String;
        /**  */
        type: cn.nukkit.network.protocol.UpdateSoftEnumPacket.Type;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockFenceNetherBrick extends cn.nukkit.block.BlockFenceBase{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class SpruceBigTreePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.scheduler{
     class ServerScheduler extends java.lang.Object{
        /**  */
        currentTick: int;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        WORKERS: int;
        /**  */
        currentTaskId: java.util.concurrent.atomic.AtomicInteger;
        /**  */
        pending: java.util.Queue;
        /**  */
        taskMap: java.util.Map;
        /**  */
        queueMap: java.util.Map;
        /**  */
        asyncPool: cn.nukkit.scheduler.AsyncPool;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} delay 
         * @param {boolean} asynchronous 
         */
        public scheduleDelayedTask(task: cn.nukkit.scheduler.Task,delay: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         */
        public scheduleDelayedTask(task: java.lang.Runnable,delay: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {boolean} asynchronous 
         */
        public scheduleDelayedTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,delay: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} delay 
         */
        public scheduleDelayedTask(task: cn.nukkit.scheduler.Task,delay: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {boolean} asynchronous 
         */
        public scheduleDelayedTask(task: java.lang.Runnable,delay: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         */
        public scheduleDelayedTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,delay: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         */
        private nextTaskId(): int;
        /**
         * 
         */
        public getQueueSize(): int;
        /**
         * 
         * @param {int} currentTick 
         */
        private runTasks(currentTick: int): void;
        /**
         * 
         */
        public cancelAllTasks(): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        public scheduleDelayedRepeatingTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,delay: int,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        public scheduleDelayedRepeatingTask(task: java.lang.Runnable,delay: int,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {int} period 
         */
        public scheduleDelayedRepeatingTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,delay: int,period: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {int} period 
         */
        public scheduleDelayedRepeatingTask(task: java.lang.Runnable,delay: int,period: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} delay 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        public scheduleDelayedRepeatingTask(task: cn.nukkit.scheduler.Task,delay: int,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} delay 
         * @param {int} period 
         */
        public scheduleDelayedRepeatingTask(task: cn.nukkit.scheduler.Task,delay: int,period: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         */
        public getAsyncTaskPoolSize(): int;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public cancelTask(plugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {int} taskId 
         */
        public cancelTask(taskId: int): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public mainThreadHeartbeat(currentTick: int): void;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} delay 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        private addTask(task: cn.nukkit.scheduler.Task,delay: int,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} delay 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        private addTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,delay: int,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.AsyncTask} task 
         */
        public scheduleAsyncTask(task: cn.nukkit.scheduler.AsyncTask): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {cn.nukkit.scheduler.AsyncTask} task 
         */
        public scheduleAsyncTask(plugin: cn.nukkit.plugin.Plugin,task: cn.nukkit.scheduler.AsyncTask): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {int} newSize 
         */
        public increaseAsyncTaskPoolSize(newSize: int): void;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         */
        public scheduleTask(task: cn.nukkit.scheduler.Task): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         */
        public scheduleTask(task: java.lang.Runnable): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {boolean} asynchronous 
         */
        public scheduleTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         */
        public scheduleTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {boolean} asynchronous 
         */
        public scheduleTask(task: java.lang.Runnable,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.AsyncTask} task 
         * @param {int} worker 
         */
        public scheduleAsyncTaskToWorker(task: cn.nukkit.scheduler.AsyncTask,worker: int): void;
        /**
         * 
         * @param {int} taskId 
         */
        public isQueued(taskId: int): boolean;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        public scheduleRepeatingTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        public scheduleRepeatingTask(task: cn.nukkit.scheduler.Task,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.scheduler.Task} task 
         * @param {int} period 
         */
        public scheduleRepeatingTask(task: cn.nukkit.scheduler.Task,period: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {int} period 
         * @param {boolean} asynchronous 
         */
        public scheduleRepeatingTask(task: java.lang.Runnable,period: int,asynchronous: boolean): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.Runnable} task 
         * @param {int} period 
         */
        public scheduleRepeatingTask(plugin: cn.nukkit.plugin.Plugin,task: java.lang.Runnable,period: int): cn.nukkit.scheduler.TaskHandler;
        /**
         * 
         * @param {java.lang.Runnable} task 
         * @param {int} period 
         */
        public scheduleRepeatingTask(task: java.lang.Runnable,period: int): cn.nukkit.scheduler.TaskHandler;
    }
}
declare namespace cn.nukkit.network.protocol{
     class InventorySlotPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        NETWORK_ID: byte;
        /**  */
        inventoryId: int;
        /**  */
        slot: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.event.vehicle{
     class EntityExitVehicleEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        riding: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public isPlayer(): boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentThorns extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {java.util.concurrent.ThreadLocalRandom} random 
         * @param {int} level 
         */
        private static getDamage(random: java.util.concurrent.ThreadLocalRandom,level: int): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {java.util.concurrent.ThreadLocalRandom} random 
         * @param {int} level 
         */
        private static shouldHit(random: java.util.concurrent.ThreadLocalRandom,level: int): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} attacker 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public doPostAttack(attacker: cn.nukkit.entity.Entity,entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemEgg extends cn.nukkit.item.ProjectileItem{
        /**
         * 
         */
        public getProjectileEntityType(): java.lang.String;
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         */
        public getThrowForce(): float;
    }
}
declare namespace cn.nukkit.math{
     class BlockFace extends java.lang.Enum{
        /**  */
        HORIZONTALS: cn.nukkit.math.BlockFace[];
        /**  */
        DOWN: cn.nukkit.math.BlockFace;
        /**  */
        unitVector: cn.nukkit.math.Vector3;
        /**  */
        horizontalIndex: int;
        /**  */
        WEST: cn.nukkit.math.BlockFace;
        /**  */
        index: int;
        /**  */
        opposite: int;
        /**  */
        axis: cn.nukkit.math.BlockFace.Axis;
        /**  */
        NORTH: cn.nukkit.math.BlockFace;
        /**  */
        axisDirection: cn.nukkit.math.BlockFace.AxisDirection;
        /**  */
        name: java.lang.String;
        /**  */
        VALUES: cn.nukkit.math.BlockFace[];
        /**  */
        UP: cn.nukkit.math.BlockFace;
        /**  */
        SOUTH: cn.nukkit.math.BlockFace;
        /**  */
        EAST: cn.nukkit.math.BlockFace;
        /**  */
        $VALUES: cn.nukkit.math.BlockFace[];
        /**
         * 
         */
        public getXOffset(): int;
        /**
         * 
         */
        public getHorizontalAngle(): float;
        /**
         * 
         */
        public getAxisDirection(): cn.nukkit.math.BlockFace.AxisDirection;
        /**
         * 
         * @param {double} angle 
         */
        public static fromHorizontalAngle(angle: double): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getIndex(): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public static values(): cn.nukkit.math.BlockFace[];
        /**
         * 
         */
        public rotateYCCW(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getAxis(): cn.nukkit.math.BlockFace.Axis;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace.AxisDirection} axisDirection 
         * @param {cn.nukkit.math.BlockFace.Axis} axis 
         */
        public static fromAxis(axisDirection: cn.nukkit.math.BlockFace.AxisDirection,axis: cn.nukkit.math.BlockFace.Axis): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getYOffset(): int;
        /**
         * 
         * @param {java.util.Random} rand 
         */
        public static random(rand: java.util.Random): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getHorizontalIndex(): int;
        /**
         * 
         * @param {int} index 
         */
        public static fromHorizontalIndex(index: int): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getZOffset(): int;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getOpposite(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getCompassRoseDirection(): cn.nukkit.math.CompassRoseDirection;
        /**
         * 
         */
        public getUnitVector(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} index 
         */
        public static fromIndex(index: int): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public rotateY(): cn.nukkit.math.BlockFace;
    }
}
declare namespace cn.nukkit.block{
     class BlockIcePacked extends cn.nukkit.block.BlockIce{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getLightFilter(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.item.enchantment.protection{
     class EnchantmentProtectionFire extends cn.nukkit.item.enchantment.protection.EnchantmentProtection{
        /**
         * 
         */
        public getTypeModifier(): double;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} e 
         */
        public getProtectionFactor(e: cn.nukkit.event.entity.EntityDamageEvent): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoeDiamond extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.scheduler{
    abstract class PluginTask extends cn.nukkit.scheduler.Task{
        /**  */
        owner: cn.nukkit.plugin.Plugin;
        /**
         * 
         */
        public  getOwner(): cn.nukkit.plugin.Plugin;
    }
}
declare namespace cn.nukkit.event.server{
     class BatchPacketsEvent extends cn.nukkit.event.server.ServerEvent{
        /**  */
        forceSync: boolean;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        players: cn.nukkit.Player[];
        /**  */
        packets: cn.nukkit.network.protocol.DataPacket[];
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getPackets(): cn.nukkit.network.protocol.DataPacket[];
        /**
         * 
         */
        public isForceSync(): boolean;
        /**
         * 
         */
        public getPlayers(): cn.nukkit.Player[];
    }
}
declare namespace cn.nukkit.level.particle{
     class GenericParticle extends cn.nukkit.level.particle.Particle{
        /**  */
        data: int;
        /**  */
        id: int;
        /**
         * 
         */
        public encode(): cn.nukkit.network.protocol.DataPacket[];
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityWither extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemRabbitStew extends cn.nukkit.item.ItemEdible{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordMellohi extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.permission{
     class PermissibleBase extends java.lang.Object{
        /**  */
        parent: cn.nukkit.permission.Permissible;
        /**  */
        attachments: java.util.Set;
        /**  */
        permissions: java.util.Map;
        /**  */
        opable: cn.nukkit.permission.ServerOperator;
        /**
         * 
         */
        public clearPermissions(): void;
        /**
         * 
         */
        public getEffectivePermissions(): java.util.Map;
        /**
         * 
         * @param {boolean} value 
         */
        public setOp(value: boolean): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public hasPermission(name: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public hasPermission(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         */
        public isOp(): boolean;
        /**
         * 
         * @param {java.util.Map} children 
         * @param {boolean} invert 
         * @param {cn.nukkit.permission.PermissionAttachment} attachment 
         */
        private calculateChildPermissions(children: java.util.Map,invert: boolean,attachment: cn.nukkit.permission.PermissionAttachment): void;
        /**
         * 
         */
        public recalculatePermissions(): void;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {java.lang.String} name 
         * @param {java.lang.Boolean} value 
         */
        public addAttachment(plugin: cn.nukkit.plugin.Plugin,name: java.lang.String,value: java.lang.Boolean): cn.nukkit.permission.PermissionAttachment;
        /**
         * 
         * @param {cn.nukkit.permission.PermissionAttachment} attachment 
         */
        public removeAttachment(attachment: cn.nukkit.permission.PermissionAttachment): void;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} permission 
         */
        public isPermissionSet(permission: cn.nukkit.permission.Permission): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public isPermissionSet(name: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerDeathEvent extends cn.nukkit.event.entity.EntityDeathEvent{
        /**  */
        deathMessage: cn.nukkit.lang.TextContainer;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        experience: int;
        /**  */
        keepExperience: boolean;
        /**  */
        keepInventory: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getKeepInventory(): boolean;
        /**
         * 
         */
        public getExperience(): int;
        /**
         * 
         * @param {int} experience 
         */
        public setExperience(experience: int): void;
        /**
         * 
         * @param {boolean} keepInventory 
         */
        public setKeepInventory(keepInventory: boolean): void;
        /**
         * 
         * @param {java.lang.String} deathMessage 
         */
        public setDeathMessage(deathMessage: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} deathMessage 
         */
        public setDeathMessage(deathMessage: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         */
        public  getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.Player;
        /**
         * 
         */
        public getDeathMessage(): cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public getKeepExperience(): boolean;
        /**
         * 
         * @param {boolean} keepExperience 
         */
        public setKeepExperience(keepExperience: boolean): void;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityBrewingStand extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**  */
        MAX_BREW_TIME: int;
        /**  */
        brewTime: int;
        /**  */
        ingredients: java.util.List;
        /**  */
        inventory: cn.nukkit.inventory.BrewingInventory;
        /**  */
        fuelTotal: int;
        /**  */
        fuelAmount: int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setName(name: java.lang.String): void;
        /**
         * 
         */
        public onBreak(): void;
        /**
         * 
         * @param {boolean} quickTest 
         */
        private matchRecipes(quickTest: boolean): cn.nukkit.inventory.MixRecipe[];
        /**
         * 
         */
        private stopBrewing(): void;
        /**
         * 
         */
        public hasName(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        protected sendBrewTime(): void;
        /**
         * 
         * @param {int} index 
         */
        public getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} ingredient 
         */
        protected checkIngredient(ingredient: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        protected sendFuel(): void;
        /**
         * 
         */
        public updateBlock(): void;
        /**
         * 
         */
        public getSize(): int;
        /**
         * 
         * @param {int} fuel 
         */
        public setFuel(fuel: int): void;
        /**
         * 
         */
        public getFuel(): int;
        /**
         * 
         * @param {int} index 
         */
        protected getSlotIndex(index: int): int;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        private restockFuel(): void;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
        /**
         * 
         */
        public  getInventory(): cn.nukkit.inventory.Inventory;
        /**
         * 
         */
        public getInventory(): cn.nukkit.inventory.BrewingInventory;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        public onUpdate(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(index: int,item: cn.nukkit.item.Item): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockBricksNether extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockShulkerBox extends cn.nukkit.block.BlockUndyedShulkerBox{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.format{
    abstract class Chunk extends java.lang.Object{
        /**  */
        SECTION_COUNT: byte;
        /**
         * 
         * @param {float} fY 
         */
        public abstract isSectionEmpty(fY: float): boolean;
        /**
         * 
         * @param {float} fY 
         */
        public abstract getSection(fY: float): cn.nukkit.level.format.ChunkSection;
        /**
         * 
         * @param {float} fY 
         * @param {cn.nukkit.level.format.ChunkSection} section 
         */
        public abstract setSection(fY: float,section: cn.nukkit.level.format.ChunkSection): boolean;
        /**
         * 
         */
        public abstract getSections(): cn.nukkit.level.format.ChunkSection[];
    }
}
declare namespace cn.nukkit.plugin{
     class PluginDescription extends java.lang.Object{
        /**  */
        website: java.lang.String;
        /**  */
        depend: java.util.List;
        /**  */
        prefix: java.lang.String;
        /**  */
        description: java.lang.String;
        /**  */
        main: java.lang.String;
        /**  */
        loadBefore: java.util.List;
        /**  */
        version: java.lang.String;
        /**  */
        permissions: java.util.List;
        /**  */
        softDepend: java.util.List;
        /**  */
        name: java.lang.String;
        /**  */
        api: java.util.List;
        /**  */
        commands: java.util.Map;
        /**  */
        authors: java.util.List;
        /**  */
        order: cn.nukkit.plugin.PluginLoadOrder;
        /**
         * 
         */
        public getVersion(): java.lang.String;
        /**
         * 
         */
        public getWebsite(): java.lang.String;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getPrefix(): java.lang.String;
        /**
         * 
         * @param {java.util.Map} plugin 
         */
        private loadMap(plugin: java.util.Map): void;
        /**
         * 
         */
        public getPermissions(): java.util.List;
        /**
         * 
         */
        public getCompatibleAPIs(): java.util.List;
        /**
         * 
         */
        public getDescription(): java.lang.String;
        /**
         * 
         */
        public getMain(): java.lang.String;
        /**
         * 
         */
        public getCommands(): java.util.Map;
        /**
         * 
         */
        public getSoftDepend(): java.util.List;
        /**
         * 
         */
        public getLoadBefore(): java.util.List;
        /**
         * 
         */
        public getAuthors(): java.util.List;
        /**
         * 
         */
        public getOrder(): cn.nukkit.plugin.PluginLoadOrder;
        /**
         * 
         */
        public getFullName(): java.lang.String;
        /**
         * 
         */
        public getDepend(): java.util.List;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorTree extends cn.nukkit.level.generator.populator.type.PopulatorCount{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populateCount(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSwordNetherite extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace manager{
    /**  */
    var qq: com.blocklynukkit.loader.other.lizi.bnqqbot;
    /**  */
    var jvm: com.blocklynukkit.loader.other.control.JVM;
    /**  */
    var plugin: com.blocklynukkit.loader.Loader;
    /**  */
    var timing: com.blocklynukkit.loader.other.Timing;
    /**
     * 获取网络或本地的资源内容
     * @param {java.lang.String} name URL或文件路径
     */
    function getResource(name: java.lang.String): java.lang.String;
    /**
     * 获取当前服务器在线的所有玩家
     */
    function getOnlinePlayers(): cn.nukkit.Player[];
    /**
     * 加载一个新的php插件
     * @param {java.lang.String} name 插件名
     * @param {java.lang.String} code 插件代码
     */
    function newPHPPlugin(name: java.lang.String,code: java.lang.String): void;
    /**
     * 从xyz构建三维向量
     * @param {double} x 向量x分量
     * @param {double} y 向量y分量
     * @param {double} z 向量z分量
     */
    function buildvec3(x: double,y: double,z: double): cn.nukkit.math.Vector3;
    /**
     * 将指定路径的文件当作bn插件加载
     * @param {java.lang.String} path 绝对路径或相对路径
     */
    function newPlugin(path: java.lang.String): void;
    /**
     * 此函数已经废弃
     * @param {java.lang.String} host 此函数已经放弃
     * @param {int} port 此函数已经放弃
     * @param {java.lang.String} callback 此函数已经放弃
     */
    function getServerMotd(host: java.lang.String,port: int,callback: java.lang.String): void;
    /**
     * 此函数已经废弃
     * @param {java.lang.String} event 此函数已经废弃
     * @param {java.lang.String} callname 此函数已经废弃
     */
    function setPrivateCall(event: java.lang.String,callname: java.lang.String): void;
    /**
     * 获取玩家设备的操作系统名称
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerDeviceOS(player: cn.nukkit.Player): java.lang.String;
    /**
     * 通过smtp服务器发送电子邮件
     * @param {java.lang.String} smtpMailServer smtp服务器地址
     * @param {java.lang.String} from 发件人
     * @param {java.lang.String} to 收件人
     * @param {java.lang.String} cc 抄送
     * @param {java.lang.String} bcc 隐式抄送
     * @param {java.lang.String} subject 主题
     * @param {java.lang.String} content 内容
     */
    function sendMail(smtpMailServer: java.lang.String,from: java.lang.String,to: java.lang.String,cc: java.lang.String,bcc: java.lang.String,subject: java.lang.String,content: java.lang.String): void;
    /**
     * 调用其他插件或本插件的的函数
     * @param {java.lang.String} functionname 要调用的函数名，格式为 插件名::函数名
     * @param {java.lang.Object[]} args 调用参数
     */
    function callFunction(functionname: java.lang.String,...args: java.lang.Object[]): java.lang.Object;
    /**
     * 加载一个新的js插件
     * @param {java.lang.String} name 插件名
     * @param {java.lang.String} code 插件代码
     */
    function newJSPlugin(name: java.lang.String,code: java.lang.String): void;
    /**
     * 从指定文件名的bn插件中获取指定变量名的变量
     * @param {java.lang.String} scriptName 插件文件名
     * @param {java.lang.String} varName 变量名
     */
    function getVariableFrom(scriptName: java.lang.String,varName: java.lang.String): java.lang.Object;
    /**
     * 获取指定路径的文件大小，如果是文件夹返回-1
     * @param {java.lang.String} path 绝对路径或相对路径，非文件夹
     */
    function getFileSize(path: java.lang.String): long;
    /**
     * 将指定文件名的bn插件中的指定变量设为指定值
     * @param {java.lang.String} scriptName 插件文件名
     * @param {java.lang.String} varName 变量名
     * @param {java.lang.Object} _var 变量对应的值
     */
    function putVariableTo(scriptName: java.lang.String,varName: java.lang.String,_var: java.lang.Object): void;
    /**
     * 格式化JSON字符串（重排版）
     * @param {java.lang.String} json 要格式化的json字符串
     */
    function formatJSON(json: java.lang.String): java.lang.String;
    /**
     * 此函数已废弃
     * @param {int} id 此函数已废弃
     */
    function clearTimeout(id: int): void;
    /**
     * 是否运行在Windows系统上
     */
    function isWindows(): boolean;
    /**
     * 创建新的权限节点
     * @param {java.lang.String} per 权限节点名称
     * @param {java.lang.String} description 权限节点描述
     * @param {java.lang.String} defaultper 默认授权，可以为OP/ALL或者NONE
     */
    function createPermission(per: java.lang.String,description: java.lang.String,defaultper: java.lang.String): void;
    /**
     * 加载一个新的python插件
     * @param {java.lang.String} name 插件名
     * @param {java.lang.String} code 插件代码
     */
    function newPYPlugin(name: java.lang.String,code: java.lang.String): void;
    /**
     * 获取玩家的具体地理位置
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerArea(player: cn.nukkit.Player): java.lang.String;
    /**
     * 设置玩家金钱
     * @param {java.lang.String} player 玩家名
     * @param {double} money 金钱
     */
    function setMoney(player: java.lang.String,money: double): void;
    /**
     * 设置玩家金钱
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {double} money 金钱
     */
    function setMoney(player: cn.nukkit.Player,money: double): void;
    /**
     * 创建新的命令
     * @param {java.lang.String} name 命令主名
     * @param {java.lang.String} description 命令描述
     * @param {java.lang.String} functionName 命令回调函数
     * @param {java.lang.String} per 命令对应的权限节点
     */
    function createCommand(name: java.lang.String,description: java.lang.String,functionName: Fun2<cn.nukkit.command.CommandSender,java.lang.String[]>,per: java.lang.String): void;
    /**
     * 创建新的命令
     * @param {java.lang.String} name 命令主名
     * @param {java.lang.String} description 命令描述
     * @param {java.lang.String} functionName 命令回调函数
     */
    function createCommand(name: java.lang.String,description: java.lang.String,functionName: Fun2<cn.nukkit.command.CommandSender,java.lang.String[]>): void;
    /**
     * 
     * @param {com.blocklynukkit.loader.script.FunctionManager} arg0 
     */
    function access$000(arg0: com.blocklynukkit.loader.script.FunctionManager): com.blocklynukkit.loader.Loader;
    /**
     * 获取一个事件对象可用的所有成员函数的函数名
     * @param {cn.nukkit.event.Event} event 事件对象
     */
    function getEventFunctions(event: cn.nukkit.event.Event): java.lang.String[];
    /**
     * 创建WebSocket服务器
     * @param {int} port 端口
     * @param {java.lang.String} newWsConnectCallback 有新的ws客户端连接回调
     * @param {java.lang.String} closeWsConnectCallback ws客户端断开连接回调
     * @param {java.lang.String} receiveStringCallback 接收到字符串数据回调
     * @param {java.lang.String} receiveDataCallback 接收到非字符串数据回调
     */
    function createWsServer(port: int,newWsConnectCallback: Fun2<com.blocklynukkit.loader.other.net.websocket.WsServer,org.java_websocket.WebSocket>,closeWsConnectCallback: Fun5<com.blocklynukkit.loader.other.net.websocket.WsServer,org.java_websocket.WebSocket,int,java.lang.String,boolean>,receiveStringCallback: Fun3<com.blocklynukkit.loader.other.net.websocket.WsServer,org.java_websocket.WebSocket,java.lang.String>,receiveDataCallback: Fun3<com.blocklynukkit.loader.other.net.websocket.WsServer,org.java_websocket.WebSocket,java.nio.ByteBuffer>): com.blocklynukkit.loader.other.net.websocket.WsServer;
    /**
     * 获取配置文件对象中的所有键
     * @param {cn.nukkit.utils.Config} config 配置文件对象
     */
    function getAllKeyInConfig(config: cn.nukkit.utils.Config): java.lang.String[];
    /**
     * 
     * @param {java.lang.String} callbackFunction 事件回调函数
     * @param {cn.nukkit.event.Listener} listener 
     * @param {cn.nukkit.event.Event} event 
     */
    function lambda$customEventListener$0(callbackFunction: Fun1<cn.nukkit.event.Event>,listener: cn.nukkit.event.Listener,event: cn.nukkit.event.Event): void;
    /**
     * 进行垃圾回收，释放无用内存，该函数会暂时阻塞线程
     */
    function jvmGC(): void;
    /**
     * 检查玩家是否永远指定权限节点
     * @param {java.lang.String} per 
     * @param {cn.nukkit.Player} player 
     */
    function checkPlayerPermission(per: java.lang.String,player: cn.nukkit.Player): boolean;
    /**
     * 
     * @param {java.lang.String} method 
     */
    function fiterMethod(method: java.lang.String): boolean;
    /**
     * 此函数不对外暴露
     * @param {java.lang.String} callback 
     * @param {int} delay 
     * @param {java.lang.Object[]} args 
     */
    function __setIntervalInner(callback: java.lang.String,delay: int,...args: java.lang.Object[]): int;
    /**
     * 字符串MD5加密，返回密文
     * @param {java.lang.String} str 要加密的字符串
     */
    function MD5Encryption(str: java.lang.String): java.lang.String;
    /**
     * 设置NK分支号（用于装13）划掉
     * @param {java.lang.String} string 新的NK分支版本号名称
     */
    function setNukkitCodeVersion(string: java.lang.String): void;
    /**
     * 创建新的延迟任务，返回任务对象
     * @param {java.lang.String} functionName 任务回调函数名
     * @param {int} delay 任务延迟(刻)
     * @param {java.lang.Object[]} args 回调函数调用参数
     */
    function createTask(functionName: FunV,delay: int,...args: java.lang.Object[]): cn.nukkit.scheduler.TaskHandler;
    /**
     * 指定文件路径是否存在
     * @param {java.lang.String} path 绝对路径或相对路径
     */
    function isPathExists(path: java.lang.String): boolean;
    /**
     * 取出简易存储数字
     * @param {java.lang.String} string 键
     */
    function getEasyNumber(string: java.lang.String): double;
    /**
     * 将一个路径上的文件复制到另一个路径
     * @param {java.lang.String} fromPath 绝对路径或相对路径，非文件夹
     * @param {java.lang.String} toPath 绝对路径或相对路径，非文件夹
     */
    function copyFile(fromPath: java.lang.String,toPath: java.lang.String): void;
    /**
     * 路径上的文件是否可读
     * @param {java.lang.String} path 绝对路径或相对路径，非文件夹
     */
    function isPathReadable(path: java.lang.String): boolean;
    /**
     * 将处理器函数绑定到指定端口的http服务器上
     * @param {int} port 要绑定处理器函数的http服务器的端口
     * @param {java.lang.String} path 要绑定处理器处理的访问路径
     * @param {java.lang.String} _function 要绑定的处理器函数
     */
    function attachHandlerToHttpServer(port: int,path: java.lang.String,_function: Fun1<com.blocklynukkit.loader.other.net.http.HttpRequestEntry>): boolean;
    /**
     * 加载指定路径上的jar包作为第三方依赖库
     * @param {java.lang.String} path jar包的路径
     */
    function loadJar(path: java.lang.String): void;
    /**
     * 获取正在使用的内存大小
     */
    function getMemoryUsedSizeMB(): double;
    /**
     * 获取玩家设备唯一识别码
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerDeviceID(player: cn.nukkit.Player): java.lang.String;
    /**
     * 获取CPU负载
     */
    function getCPULoad(): double;
    /**
     * 向简易存储放入内容
     * @param {java.lang.String} string 键
     * @param {java.lang.Object} object 值
     */
    function putEasy(string: java.lang.String,object: java.lang.Object): void;
    /**
     * 并行运行函数
     * @param {java.lang.String} functionName 函数名
     * @param {java.lang.Object[]} args 参数
     */
    function concurrentRun(functionName: FunV,...args: java.lang.Object[]): void;
    /**
     * 取出简易存储物品
     * @param {java.lang.String} string 键
     */
    function getEasyItem(string: java.lang.String): cn.nukkit.item.Item;
    /**
     * 调用bStats统计服务
     * @param {java.lang.String} pluginName 插件名称
     * @param {java.lang.String} pluginVer 版本
     * @param {java.lang.String} authorName 作者名
     * @param {int} pluginid 唯一识别符ID
     */
    function bStats(pluginName: java.lang.String,pluginVer: java.lang.String,authorName: java.lang.String,pluginid: int): void;
    /**
     * 加载一个新的lua插件
     * @param {java.lang.String} name 插件名
     * @param {java.lang.String} code 插件代码
     */
    function newLUAPlugin(name: java.lang.String,code: java.lang.String): void;
    /**
     * 为指定玩家构建4D皮肤
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {java.lang.String} skinname 皮肤名
     */
    function buildskin(player: cn.nukkit.Player,skinname: java.lang.String): void;
    /**
     * YAML字符串转JSON字符串
     * @param {java.lang.String} yaml 要转换的YAML字符串
     */
    function YAMLtoJSON(yaml: java.lang.String): java.lang.String;
    /**
     * 是否运行在PowerNukkit上
     */
    function isPowerNukkit(): boolean;
    /**
     * 创建WebSocket客户端
     * @param {java.lang.String} serverUrl 远程ws服务器链接
     * @param {java.lang.String} newWsConnectCallback ws成功连接回调
     * @param {java.lang.String} closeWsConnectCallback ws客户端断开连接回调
     * @param {java.lang.String} receiveStringCallback 接收到字符串数据回调
     * @param {java.lang.String} receiveDataCallback 接收到非字符串数据回调
     */
    function createWsClient(serverUrl: java.lang.String,newWsConnectCallback: Fun2<com.blocklynukkit.loader.other.net.websocket.WsClient,org.java_websocket.WebSocket>,closeWsConnectCallback: Fun5<com.blocklynukkit.loader.other.net.websocket.WsClient,org.java_websocket.WebSocket,int,java.lang.String,boolean>,receiveStringCallback: Fun3<com.blocklynukkit.loader.other.net.websocket.WsClient,org.java_websocket.WebSocket,java.lang.String>,receiveDataCallback: Fun3<com.blocklynukkit.loader.other.net.websocket.WsClient,org.java_websocket.WebSocket,java.nio.ByteBuffer>): com.blocklynukkit.loader.other.net.websocket.WsClient;
    /**
     * 踢出指定玩家
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {java.lang.String} reason 踢出原因
     */
    function kickPlayer(player: cn.nukkit.Player,reason: java.lang.String): void;
    /**
     * 此函数已废弃
     * @param {jdk.nashorn.api.scripting.ScriptObjectMirror} scriptObjectMirror 此函数已废弃
     * @param {int} delay 此函数已废弃
     * @param {java.lang.Object[]} args 此函数已废弃
     */
    function setTimeout(scriptObjectMirror: jdk.nashorn.api.scripting.ScriptObjectMirror,delay: int,...args: java.lang.Object[]): int;
    /**
     * 
     */
    function plugin(): com.blocklynukkit.loader.Loader;
    /**
     * 以自适应编码读取本地文本文件
     * @param {java.lang.String} path 文本文件的路径
     */
    function readFile(path: java.lang.String): java.lang.String;
    /**
     * 根据插件名获取其他的java插件对象
     * @param {java.lang.String} name 其他java插件的注册名
     */
    function getPlugin(name: java.lang.String): cn.nukkit.plugin.Plugin;
    /**
     * 获取指定路径下的所有文件和文件夹名称
     * @param {java.lang.String} path 绝对路径或相对路径
     */
    function getFolderFiles(path: java.lang.String): java.lang.String[];
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 设置快速建站模块的html占位符
     * @param {java.lang.String} key 占位符
     * @param {java.lang.String} value 替换为的值
     */
    function setHTMLPlaceholder(key: java.lang.String,value: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} functionName 函数名
     * @param {java.lang.Object[]} args 参数
     */
    function lambda$concurrentRun$2(functionName: FunV,args: java.lang.Object[]): void;
    /**
     * 执行系统控制台命令
     * @param {java.lang.String} cmd 命令具体内容
     */
    function runCMD(cmd: java.lang.String): void;
    /**
     * 为指定玩家构建4D皮肤并且只能让特定的其他玩家看见
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {java.lang.String} skinname 皮肤名
     * @param {cn.nukkit.Player} to 能看见的另一个玩家
     */
    function buildskinfor(player: cn.nukkit.Player,skinname: java.lang.String,to: cn.nukkit.Player): void;
    /**
     * 
     * @param {int} time 
     */
    function strzero(time: int): java.lang.String;
    /**
     * 为指定命令添加或覆写命令补全器
     * @param {java.lang.String} cmd 命令主名
     * @param {java.lang.String} id 补全器ID，nk默认补全器id为default
     * @param {java.lang.String} completer 补全器补全的规则，详见bnwiki#专题#命令补全器
     */
    function addCommandCompleter(cmd: java.lang.String,id: java.lang.String,completer: java.lang.String): void;
    /**
     * 获取玩家的游戏模式
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerGameMode(player: cn.nukkit.Player): int;
    /**
     * 获取本地文件对象
     * @param {java.lang.String} folder 文件夹名
     * @param {java.lang.String} archive 文件名
     */
    function getFile(folder: java.lang.String,archive: java.lang.String): java.io.File;
    /**
     * 根据任务id取消运行或等待中的任务
     * @param {int} id 任务对象的id
     */
    function cancelTask(id: int): void;
    /**
     * 取出简易存储方块
     * @param {java.lang.String} string 键
     */
    function getEasyBlock(string: java.lang.String): jdk.nashorn.internal.ir.Block;
    /**
     * 比较两个文件是否内容相同
     * @param {java.lang.String} path1 一个文件
     * @param {java.lang.String} path2 另一个文件
     */
    function isFileSame(path1: java.lang.String,path2: java.lang.String): boolean;
    /**
     * 此函数已废弃
     * @param {java.lang.String} name 此函数已废弃
     * @param {java.lang.String} description 此函数已废弃
     * @param {jdk.nashorn.api.scripting.ScriptObjectMirror} scriptObjectMirror 此函数已废弃
     * @param {java.lang.String} per 此函数已废弃
     */
    function newCommand(name: java.lang.String,description: java.lang.String,scriptObjectMirror: jdk.nashorn.api.scripting.ScriptObjectMirror,per: java.lang.String): void;
    /**
     * 此函数已废弃
     * @param {java.lang.String} name 此函数已废弃
     * @param {java.lang.String} description 此函数已废弃
     * @param {jdk.nashorn.api.scripting.ScriptObjectMirror} scriptObjectMirror 此函数已废弃
     */
    function newCommand(name: java.lang.String,description: java.lang.String,scriptObjectMirror: jdk.nashorn.api.scripting.ScriptObjectMirror): void;
    /**
     * 获取玩家是否为OP
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function PlayerIsOP(player: cn.nukkit.Player): boolean;
    /**
     * 强制中断当前函数运行
     * @param {java.lang.String} info 中断后发出的警告信息
     */
    function interrupt(info: java.lang.String): void;
    /**
     * 从指定URL下载文件并保存在本地
     * @param {java.lang.String} url 要从其下载文件的url
     * @param {java.lang.String} saveDir 保存此文件的目录路径
     * @param {java.lang.String} saveName 下载后保存的文件名
     */
    function downloadFromURL(url: java.lang.String,saveDir: java.lang.String,saveName: java.lang.String): void;
    /**
     * 
     * @param {java.lang.String} functionName 要在新线程运行的函数名称
     * @param {java.lang.Object[]} args 调用函数的参数
     */
    function lambda$runThread$1(functionName: FunV,args: java.lang.Object[]): void;
    /**
     * 通过BlackBE根据玩家名检测玩家是否为熊孩子
     * @param {java.lang.String} player 玩家名
     */
    function checkIsBearName(player: java.lang.String): java.lang.String;
    /**
     * 如路径不存在，创建指定路径的文件或文件夹及其所有未创建的父文件夹
     * @param {java.lang.String} path 绝对路径或相对路径
     */
    function doPathCreate(path: java.lang.String): void;
    /**
     * 字符串格式化
     * @param {java.lang.String} msg 格式化模板
     * @param {java.lang.Object[]} args 格式化参数run
     */
    function format(msg: java.lang.String,...args: java.lang.Object[]): java.lang.String;
    /**
     * 启动指定端口的HTTP服务器
     * @param {int} port 要启动的http服务器端口
     */
    function startHttpServer(port: int): void;
    /**
     * 创建配置文件对象
     * @param {java.io.File} file 配置文件对象对应的文件对象
     * @param {int} type 配置文件种类
     */
    function createConfig(file: java.io.File,type: int): cn.nukkit.utils.Config;
    /**
     * 从权限系统中移除指定权限节点
     * @param {java.lang.String} per 权限节点名称
     */
    function removePermission(per: java.lang.String): void;
    /**
     * 强制让玩家与服务器断开链接，就像玩家断网了一样
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function forceDisconnect(player: cn.nukkit.Player): void;
    /**
     * 取出简易存储坐标
     * @param {java.lang.String} string 键
     */
    function getEasyPosition(string: java.lang.String): cn.nukkit.level.Position;
    /**
     * 减少玩家金钱
     * @param {java.lang.String} player 玩家名
     * @param {double} money 金钱
     */
    function reduceMoney(player: java.lang.String,money: double): void;
    /**
     * 减少玩家金钱
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {double} money 金钱
     */
    function reduceMoney(player: cn.nukkit.Player,money: double): void;
    /**
     * 获取CPU核心数量
     */
    function getCPUCores(): int;
    /**
     * 取出简易存储布尔值
     * @param {java.lang.String} string 键
     */
    function getEasyBoolean(string: java.lang.String): boolean;
    /**
     * 获取总物理内存大小
     */
    function getMemoryTotalSizeMB(): double;
    /**
     * 取出简易存储玩家
     * @param {java.lang.String} string 键
     */
    function getEasyPlayer(string: java.lang.String): cn.nukkit.Player;
    /**
     * 通过BlackBE检测玩家是否为熊孩子
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function checkIsBear(player: cn.nukkit.Player): java.lang.String;
    /**
     * 移除指定的命令
     * @param {java.lang.String} name 命令主名
     */
    function removeCommand(name: java.lang.String): void;
    /**
     * 以UTF-8编码追加写入本地文本文件
     * @param {java.lang.String} path 文本文件路径
     * @param {java.lang.String} text 要追加写入的文本
     */
    function appendFile(path: java.lang.String,text: java.lang.String): void;
    /**
     * 字符串SHA1加密，返回密文
     * @param {java.lang.String} str 要加密的字符串
     */
    function SHA1Encryption(str: java.lang.String): java.lang.String;
    /**
     * 增加玩家金钱
     * @param {java.lang.String} player 玩家名
     * @param {double} money 金钱
     */
    function addMoney(player: java.lang.String,money: double): void;
    /**
     * 增加玩家金钱
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {double} money 金钱
     */
    function addMoney(player: cn.nukkit.Player,money: double): void;
    /**
     * 此函数已废弃
     * @param {int} id 此函数已废弃
     */
    function clearInterval(id: int): void;
    /**
     * 强制与NK主线程同步调用指定函数
     * @param {java.lang.String} functionName 要调用的函数
     * @param {java.lang.Object[]} args 调用函数的参数
     */
    function syncCallFunction(functionName: FunV,...args: java.lang.Object[]): java.lang.Object;
    /**
     * JSON字符串转YAML字符串
     * @param {java.lang.String} json 要转换的json字符串
     */
    function JSONtoYAML(json: java.lang.String): java.lang.String;
    /**
     * 此函数已废弃
     * @param {jdk.nashorn.api.scripting.ScriptObjectMirror} scriptObjectMirror 此函数已废弃
     * @param {int} delay 此函数已废弃
     * @param {java.lang.Object[]} args 此函数已废弃
     */
    function setInterval(scriptObjectMirror: jdk.nashorn.api.scripting.ScriptObjectMirror,delay: int,...args: java.lang.Object[]): int;
    /**
     * 创建一个新的HTTP服务器，返回是否创建成功，如创建成功则可以启动
     * @param {int} port 服务器端口
     */
    function createHttpServer(port: int): boolean;
    /**
     * 发起HTTP请求
     * @param {java.lang.String} method 方法(GET/POST)
     * @param {java.lang.String} url 请求地址
     * @param {java.lang.String} data 请求数据
     */
    function httpRequest(method: java.lang.String,url: java.lang.String,data: java.lang.String): java.lang.String;
    /**
     * 获取玩家金钱
     * @param {java.lang.String} player 玩家名
     */
    function getMoney(player: java.lang.String): double;
    /**
     * 获取玩家金钱
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getMoney(player: cn.nukkit.Player): double;
    /**
     * 以UTF-8编码写入本地文本文件
     * @param {java.lang.String} path 文本文件路径
     * @param {java.lang.String} text 要写入的内容
     */
    function writeFile(path: java.lang.String,text: java.lang.String): void;
    /**
     * 获取任务对象的任务id
     * @param {cn.nukkit.scheduler.TaskHandler} handler 任务对象
     */
    function getTaskId(handler: cn.nukkit.scheduler.TaskHandler): int;
    /**
     * 删除指定路径的文件或文件夹
     * @param {java.lang.String} path 绝对路径或相对路径
     */
    function deleteFile(path: java.lang.String): void;
    /**
     * 动态监听事件
     * @param {java.lang.String} fullEventName 要监听的事件的java类名
     * @param {java.lang.String} callbackFunction 事件回调函数
     * @param {java.lang.String} priority 事件优先级，可选NORMAL MONITOR LOWEST LOW HIGH HIGHEST
     */
    function customEventListener(fullEventName: java.lang.String,callbackFunction: Fun1<cn.nukkit.event.Event>,priority: java.lang.String): void;
    /**
     * 将指定函数立即在新线程上调用，并立即返回该函数运行的线程对象
     * @param {java.lang.String} functionName 要在新线程运行的函数名称
     * @param {java.lang.Object[]} args 调用函数的参数
     */
    function runThread(functionName: FunV,...args: java.lang.Object[]): java.lang.Thread;
    /**
     * 获取玩家游戏设备种类
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerDeviceModal(player: cn.nukkit.Player): java.lang.String;
    /**
     * 此函数不对外暴露
     * @param {java.lang.String} callback 
     * @param {int} delay 
     * @param {java.lang.Object[]} args 
     */
    function __setTimeoutInner(callback: java.lang.String,delay: int,...args: java.lang.Object[]): int;
    /**
     * 创建新的定时循环任务，返回任务对象
     * @param {java.lang.String} functionName 定时循环任务名
     * @param {int} delay 间隔(刻)
     * @param {java.lang.Object[]} args 回调函数调用参数
     */
    function createLoopTask(functionName: FunV,delay: int,...args: java.lang.Object[]): cn.nukkit.scheduler.TaskHandler;
    /**
     * 路径上的文件是否可写
     * @param {java.lang.String} path 绝对路径或相对路径，非文件夹
     */
    function isPathWritable(path: java.lang.String): boolean;
    /**
     * 取出简易存储字符串
     * @param {java.lang.String} string 键
     */
    function getEasyString(string: java.lang.String): java.lang.String;
    /**
     * 检验bn解释器版本，如果过低则停止插件加载并发出错误信息
     * @param {java.lang.String} minVersion 插件要求的最低版本的版本号
     * @param {java.lang.String} failMessage 版本太低时发出的错误提示信息
     */
    function requireMinVersion(minVersion: java.lang.String,failMessage: java.lang.String): void;
    /**
     * 格式化时间，返回格式化后的时间字符串
     * @param {int} seconds 秒数
     */
    function time(seconds: int): java.lang.String;
}
declare namespace cn.nukkit.level.particle{
     class HappyVillagerParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerSettingsRespondedEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        formID: int;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        closed: boolean;
        /**  */
        window: cn.nukkit.form.window.FormWindow;
        /**
         * 
         */
        public getFormID(): int;
        /**
         * 
         */
        public getWindow(): cn.nukkit.form.window.FormWindow;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public setCancelled(): void;
        /**
         * 
         */
        public getResponse(): cn.nukkit.form.response.FormResponse;
        /**
         * 
         */
        public wasClosed(): boolean;
    }
}
declare namespace cn.nukkit.level.generator.object.tree{
    abstract class HugeTreesGenerator extends cn.nukkit.level.generator.object.tree.TreeGenerator{
        /**  */
        extraRandomHeight: int;
        /**  */
        woodMetadata: cn.nukkit.block.Block;
        /**  */
        leavesMetadata: cn.nukkit.block.Block;
        /**  */
        baseHeight: int;
        /**
         * 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         */
        protected getHeight(rand: cn.nukkit.math.NukkitRandom): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} layerCenter 
         * @param {int} width 
         */
        protected growLeavesLayer(worldIn: cn.nukkit.level.ChunkManager,layerCenter: cn.nukkit.math.Vector3,width: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} layerCenter 
         * @param {int} width 
         */
        protected growLeavesLayerStrict(worldIn: cn.nukkit.level.ChunkManager,layerCenter: cn.nukkit.math.Vector3,width: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {cn.nukkit.math.Vector3} treePos 
         * @param {int} p_175929_4_ 
         */
        protected ensureGrowable(worldIn: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,treePos: cn.nukkit.math.Vector3,p_175929_4_: int): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         */
        private ensureDirtsUnderneath(pos: cn.nukkit.math.Vector3,worldIn: cn.nukkit.level.ChunkManager): boolean;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} leavesPos 
         * @param {int} height 
         */
        private isSpaceAt(worldIn: cn.nukkit.level.ChunkManager,leavesPos: cn.nukkit.math.Vector3,height: int): boolean;
    }
}
declare namespace cn.nukkit.plugin{
     class MethodEventExecutor extends java.lang.Object{
        /**  */
        method: java.lang.reflect.Method;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public getMethod(): java.lang.reflect.Method;
        /**
         * 
         * @param {cn.nukkit.event.Listener} listener 
         * @param {cn.nukkit.event.Event} event 
         */
        public execute(listener: cn.nukkit.event.Listener,event: cn.nukkit.event.Event): void;
    }
}
declare namespace cn.nukkit.event.block{
     class DoorToggleEvent extends cn.nukkit.event.block.BlockUpdateEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public setPlayer(player: cn.nukkit.Player): void;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentKnockback extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.event.vehicle{
     class VehicleDestroyEvent extends cn.nukkit.event.vehicle.VehicleEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorGroundFire extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager,x: int,z: int,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        protected placeBlock(x: int,y: int,z: int,id: int,chunk: cn.nukkit.level.format.FullChunk,random: cn.nukkit.math.NukkitRandom): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockEmerald extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryPickupArrowEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        arrow: cn.nukkit.entity.projectile.EntityArrow;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getArrow(): cn.nukkit.entity.projectile.EntityArrow;
    }
}
declare namespace org.java_websocket{
    abstract class WebSocketAdapter extends java.lang.Object{
        /**  */
        pingFrame: org.java_websocket.framing.PingFrame;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.ClientHandshake} arg1 
         */
        public onWebsocketHandshakeSentAsClient(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.ClientHandshake): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.handshake.ClientHandshake} arg1 
         * @param {org.java_websocket.handshake.ServerHandshake} arg2 
         */
        public onWebsocketHandshakeReceivedAsClient(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.handshake.ClientHandshake,arg2: org.java_websocket.handshake.ServerHandshake): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         */
        public onPreparePing(arg0: org.java_websocket.WebSocket): org.java_websocket.framing.PingFrame;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.framing.Framedata} arg1 
         */
        public onWebsocketPong(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.framing.Framedata): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.drafts.Draft} arg1 
         * @param {org.java_websocket.handshake.ClientHandshake} arg2 
         */
        public onWebsocketHandshakeReceivedAsServer(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.drafts.Draft,arg2: org.java_websocket.handshake.ClientHandshake): org.java_websocket.handshake.ServerHandshakeBuilder;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {org.java_websocket.framing.Framedata} arg1 
         */
        public onWebsocketPing(arg0: org.java_websocket.WebSocket,arg1: org.java_websocket.framing.Framedata): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemBootsIron extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace com.blocklynukkit.loader.other.data{
     class MemoryStorage extends java.util.concurrent.ConcurrentHashMap{
        /**
         * 移除键值对
         * @param {java.lang.Object} key 键
         */
        public removeItem(key: java.lang.Object): void;
        /**
         * 获取键值对
         * @param {java.lang.Object} key 键
         */
        public getItem(key: java.lang.Object): java.lang.Object;
        /**
         * 获取所有键
         */
        public getKeys(): java.lang.Object[];
        /**
         * 设置键值对
         * @param {java.lang.Object} key 键
         * @param {java.lang.Object} item 值
         */
        public setItem(key: java.lang.Object,item: java.lang.Object): void;
    }
}
declare namespace cn.nukkit.level.format{
    abstract class FullChunk extends java.lang.Object{
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockExtraData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         */
        public abstract setX(x: int): void;
        /**
         * 
         */
        public abstract getIndex(): long;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public abstract setBlock(x: int,y: int,z: int,blockId: int,meta: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} blockId 
         */
        public abstract setBlock(x: int,y: int,z: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public abstract setBlockLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public abstract recalculateHeightMapColumn(chunkX: int,chunkZ: int): int;
        /**
         * 
         */
        public abstract getBlockEntities(): java.util.Map;
        /**
         * 
         */
        public abstract isLoaded(): boolean;
        /**
         * 
         * @param {int} z 
         */
        public abstract setZ(z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,fullId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public setFullBlockId(x: int,y: int,z: int,layer: int,fullId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public setPosition(x: int,z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract isBlockedByBorder(x: int,z: int): boolean;
        /**
         * 
         */
        public abstract hasChanged(): boolean;
        /**
         * 
         */
        public abstract setGenerated(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public abstract setGenerated(value: boolean): void;
        /**
         * 
         * @param {boolean} save 
         * @param {boolean} safe 
         */
        public abstract unload(save: boolean,safe: boolean): boolean;
        /**
         * 
         */
        public abstract unload(): boolean;
        /**
         * 
         * @param {boolean} save 
         */
        public abstract unload(save: boolean): boolean;
        /**
         * 
         */
        public abstract toFastBinary(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract findBorders(x: int,z: int): java.util.List;
        /**
         * 
         */
        public abstract getProvider(): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         */
        public abstract getBiomeIdArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.biome.Biome} biome 
         */
        public setBiome(x: int,z: int,biome: cn.nukkit.level.biome.Biome): void;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} blockEntity 
         */
        public abstract removeBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getTile(x: int,y: int,z: int): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public abstract isLightPopulated(): boolean;
        /**
         * 
         */
        public abstract initChunk(): void;
        /**
         * 
         */
        public abstract populateSkyLight(): void;
        /**
         * 
         */
        public abstract toBinary(): byte[];
        /**
         * 
         * @param {boolean} value 
         */
        public abstract setPopulated(value: boolean): void;
        /**
         * 
         */
        public abstract setPopulated(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public abstract setBlockData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public abstract setBlockData(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public abstract addEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public abstract setBlockId(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public abstract setBlockId(x: int,y: int,z: int,id: int): void;
        /**
         * 
         */
        public abstract getEntities(): java.util.Map;
        /**
         * 
         * @param {boolean} changed 
         */
        public abstract setChanged(changed: boolean): void;
        /**
         * 
         */
        public abstract setChanged(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockState(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {byte} biomeId 
         */
        public abstract setBiomeId(x: int,z: int,biomeId: byte): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {int} biomeId 
         */
        public setBiomeId(x: int,z: int,biomeId: int): void;
        /**
         * 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         */
        public abstract setProvider(provider: cn.nukkit.level.format.LevelProvider): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockData(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public abstract setBlockStateAtLayer(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract getBiomeId(x: int,z: int): int;
        /**
         * 
         */
        public abstract setLightPopulated(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public abstract setLightPopulated(value: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract getHeightMap(x: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} cache 
         */
        public abstract getHighestBlockAt(x: int,z: int,cache: boolean): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public abstract getHighestBlockAt(x: int,z: int): int;
        /**
         * 
         */
        public abstract isGenerated(): boolean;
        /**
         * 
         * @param {boolean} generate 
         */
        public abstract load(generate: boolean): boolean;
        /**
         * 
         */
        public abstract load(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getFullBlock(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public abstract getBlockId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract getBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         */
        public abstract recalculateHeightMap(): void;
        /**
         * 
         */
        public abstract getBlockLightArray(): byte[];
        /**
         * 
         */
        public abstract isPopulated(): boolean;
        /**
         * 
         */
        public abstract getHeightMapArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockRuntimeId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockRuntimeId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} blockEntity 
         */
        public abstract addBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.block.Block} block 
         */
        public abstract getAndSetBlock(x: int,y: int,z: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         */
        public abstract getAndSetBlock(x: int,y: int,z: int,layer: int,block: cn.nukkit.block.Block): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockState(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public abstract removeEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public abstract getBlockExtraDataArray(): java.util.Map;
        /**
         * 
         */
        public abstract getX(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public abstract setBlockSkyLight(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public getAndSetBlockState(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public abstract getAndSetBlockState(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public abstract getZ(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {int} value 
         */
        public abstract setHeightMap(x: int,z: int,value: int): void;
        /**
         * 
         */
        public abstract getBlockSkyLightArray(): byte[];
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public abstract setBlockExtraData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public abstract isBlockChangeAllowed(x: int,y: int,z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         */
        public abstract setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} blockId 
         * @param {int} meta 
         */
        public abstract setBlockAtLayer(x: int,y: int,z: int,layer: int,blockId: int,meta: int): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockFarmland extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        MOISTURIZED_AMOUNT: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getMaxY(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemRabbitCooked extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.block{
     class BlockCauldron extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        LIQUID: cn.nukkit.blockproperty.ArrayBlockProperty;
        /**  */
        FILL_LEVEL: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightFilter(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getFillLevel(): int;
        /**
         * 
         * @param {int} fillLevel 
         */
        public setFillLevel(fillLevel: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public isEmpty(): boolean;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        private consumePotion(item: cn.nukkit.item.Item,player: cn.nukkit.Player): void;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} oldBucket 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} newBucket 
         */
        protected replaceBucket(oldBucket: cn.nukkit.item.Item,player: cn.nukkit.Player,newBucket: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityCauldron} cauldron 
         */
        public clearWithFizz(cauldron: cn.nukkit.blockentity.BlockEntityCauldron): void;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public isFull(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockHopper extends cn.nukkit.block.BlockTransparentMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getBlockEntityClass(): java.lang.Class;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBlockEntityType(): java.lang.String;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public hasComparatorInputOverride(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         * @param {boolean} enabled 
         */
        public setEnabled(enabled: boolean): void;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getComparatorInputOverride(): int;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public isEnabled(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.command.defaults{
     class PardonCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.level{
     class GlobalBlockPalette extends java.lang.Object{
        /**  */
        BLOCK_PALETTE: byte[];
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         * @param {int} id 
         * @param {int} meta 
         */
        public static getOrCreateRuntimeId(id: int,meta: int): int;
        /**
         * 
         * @param {int} legacyId 
         */
        public static getOrCreateRuntimeId(legacyId: int): int;
        /**
         * 
         * @param {int} blockId 
         */
        public static getName(blockId: int): java.lang.String;
    }
}
declare namespace cn.nukkit.plugin.service{
     class ServicePriority extends java.lang.Enum{
        /**  */
        LOWEST: cn.nukkit.plugin.service.ServicePriority;
        /**  */
        LOWER: cn.nukkit.plugin.service.ServicePriority;
        /**  */
        HIGHEST: cn.nukkit.plugin.service.ServicePriority;
        /**  */
        HIGHER: cn.nukkit.plugin.service.ServicePriority;
        /**  */
        NORMAL: cn.nukkit.plugin.service.ServicePriority;
        /**  */
        $VALUES: cn.nukkit.plugin.service.ServicePriority[];
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.plugin.service.ServicePriority;
        /**
         * 
         */
        public static values(): cn.nukkit.plugin.service.ServicePriority[];
    }
}
declare namespace cn.nukkit.block{
     class BlockDoorWood extends cn.nukkit.block.BlockDoor{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.block{
     class BlockNetherWart extends cn.nukkit.block.BlockFlowable{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        AGE: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityDamageEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        cause: cn.nukkit.event.entity.EntityDamageEvent.DamageCause;
        /**  */
        modifiers: java.util.Map;
        /**  */
        originals: java.util.Map;
        /**  */
        sideEffects: cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**  */
        attackCooldown: int;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent.DamageModifier} type 
         */
        public getDamage(type: cn.nukkit.event.entity.EntityDamageEvent.DamageModifier): float;
        /**
         * 
         */
        public getDamage(): float;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {int} x$0 
         */
        private static lambda$addSideEffects$2(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent.DamageModifier} type 
         */
        public isApplicable(type: cn.nukkit.event.entity.EntityDamageEvent.DamageModifier): boolean;
        /**
         * 
         */
        public canBeReducedByArmor(): boolean;
        /**
         * 
         * @param {int} x$0 
         */
        private static lambda$getSideEffects$0(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         * @param {float} damage 
         * @param {cn.nukkit.event.entity.EntityDamageEvent.DamageModifier} type 
         */
        public setDamage(damage: float,type: cn.nukkit.event.entity.EntityDamageEvent.DamageModifier): void;
        /**
         * 
         * @param {float} damage 
         */
        public setDamage(damage: float): void;
        /**
         * 
         */
        public getFinalDamage(): float;
        /**
         * 
         */
        public getCause(): cn.nukkit.event.entity.EntityDamageEvent.DamageCause;
        /**
         * 
         * @param {float} baseDamage 
         */
        private static createDamageModifierMap(baseDamage: float): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.sideeffect.SideEffect[]} sideEffects 
         */
        public  addSideEffects(...sideEffects: cn.nukkit.item.enchantment.sideeffect.SideEffect[]): void;
        /**
         * 
         * @param {java.util.Collection} sideEffects 
         */
        public addSideEffects(sideEffects: java.util.Collection): void;
        /**
         * 
         * @param {int} x$0 
         */
        private static lambda$setSideEffects$1(x$0: int): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         */
        public getSideEffects(): cn.nukkit.item.enchantment.sideeffect.SideEffect[];
        /**
         * 
         * @param {java.util.Collection} sideEffects 
         */
        public setSideEffects(sideEffects: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.sideeffect.SideEffect[]} sideEffects 
         */
        public  setSideEffects(...sideEffects: cn.nukkit.item.enchantment.sideeffect.SideEffect[]): void;
        /**
         * 
         */
        public getAttackCooldown(): int;
        /**
         * 
         * @param {int} attackCooldown 
         */
        public setAttackCooldown(attackCooldown: int): void;
        /**
         * 
         */
        public getOriginalDamage(): float;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent.DamageModifier} type 
         */
        public getOriginalDamage(type: cn.nukkit.event.entity.EntityDamageEvent.DamageModifier): float;
    }
}
declare namespace cn.nukkit.level.particle{
     class RedstoneParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.level.biome.impl.jungle{
     class JungleMBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.util{
     class BitArrayVersion extends java.lang.Enum{
        /**  */
        V6: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        next: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        V8: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        bits: byte;
        /**  */
        maxEntryValue: int;
        /**  */
        entriesPerWord: byte;
        /**  */
        V16: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        V1: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        V2: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        V3: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        V4: cn.nukkit.level.util.BitArrayVersion;
        /**  */
        $VALUES: cn.nukkit.level.util.BitArrayVersion[];
        /**  */
        V5: cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         */
        public next(): cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         * @param {int} size 
         */
        public getWordsForSize(size: int): int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static valueOf(name: java.lang.String): cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         * @param {int} version 
         * @param {boolean} read 
         */
        public static get(version: int,read: boolean): cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         */
        public static values(): cn.nukkit.level.util.BitArrayVersion[];
        /**
         * 
         * @param {int} size 
         * @param {int[]} words 
         */
        public createPalette(size: int,words: int[]): cn.nukkit.level.util.BitArray;
        /**
         * 
         * @param {int} size 
         */
        public createPalette(size: int): cn.nukkit.level.util.BitArray;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public getMaxEntryValue(): int;
    }
}
declare namespace cn.nukkit.command.defaults{
     class TimingsCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ClientboundMapItemDataPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        image: java.awt.image.BufferedImage;
        /**  */
        DECORATIONS_UPDATE: int;
        /**  */
        ENTITIES_UPDATE: int;
        /**  */
        update: int;
        /**  */
        scale: byte;
        /**  */
        colors: int[];
        /**  */
        offsetX: int;
        /**  */
        offsetZ: int;
        /**  */
        dimensionId: byte;
        /**  */
        decorators: cn.nukkit.network.protocol.ClientboundMapItemDataPacket.MapDecorator[];
        /**  */
        isLocked: boolean;
        /**  */
        width: int;
        /**  */
        TEXTURE_UPDATE: int;
        /**  */
        mapId: long;
        /**  */
        eids: int[];
        /**  */
        height: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.generator.noise.nukkit.f{
     class PerlinF extends cn.nukkit.level.generator.noise.nukkit.f.NoiseF{
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         */
        public getNoise2D(x: float,y: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public getNoise3D(x: float,y: float,z: float): float;
    }
}
declare namespace cn.nukkit.event.level{
     class LevelSaveEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.block{
     class BlockIce extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onBreak(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getFrictionFactor(): double;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getLightFilter(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockSpreadEvent extends cn.nukkit.event.block.BlockFormEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        source: cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSource(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneTorchUnlit extends cn.nukkit.block.BlockTorch{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        private checkState(): boolean;
        /**
         * 
         */
        protected isPoweredFromSide(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         */
        public tickRate(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.entity.passive{
    abstract class EntityNPC extends java.lang.Object{
    }
}
declare namespace cn.nukkit.math{
     class NukkitRandom extends java.lang.Object{
        /**  */
        seed: long;
        /**
         * 
         */
        public nextFloat(): float;
        /**
         * 
         */
        public nextSignedDouble(): double;
        /**
         * 
         */
        public nextSignedFloat(): float;
        /**
         * 
         * @param {int} start 
         * @param {int} end 
         */
        public nextRange(start: int,end: int): int;
        /**
         * 
         */
        public nextRange(): int;
        /**
         * 
         * @param {int} start 
         */
        public nextRange(start: int): int;
        /**
         * 
         */
        public nextInt(): int;
        /**
         * 
         */
        public nextBoolean(): boolean;
        /**
         * 
         * @param {long} seeds 
         */
        public setSeed(seeds: long): void;
        /**
         * 
         * @param {int} bound 
         */
        public nextBoundedInt(bound: int): int;
        /**
         * 
         */
        public nextDouble(): double;
        /**
         * 
         */
        public nextSignedInt(): int;
    }
}
declare namespace cn.nukkit.command.defaults{
     class TeleportCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class VideoStreamConnectPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        address: java.lang.String;
        /**  */
        NETWORK_ID: byte;
        /**  */
        screenshotFrequency: float;
        /**  */
        ACTION_OPEN: byte;
        /**  */
        action: byte;
        /**  */
        ACTION_CLOSE: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityMinecartEmpty extends cn.nukkit.entity.item.EntityMinecartAbstract{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public isRideable(): boolean;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getType(): cn.nukkit.utils.MinecartType;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {boolean} flag 
         */
        protected activate(x: int,y: int,z: int,flag: boolean): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        public getInteractButtonText(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class DoubleTag extends cn.nukkit.nbt.tag.NumberTag{
        /**  */
        data: double;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         * @param {java.lang.Double} data 
         */
        public setData(data: java.lang.Double): void;
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public  setData(data: java.lang.Number): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): java.lang.Double;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public  getData(): java.lang.Number;
        /**
         * 
         */
        public getData(): java.lang.Double;
    }
}
declare namespace cn.nukkit.event.block{
     class LeavesDecayEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.item{
     class ItemPaper extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.command.defaults{
     class SeedCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.positiontracking{
    abstract class NamedPosition extends cn.nukkit.math.Vector3{
        /**
         * 
         */
        public clone(): cn.nukkit.positiontracking.NamedPosition;
        /**
         * 
         */
        public  clone(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public abstract getLevelName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.positiontracking.NamedPosition} position 
         */
        public matchesNamedPosition(position: cn.nukkit.positiontracking.NamedPosition): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.swamp{
     class SwampBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.inventory{
    abstract class Inventory extends java.lang.Object{
        /**  */
        MAX_STACK: int;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} slots 
         */
        public abstract  removeItem(...slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[];
        /**
         * 
         */
        public abstract getMaxStackSize(): int;
        /**
         * 
         */
        public abstract getName(): java.lang.String;
        /**
         * 
         * @param {int} size 
         */
        public abstract setMaxStackSize(size: int): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public abstract firstEmpty(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {int} index 
         */
        public abstract getItem(index: int): cn.nukkit.item.Item;
        /**
         * 
         */
        public abstract getViewers(): java.util.Set;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public abstract remove(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public abstract clearAll(): void;
        /**
         * 
         * @param {cn.nukkit.item.Item[]} slots 
         */
        public abstract  addItem(...slots: cn.nukkit.item.Item[]): cn.nukkit.item.Item[];
        /**
         * 
         */
        public abstract getTitle(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public abstract onOpen(who: cn.nukkit.Player): void;
        /**
         * 
         */
        public abstract getContents(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public abstract sendContents(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public abstract  sendContents(...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {java.util.Collection} players 
         */
        public abstract sendContents(players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public abstract close(who: cn.nukkit.Player): void;
        /**
         * 
         * @param {java.util.Map} items 
         */
        public abstract setContents(items: java.util.Map): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(index: int,item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} send 
         */
        public abstract setItem(index: int,item: cn.nukkit.item.Item,send: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.InventoryListener} listener 
         */
        public abstract addListener(listener: cn.nukkit.inventory.InventoryListener): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public abstract all(item: cn.nukkit.item.Item): java.util.Map;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.item.Item} before 
         * @param {boolean} send 
         */
        public abstract onSlotChange(index: int,before: cn.nukkit.item.Item,send: boolean): void;
        /**
         * 
         * @param {int} index 
         * @param {boolean} send 
         */
        public abstract clear(index: int,send: boolean): boolean;
        /**
         * 
         * @param {int} index 
         */
        public clear(index: int): boolean;
        /**
         * 
         */
        public abstract isEmpty(): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.InventoryListener} listener 
         */
        public abstract removeListener(listener: cn.nukkit.inventory.InventoryListener): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public abstract contains(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public abstract getSize(): int;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public abstract onClose(who: cn.nukkit.Player): void;
        /**
         * 
         */
        public abstract getType(): cn.nukkit.inventory.InventoryType;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public abstract canAddItem(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {int} slot 
         */
        public abstract decreaseCount(slot: int): void;
        /**
         * 
         */
        public abstract isFull(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.Player} player 
         */
        public abstract sendSlot(index: int,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.Player[]} players 
         */
        public abstract  sendSlot(index: int,...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {int} index 
         * @param {java.util.Collection} players 
         */
        public abstract sendSlot(index: int,players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {boolean} exact 
         */
        public abstract first(item: cn.nukkit.item.Item,exact: boolean): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public first(item: cn.nukkit.item.Item): int;
        /**
         * 
         * @param {cn.nukkit.Player} who 
         */
        public abstract open(who: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public abstract getHolder(): cn.nukkit.inventory.InventoryHolder;
    }
}
declare namespace cn.nukkit.level.particle{
     class BoneMealParticle extends cn.nukkit.level.particle.Particle{
        /**  */
        position: cn.nukkit.math.Vector3;
        /**
         * 
         */
        public encode(): cn.nukkit.network.protocol.DataPacket[];
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerToggleFlightEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        isFlying: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isFlying(): boolean;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerQuitEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        reason: java.lang.String;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        quitMessage: cn.nukkit.lang.TextContainer;
        /**  */
        autoSave: boolean;
        /**
         * 
         */
        public getQuitMessage(): cn.nukkit.lang.TextContainer;
        /**
         * 
         */
        public getReason(): java.lang.String;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getAutoSave(): boolean;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} quitMessage 
         */
        public setQuitMessage(quitMessage: cn.nukkit.lang.TextContainer): void;
        /**
         * 
         * @param {java.lang.String} quitMessage 
         */
        public setQuitMessage(quitMessage: java.lang.String): void;
        /**
         * 
         */
        public setAutoSave(): void;
        /**
         * 
         * @param {boolean} autoSave 
         */
        public setAutoSave(autoSave: boolean): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSaddle extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemMagmaCream extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.inventory.transaction{
     class InventoryTransaction extends java.lang.Object{
        /**  */
        hasExecuted: boolean;
        /**  */
        creationTime: long;
        /**  */
        inventories: java.util.Set;
        /**  */
        source: cn.nukkit.Player;
        /**  */
        actions: java.util.List;
        /**
         * 
         */
        protected callExecuteEvent(): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} source 
         * @param {java.util.List} actions 
         */
        protected init(source: cn.nukkit.Player,actions: java.util.List): void;
        /**
         * 
         */
        public getInventories(): java.util.Set;
        /**
         * 
         */
        public canExecute(): boolean;
        /**
         * 
         */
        protected sendInventories(): void;
        /**
         * 
         */
        public getActions(): java.util.Set;
        /**
         * 
         * @param {cn.nukkit.inventory.Inventory} inventory 
         */
        public addInventory(inventory: cn.nukkit.inventory.Inventory): void;
        /**
         * 
         * @param {java.util.List} needItems 
         * @param {java.util.List} haveItems 
         */
        protected matchItems(needItems: java.util.List,haveItems: java.util.List): boolean;
        /**
         * 
         */
        public execute(): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.transaction.action.InventoryAction} action 
         */
        public addAction(action: cn.nukkit.inventory.transaction.action.InventoryAction): void;
        /**
         * 
         */
        public hasExecuted(): boolean;
        /**
         * 
         */
        public getActionList(): java.util.List;
        /**
         * 
         */
        public getSource(): cn.nukkit.Player;
        /**
         * 
         */
        public getCreationTime(): long;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedMagenta extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.particle{
     class InkParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentDurability extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {int} level 
         * @param {java.util.Random} random 
         */
        public static negateDamage(item: cn.nukkit.item.Item,level: int,random: java.util.Random): boolean;
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreRedstoneGlowing extends cn.nukkit.block.BlockOreRedstone{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item.enchantment.bow{
     class EnchantmentBowPower extends cn.nukkit.item.enchantment.bow.EnchantmentBow{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemIngotGold extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.network.protocol{
     class CraftingDataPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        brewingEntries: java.util.List;
        /**  */
        CRAFTING_TAG_CARTOGRAPHY_TABLE: java.lang.String;
        /**  */
        entries: java.util.List;
        /**  */
        NETWORK_ID: byte;
        /**  */
        CRAFTING_TAG_STONECUTTER: java.lang.String;
        /**  */
        CRAFTING_TAG_FURNACE: java.lang.String;
        /**  */
        CRAFTING_TAG_SMOKER: java.lang.String;
        /**  */
        cleanRecipes: boolean;
        /**  */
        CRAFTING_TAG_CRAFTING_TABLE: java.lang.String;
        /**  */
        containerEntries: java.util.List;
        /**  */
        CRAFTING_TAG_CAMPFIRE: java.lang.String;
        /**  */
        CRAFTING_TAG_BLAST_FURNACE: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         * @param {cn.nukkit.inventory.CartographyRecipe} r 
         */
        private lambda$addCartographyRecipe$1(r: cn.nukkit.inventory.CartographyRecipe): void;
        /**
         * 
         * @param {cn.nukkit.inventory.CartographyRecipe} r 
         */
        private static lambda$addCartographyRecipe$0(r: cn.nukkit.inventory.CartographyRecipe): boolean;
        /**
         * 
         * @param {cn.nukkit.inventory.CampfireRecipe[]} recipe 
         */
        public  addCampfireRecipeRecipe(...recipe: cn.nukkit.inventory.CampfireRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.StonecutterRecipe[]} recipes 
         */
        public  addStonecutterRecipe(...recipes: cn.nukkit.inventory.StonecutterRecipe[]): void;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         * @param {cn.nukkit.inventory.ShapelessRecipe[]} recipe 
         */
        public  addShapelessRecipe(...recipe: cn.nukkit.inventory.ShapelessRecipe[]): void;
        /**
         * 
         */
        public decode(): void;
        /**
         * 
         */
        public clean(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         * @param {cn.nukkit.inventory.BlastFurnaceRecipe[]} recipe 
         */
        public  addBlastFurnaceRecipe(...recipe: cn.nukkit.inventory.BlastFurnaceRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.CartographyRecipe[]} recipe 
         */
        public  addCartographyRecipe(...recipe: cn.nukkit.inventory.CartographyRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.FurnaceRecipe[]} recipe 
         */
        public  addFurnaceRecipe(...recipe: cn.nukkit.inventory.FurnaceRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.MultiRecipe[]} recipe 
         */
        public  addMultiRecipe(...recipe: cn.nukkit.inventory.MultiRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.BrewingRecipe[]} recipe 
         */
        public  addBrewingRecipe(...recipe: cn.nukkit.inventory.BrewingRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.ContainerRecipe[]} recipe 
         */
        public  addContainerRecipe(...recipe: cn.nukkit.inventory.ContainerRecipe[]): void;
        /**
         * 
         * @param {cn.nukkit.inventory.ShapedRecipe[]} recipe 
         */
        public  addShapedRecipe(...recipe: cn.nukkit.inventory.ShapedRecipe[]): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.inventory.SmokerRecipe[]} recipe 
         */
        public  addSmokerRecipe(...recipe: cn.nukkit.inventory.SmokerRecipe[]): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class DefaultGamemodeCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedPink extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.plugin{
    abstract class PluginBase extends java.lang.Object{
        /**  */
        server: cn.nukkit.Server;
        /**  */
        file: java.io.File;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        loader: cn.nukkit.plugin.PluginLoader;
        /**  */
        isEnabled: boolean;
        /**  */
        configFile: java.io.File;
        /**  */
        logger: cn.nukkit.plugin.PluginLogger;
        /**  */
        initialized: boolean;
        /**  */
        description: cn.nukkit.plugin.PluginDescription;
        /**  */
        dataFolder: java.io.File;
        /**  */
        config: cn.nukkit.utils.Config;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public getResource(filename: java.lang.String): java.io.InputStream;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getPluginCommand(name: java.lang.String): cn.nukkit.command.PluginCommand;
        /**
         * 
         */
        public  isInitialized(): boolean;
        /**
         * 
         */
        public onEnable(): void;
        /**
         * 
         */
        public  getDataFolder(): java.io.File;
        /**
         * 
         */
        protected getFile(): java.io.File;
        /**
         * 
         */
        public  getDescription(): cn.nukkit.plugin.PluginDescription;
        /**
         * 
         */
        public onDisable(): void;
        /**
         * 
         */
        public reloadConfig(): void;
        /**
         * 
         */
        public  isDisabled(): boolean;
        /**
         * 
         */
        public  getFullName(): java.lang.String;
        /**
         * 
         */
        public getPluginLoader(): cn.nukkit.plugin.PluginLoader;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {cn.nukkit.plugin.PluginLoader} loader 
         * @param {cn.nukkit.Server} server 
         * @param {cn.nukkit.plugin.PluginDescription} description 
         * @param {java.io.File} dataFolder 
         * @param {java.io.File} file 
         */
        public  init(loader: cn.nukkit.plugin.PluginLoader,server: cn.nukkit.Server,description: cn.nukkit.plugin.PluginDescription,dataFolder: java.io.File,file: java.io.File): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public getCommand(name: java.lang.String): cn.nukkit.command.PluginIdentifiableCommand;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {cn.nukkit.command.Command} command 
         * @param {java.lang.String} label 
         * @param {java.lang.String[]} args 
         */
        public onCommand(sender: cn.nukkit.command.CommandSender,command: cn.nukkit.command.Command,label: java.lang.String,args: java.lang.String[]): boolean;
        /**
         * 
         */
        public getLogger(): cn.nukkit.plugin.PluginLogger;
        /**
         * 
         */
        public saveDefaultConfig(): void;
        /**
         * 
         */
        public getConfig(): cn.nukkit.utils.Config;
        /**
         * 
         */
        public saveConfig(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public  setEnabled(value: boolean): void;
        /**
         * 
         */
        public  setEnabled(): void;
        /**
         * 
         */
        public  isEnabled(): boolean;
        /**
         * 
         */
        public onLoad(): void;
        /**
         * 
         * @param {java.lang.String} filename 
         */
        public saveResource(filename: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} filename 
         * @param {boolean} replace 
         */
        public saveResource(filename: java.lang.String,replace: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} filename 
         * @param {java.lang.String} outputName 
         * @param {boolean} replace 
         */
        public saveResource(filename: java.lang.String,outputName: java.lang.String,replace: boolean): boolean;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityDespawnEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        entityType: int;
        /**
         * 
         */
        public isCreature(): boolean;
        /**
         * 
         */
        public getPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isVehicle(): boolean;
        /**
         * 
         */
        public isItem(): boolean;
        /**
         * 
         */
        public isHuman(): boolean;
        /**
         * 
         */
        public isProjectile(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockRailDetector extends cn.nukkit.block.BlockRail{
        /**
         * 
         */
        protected updateState(): void;
        /**
         * 
         * @param {boolean} active 
         */
        public setRailActive(active: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getWeakPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public getStrongPower(side: cn.nukkit.math.BlockFace): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public isPowerSource(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isActive(): boolean;
        /**
         * 
         */
        public isRailActive(): cn.nukkit.utils.OptionalBoolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorCaves extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        caveSystemPocketChance: int;
        /**  */
        checkAreaSize: int;
        /**  */
        caveMinAltitude: int;
        /**  */
        caveSystemPocketMaxSize: int;
        /**  */
        caveFrequency: int;
        /**  */
        random: java.util.Random;
        /**  */
        caveSystemPocketMinSize: int;
        /**  */
        evenCaveDistribution: boolean;
        /**  */
        caveRarity: int;
        /**  */
        caveMaxAltitude: int;
        /**  */
        individualCaveRarity: int;
        /**  */
        caveSystemFrequency: int;
        /**  */
        worldHeightCap: int;
        /**
         * 
         * @param {long} seed 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        protected generateLargeCaveNode(seed: long,chunk: cn.nukkit.level.format.FullChunk,x: double,y: double,z: double): void;
        /**
         * 
         * @param {long} seed 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {float} radius 
         * @param {float} angelOffset 
         * @param {float} angel 
         * @param {int} angle 
         * @param {int} maxAngle 
         * @param {double} scale 
         */
        protected generateCaveNode(seed: long,chunk: cn.nukkit.level.format.FullChunk,x: double,y: double,z: double,radius: float,angelOffset: float,angel: float,angle: int,maxAngle: int,scale: double): void;
        /**
         * 
         * @param {java.util.Random} random 
         * @param {int} min 
         * @param {int} max 
         */
        public static numberInRange(random: java.util.Random,min: int,max: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.FullChunk} generatingChunkBuffer 
         */
        protected generateChunk(chunkX: int,chunkZ: int,generatingChunkBuffer: cn.nukkit.level.format.FullChunk): void;
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace inventory{
    /**
     * 设置实体副手中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function setEntityItemInOffHand(entity: cn.nukkit.entity.Entity,item: cn.nukkit.item.Item): void;
    /**
     * 设置实体胸甲槽中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.item.Item} item 
     */
    function setEntityItemChestplate(entity: cn.nukkit.entity.Entity,item: cn.nukkit.item.Item): void;
    /**
     * 向物品栏添加物品，会直接操作输入的物品栏对象
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {cn.nukkit.item.Item} item 要添加的物品
     */
    function addItemToInv(inv: cn.nukkit.inventory.Inventory,item: cn.nukkit.item.Item): cn.nukkit.inventory.Inventory;
    /**
     * 获取实体靴子槽的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityBoots(entity: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
    /**
     * 设置实体头盔槽中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function setEntityItemHelmet(entity: cn.nukkit.entity.Entity,item: cn.nukkit.item.Item): void;
    /**
     * 获取玩家的背包物品栏，返回的新物品栏是玩家物品栏的拷贝而非玩家真实背包
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function getPlayerInv(player: cn.nukkit.Player): cn.nukkit.inventory.Inventory;
    /**
     * 检测物品是否在物品栏中
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {cn.nukkit.item.Item} item 要检测的物品
     */
    function containsItemInInv(inv: cn.nukkit.inventory.Inventory,item: cn.nukkit.item.Item): boolean;
    /**
     * 设置指定位置的方块的物品栏对象
     * @param {cn.nukkit.level.Position} pos 坐标
     * @param {cn.nukkit.inventory.Inventory} inv 要被设置到方块上的物品栏
     */
    function setBlockInv(pos: cn.nukkit.level.Position,inv: cn.nukkit.inventory.Inventory): void;
    /**
     * 获取物品栏中的所有物品
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     */
    function getItemsInInv(inv: cn.nukkit.inventory.Inventory): java.util.List;
    /**
     * 通过Map编辑物品栏的物品，会直接操作输入的物品栏对象
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {java.util.Map} invContent 内容Map<槽位:number,物品:cn.nukkit.item.Item>
     */
    function editInvByMap(inv: cn.nukkit.inventory.Inventory,invContent: java.util.Map): cn.nukkit.inventory.Inventory;
    /**
     * 将指定物品从物品栏移除，会直接操作输入的物品栏对象
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {cn.nukkit.item.Item} item 要移除的物品
     */
    function removeItemFromInv(inv: cn.nukkit.inventory.Inventory,item: cn.nukkit.item.Item): cn.nukkit.inventory.Inventory;
    /**
     * 编辑物品栏指定槽位上的物品，会直接操作输入的物品栏对象
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {int} slot 槽位
     * @param {cn.nukkit.item.Item} item 要设置的物品
     */
    function editInvBySlot(inv: cn.nukkit.inventory.Inventory,slot: int,item: cn.nukkit.item.Item): cn.nukkit.inventory.Inventory;
    /**
     * 设置玩家的物品栏
     * @param {cn.nukkit.Player} player 玩家对象
     * @param {cn.nukkit.inventory.Inventory} inv 新的物品栏
     */
    function setPlayerInv(player: cn.nukkit.Player,inv: cn.nukkit.inventory.Inventory): void;
    /**
     * 新建一个箱子物品栏
     * @param {boolean} isDoubleChest 是否为大箱子
     * @param {cn.nukkit.item.Item[]} item 包含的物品，需要使用`Java.to`函数转换
     * @param {java.lang.String} name 物品栏标题
     */
    function addInv(isDoubleChest: boolean,item: cn.nukkit.item.Item[],name: java.lang.String): com.nukkitx.fakeinventories.inventory.ChestFakeInventory;
    /**
     * 获取指定位置上的方块所包含的物品栏对象，返回值是指定位置方块的物品栏的拷贝
     * @param {cn.nukkit.level.Position} pos 坐标
     */
    function getBlockInv(pos: cn.nukkit.level.Position): cn.nukkit.inventory.Inventory;
    /**
     * 设置实体靴子槽中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function setEntityItemBoots(entity: cn.nukkit.entity.Entity,item: cn.nukkit.item.Item): void;
    /**
     * 向玩家展示虚拟物品栏
     * @param {cn.nukkit.Player} player 要向展示的玩家
     * @param {com.nukkitx.fakeinventories.inventory.FakeInventory} inv 展示的虚拟物品栏
     */
    function showFakeInv(player: cn.nukkit.Player,inv: com.nukkitx.fakeinventories.inventory.FakeInventory): void;
    /**
     * 新建一个漏斗物品栏
     * @param {cn.nukkit.item.Item[]} item 包含的物品，需要使用`Java.to`函数转换
     * @param {java.lang.String} name 物品栏标题
     */
    function addHopperInv(item: cn.nukkit.item.Item[],name: java.lang.String): com.blocklynukkit.loader.other.inventoty.HopperFakeInventory;
    /**
     * 设置实体护腿槽中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function setEntityItemLeggings(entity: cn.nukkit.entity.Entity,item: cn.nukkit.item.Item): void;
    /**
     * 编辑物品栏中的物品，会直接操作输入的物品栏对象
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {cn.nukkit.item.Item[]} item 所有的物品数组，需要通过`Java.to`函数转换
     */
    function editInv(inv: cn.nukkit.inventory.Inventory,item: cn.nukkit.item.Item[]): cn.nukkit.inventory.Inventory;
    /**
     * 获取实体副手中的物品
     * @param {cn.nukkit.entity.Entity} entity 
     */
    function getEntityItemInOffHand(entity: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
    /**
     * 获取实体手中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityItemInHand(entity: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
    /**
     * 获取实体胸甲槽的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityChestplate(entity: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
    /**
     * 获取物品栏指定槽位上的物品
     * @param {cn.nukkit.inventory.Inventory} inv 物品栏对象
     * @param {int} slot 槽位号
     */
    function getInventorySlot(inv: cn.nukkit.inventory.Inventory,slot: int): cn.nukkit.item.Item;
    /**
     * 获取实体头盔槽的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityHelmet(entity: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 获取实体护腿槽的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     */
    function getEntityLeggings(entity: cn.nukkit.entity.Entity): cn.nukkit.item.Item;
    /**
     * 设置实体手中的物品
     * @param {cn.nukkit.entity.Entity} entity 实体对象
     * @param {cn.nukkit.item.Item} item 物品对象
     */
    function setEntityItemInHand(entity: cn.nukkit.entity.Entity,item: cn.nukkit.item.Item): void;
}
declare namespace cn.nukkit.utils{
     class ConfigSection extends java.util.LinkedHashMap{
        /**
         * 
         * @param {java.util.Set} keys 
         * @param {boolean} child 
         * @param {java.lang.String} key 
         * @param {java.lang.Object} value 
         */
        private static lambda$getKeys$2(keys: java.util.Set,child: boolean,key: java.lang.String,value: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getLongList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getBooleanList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.util.List} list 
         */
        private parseList(list: java.util.List): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {double} defaultValue 
         */
        public getDouble(key: java.lang.String,defaultValue: double): double;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getDouble(key: java.lang.String): double;
        /**
         * 
         * @param {java.util.Set} keys 
         * @param {java.lang.String} key 
         * @param {java.lang.String} childKey 
         */
        private static lambda$null$1(keys: java.util.Set,key: java.lang.String,childKey: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getMapList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getShortList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isList(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public remove(key: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isBoolean(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getSection(key: java.lang.String): cn.nukkit.utils.ConfigSection;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.util.List} defaultList 
         */
        public getList(key: java.lang.String,defaultList: java.util.List): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.Object} defaultValue 
         */
        public get(key: java.lang.String,defaultValue: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public get(key: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isInt(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isString(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getBoolean(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {boolean} defaultValue 
         */
        public getBoolean(key: java.lang.String,defaultValue: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getCharacterList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.Object} value 
         */
        public set(key: java.lang.String,value: java.lang.Object): void;
        /**
         * 
         */
        public getAll(): cn.nukkit.utils.ConfigSection;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isLong(key: java.lang.String): boolean;
        /**
         * 
         */
        public getKeys(): java.util.Set;
        /**
         * 
         * @param {boolean} child 
         */
        public getKeys(child: boolean): java.util.Set;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {java.lang.String} defaultValue 
         */
        public getString(key: java.lang.String,defaultValue: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getString(key: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getDoubleList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {long} defaultValue 
         */
        public getLong(key: java.lang.String,defaultValue: long): long;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getLong(key: java.lang.String): long;
        /**
         * 
         */
        public getAllMap(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {int} defaultValue 
         */
        public getInt(key: java.lang.String,defaultValue: int): int;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getInt(key: java.lang.String): int;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getFloatList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getIntegerList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getByteList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         * @param {boolean} ignoreCase 
         */
        public exists(key: java.lang.String,ignoreCase: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public exists(key: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.utils.ConfigSection} sections 
         * @param {java.lang.String} key1 
         * @param {java.lang.Object} value 
         */
        private static lambda$getSections$0(sections: cn.nukkit.utils.ConfigSection,key1: java.lang.String,value: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isSection(key: java.lang.String): boolean;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getStringList(key: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public getSections(key: java.lang.String): cn.nukkit.utils.ConfigSection;
        /**
         * 
         */
        public getSections(): cn.nukkit.utils.ConfigSection;
        /**
         * 
         * @param {java.lang.String} key 
         */
        public isDouble(key: java.lang.String): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemAxeGold extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityDolphin extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockSapling extends cn.nukkit.block.BlockFlowable{
        /**  */
        SPRUCE: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        BIRCH: int;
        /**  */
        SAPLING_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        JUNGLE: int;
        /**  */
        ACACIA: int;
        /**  */
        OAK: int;
        /**  */
        AGED: cn.nukkit.blockproperty.BooleanBlockProperty;
        /**  */
        BIRCH_TALL: int;
        /**  */
        DARK_OAK: int;
        /**
         * 
         * @param {boolean} aged 
         */
        public setAged(aged: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        private grow(): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        private findSaplings(type: cn.nukkit.blockproperty.value.WoodType): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} woodType 
         */
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        public canBeActivated(): boolean;
        /**
         * 
         */
        public isAged(): boolean;
        /**
         * 
         */
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        public isSameType(pos: cn.nukkit.math.Vector3,type: cn.nukkit.blockproperty.value.WoodType): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} type 
         */
        public isSameType(pos: cn.nukkit.math.Vector3,type: int): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.event.level{
     class ChunkUnloadEvent extends cn.nukkit.event.level.ChunkEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.entity.data{
     class ShortEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        data: int;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Integer} data 
         */
        public setData(data: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): java.lang.Integer;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityBlockChangeEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        from: cn.nukkit.block.Block;
        /**  */
        to: cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getTo(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getFrom(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.level.biome.impl.river{
     class FrozenRiverBiome extends cn.nukkit.level.biome.impl.river.RiverBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        public isFreezing(): boolean;
    }
}
declare namespace cn.nukkit.blockentity{
    abstract class BlockEntitySpawnable extends cn.nukkit.blockentity.BlockEntity{
        /**
         * 
         */
        public spawnToAll(): void;
        /**
         * 
         */
        protected initBlockEntity(): void;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         */
        public getSpawnPacket(nbt: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.network.protocol.BlockEntityDataPacket;
        /**
         * 
         */
        public getSpawnPacket(): cn.nukkit.network.protocol.BlockEntityDataPacket;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {cn.nukkit.Player} player 
         */
        public updateCompoundTag(nbt: cn.nukkit.nbt.tag.CompoundTag,player: cn.nukkit.Player): boolean;
    }
}
declare namespace cn.nukkit.event.level{
     class LevelUnloadEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.event.player{
    abstract class PlayerMessageEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        message: java.lang.String;
        /**
         * 
         */
        public getMessage(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public setMessage(message: java.lang.String): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class BlockEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        case1: int;
        /**  */
        case2: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: int;
        /**  */
        y: int;
        /**  */
        z: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsSandstone extends cn.nukkit.block.BlockStairs{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordWait extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.iceplains{
     class IcePlainsBiome extends cn.nukkit.level.biome.type.SnowyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.metadata{
     class BlockMetadataStore extends cn.nukkit.metadata.MetadataStore{
        /**  */
        owningLevel: cn.nukkit.level.Level;
        /**
         * 
         * @param {java.lang.Object} block 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public setMetadata(block: java.lang.Object,metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         * @param {java.lang.Object} block 
         * @param {java.lang.String} metadataKey 
         */
        public getMetadata(block: java.lang.Object,metadataKey: java.lang.String): java.util.List;
        /**
         * 
         * @param {java.lang.Object} block 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public removeMetadata(block: java.lang.Object,metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {java.lang.Object} block 
         * @param {java.lang.String} metadataKey 
         */
        public hasMetadata(block: java.lang.Object,metadataKey: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.metadata.Metadatable} block 
         * @param {java.lang.String} metadataKey 
         */
        protected disambiguate(block: cn.nukkit.metadata.Metadatable,metadataKey: java.lang.String): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorAcacia extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.entity{
     class Attribute extends java.lang.Object{
        /**  */
        MAX_HEALTH: int;
        /**  */
        shouldSend: boolean;
        /**  */
        EMPTY_ARRAY: cn.nukkit.entity.Attribute[];
        /**  */
        EXPERIENCE_LEVEL: int;
        /**  */
        maxValue: float;
        /**  */
        defaultValue: float;
        /**  */
        MOVEMENT_SPEED: int;
        /**  */
        FOLLOW_RANGE: int;
        /**  */
        LUCK: int;
        /**  */
        minValue: float;
        /**  */
        MAX_HUNGER: int;
        /**  */
        ATTACK_DAMAGE: int;
        /**  */
        name: java.lang.String;
        /**  */
        EXPERIENCE: int;
        /**  */
        attributes: java.util.Map;
        /**  */
        ABSORPTION: int;
        /**  */
        id: int;
        /**  */
        KNOCKBACK_RESISTANCE: int;
        /**  */
        SATURATION: int;
        /**  */
        EXHAUSTION: int;
        /**  */
        currentValue: float;
        /**  */
        FOOD: int;
        /**
         * 
         * @param {float} defaultValue 
         */
        public setDefaultValue(defaultValue: float): cn.nukkit.entity.Attribute;
        /**
         * 
         */
        public static init(): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getMaxValue(): float;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getDefaultValue(): float;
        /**
         * 
         */
        public getValue(): float;
        /**
         * 
         * @param {float} maxValue 
         */
        public setMaxValue(maxValue: float): cn.nukkit.entity.Attribute;
        /**
         * 
         */
        public getMinValue(): float;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getAttributeByName(name: java.lang.String): cn.nukkit.entity.Attribute;
        /**
         * 
         * @param {int} id 
         */
        public static getAttribute(id: int): cn.nukkit.entity.Attribute;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.String} name 
         * @param {float} minValue 
         * @param {float} maxValue 
         * @param {float} defaultValue 
         */
        public static addAttribute(id: int,name: java.lang.String,minValue: float,maxValue: float,defaultValue: float): cn.nukkit.entity.Attribute;
        /**
         * 
         * @param {int} id 
         * @param {java.lang.String} name 
         * @param {float} minValue 
         * @param {float} maxValue 
         * @param {float} defaultValue 
         * @param {boolean} shouldSend 
         */
        public static addAttribute(id: int,name: java.lang.String,minValue: float,maxValue: float,defaultValue: float,shouldSend: boolean): cn.nukkit.entity.Attribute;
        /**
         * 
         * @param {float} value 
         * @param {boolean} fit 
         */
        public setValue(value: float,fit: boolean): cn.nukkit.entity.Attribute;
        /**
         * 
         * @param {float} value 
         */
        public setValue(value: float): cn.nukkit.entity.Attribute;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.entity.Attribute;
        /**
         * 
         */
        public isSyncable(): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {float} minValue 
         */
        public setMinValue(minValue: float): cn.nukkit.entity.Attribute;
    }
}
declare namespace cn.nukkit.item{
     class ItemFeather extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item{
     class ItemFireCharge extends cn.nukkit.item.Item{
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemHelmetNetherite extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public isHelmet(): boolean;
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MoveEntityAbsolutePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        eid: long;
        /**  */
        onGround: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        teleport: boolean;
        /**  */
        x: double;
        /**  */
        headYaw: double;
        /**  */
        y: double;
        /**  */
        z: double;
        /**  */
        pitch: double;
        /**  */
        yaw: double;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityDrowned extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.biome.impl.savanna{
     class SavannaPlateauBiome extends cn.nukkit.level.biome.impl.savanna.SavannaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityEndCrystal extends cn.nukkit.entity.Entity{
        /**  */
        NETWORK_ID: int;
        /**  */
        detonated: boolean;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public explode(): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         * @param {boolean} value 
         */
        public setShowBase(value: boolean): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public showBase(): boolean;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemWheat extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.entity.projectile{
     class EntityArrow extends cn.nukkit.entity.projectile.EntityProjectile{
        /**  */
        PICKUP_ANY: int;
        /**  */
        PICKUP_NONE: int;
        /**  */
        NETWORK_ID: int;
        /**  */
        PICKUP_CREATIVE: int;
        /**  */
        pickupMode: int;
        /**  */
        DATA_SOURCE_ID: int;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public canBeMovedByCurrents(): boolean;
        /**
         * 
         */
        protected getBaseDamage(): double;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         */
        protected updateMotion(): void;
        /**
         * 
         */
        protected addHitEffect(): void;
        /**
         * 
         */
        public getPickupMode(): int;
        /**
         * 
         */
        public setCritical(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setCritical(value: boolean): void;
        /**
         * 
         */
        public getResultDamage(): int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        protected afterCollisionWithEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getDrag(): float;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public isCritical(): boolean;
        /**
         * 
         * @param {int} pickupMode 
         */
        public setPickupMode(pickupMode: int): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        public getGravity(): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemBrewingStand extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentLure extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemLeggingsDiamond extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isLeggings(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemChickenRaw extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.level.biome.impl.desert{
     class DesertMBiome extends cn.nukkit.level.biome.impl.desert.DesertBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerAsyncPreLoginEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        scheduledActions: java.util.List;
        /**  */
        loginResult: cn.nukkit.event.player.PlayerAsyncPreLoginEvent.LoginResult;
        /**  */
        chainData: cn.nukkit.utils.LoginChainData;
        /**  */
        address: java.lang.String;
        /**  */
        port: int;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        name: java.lang.String;
        /**  */
        skin: cn.nukkit.entity.data.Skin;
        /**  */
        uuid: java.util.UUID;
        /**  */
        kickMessage: java.lang.String;
        /**
         * 
         */
        public allow(): void;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getChainData(): cn.nukkit.utils.LoginChainData;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getXuid(): java.lang.String;
        /**
         * 
         * @param {java.util.function.Consumer} action 
         */
        public scheduleSyncAction(action: java.util.function.Consumer): void;
        /**
         * 
         */
        public getKickMessage(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.data.Skin} skin 
         */
        public setSkin(skin: cn.nukkit.entity.data.Skin): void;
        /**
         * 
         */
        public getPort(): int;
        /**
         * 
         * @param {java.lang.String} kickMessage 
         */
        public setKickMessage(kickMessage: java.lang.String): void;
        /**
         * 
         */
        public getSkin(): cn.nukkit.entity.data.Skin;
        /**
         * 
         */
        public getUuid(): java.util.UUID;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerAsyncPreLoginEvent.LoginResult} loginResult 
         */
        public setLoginResult(loginResult: cn.nukkit.event.player.PlayerAsyncPreLoginEvent.LoginResult): void;
        /**
         * 
         */
        public getAddress(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public disAllow(message: java.lang.String): void;
        /**
         * 
         */
        public getLoginResult(): cn.nukkit.event.player.PlayerAsyncPreLoginEvent.LoginResult;
        /**
         * 
         */
        public getScheduledActions(): java.util.List;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityMule extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.permission{
    abstract class DefaultPermissions extends java.lang.Object{
        /**  */
        ROOT: java.lang.String;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} perm 
         */
        public static registerPermission(perm: cn.nukkit.permission.Permission): cn.nukkit.permission.Permission;
        /**
         * 
         * @param {cn.nukkit.permission.Permission} perm 
         * @param {cn.nukkit.permission.Permission} parent 
         */
        public static registerPermission(perm: cn.nukkit.permission.Permission,parent: cn.nukkit.permission.Permission): cn.nukkit.permission.Permission;
        /**
         * 
         */
        public static registerCorePermissions(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemGunpowder extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockStairsBirch extends cn.nukkit.block.BlockStairsWood{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.form.element{
     class ElementLabel extends cn.nukkit.form.element.Element{
        /**  */
        text: java.lang.String;
        /**  */
        type: java.lang.String;
        /**
         * 
         */
        public getText(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} text 
         */
        public setText(text: java.lang.String): void;
    }
}
declare namespace cn.nukkit.level.generator.noise.vanilla.f{
     class NoiseGeneratorSimplexF extends java.lang.Object{
        /**  */
        p: int[];
        /**  */
        grad3: int[][];
        /**  */
        zo: float;
        /**  */
        yo: float;
        /**  */
        xo: float;
        /**  */
        SQRT_3: float;
        /**  */
        G2: float;
        /**  */
        F2: float;
        /**
         * 
         * @param {float[]} p_151606_1_ 
         * @param {float} p_151606_2_ 
         * @param {float} p_151606_4_ 
         * @param {int} p_151606_6_ 
         * @param {int} p_151606_7_ 
         * @param {float} p_151606_8_ 
         * @param {float} p_151606_10_ 
         * @param {float} p_151606_12_ 
         */
        public add(p_151606_1_: float[],p_151606_2_: float,p_151606_4_: float,p_151606_6_: int,p_151606_7_: int,p_151606_8_: float,p_151606_10_: float,p_151606_12_: float): void;
        /**
         * 
         * @param {float} p_151605_1_ 
         * @param {float} p_151605_3_ 
         */
        public getValue(p_151605_1_: float,p_151605_3_: float): float;
        /**
         * 
         * @param {float} value 
         */
        private static fastFloor(value: float): int;
        /**
         * 
         * @param {int[]} p_151604_0_ 
         * @param {float} p_151604_1_ 
         * @param {float} p_151604_3_ 
         */
        private static dot(p_151604_0_: int[],p_151604_1_: float,p_151604_3_: float): float;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityDamageable extends java.lang.Object{
    }
}
declare namespace cn.nukkit.entity.data{
     class LongEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        data: long;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {java.lang.Long} data 
         */
        public setData(data: java.lang.Long): void;
        /**
         * 
         * @param {java.lang.Object} data 
         */
        public  setData(data: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): java.lang.Long;
    }
}
declare namespace java.lang{
     class System extends java.lang.Object{
        /**  */
        err: java.io.PrintStream;
        /**  */
        in: java.io.InputStream;
        /**  */
        lineSeparator: java.lang.String;
        /**  */
        out: java.io.PrintStream;
        /**  */
        cons: java.io.Console;
        /**  */
        props: java.util.Properties;
        /**
         * 
         * @param {java.util.Properties} arg0 
         */
        private static  initProperties(arg0: java.util.Properties): java.util.Properties;
        /**
         * 
         * @param {java.lang.SecurityManager} arg0 
         */
        public static setSecurityManager(arg0: java.lang.SecurityManager): void;
        /**
         * 
         */
        private static initializeSystemClass(): void;
        /**
         * 
         * @param {java.util.Properties} arg0 
         */
        public static setProperties(arg0: java.util.Properties): void;
        /**
         * 
         */
        private static setJavaLangAccess(): void;
        /**
         * 
         */
        private static  registerNatives(): void;
        /**
         * 
         * @param {java.lang.SecurityManager} arg0 
         */
        private static  setSecurityManager0(arg0: java.lang.SecurityManager): void;
        /**
         * 
         * @param {boolean} arg0 
         */
        public static runFinalizersOnExit(arg0: boolean): void;
        /**
         * 
         */
        public static lineSeparator(): java.lang.String;
        /**
         * 
         * @param {java.io.PrintStream} arg0 
         */
        public static setOut(arg0: java.io.PrintStream): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static clearProperty(arg0: java.lang.String): java.lang.String;
        /**
         * 
         */
        private static checkIO(): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public static  identityHashCode(arg0: java.lang.Object): int;
        /**
         * 
         * @param {java.io.FileOutputStream} arg0 
         * @param {java.lang.String} arg1 
         */
        private static newPrintStream(arg0: java.io.FileOutputStream,arg1: java.lang.String): java.io.PrintStream;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static load(arg0: java.lang.String): void;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {int} arg1 
         * @param {java.lang.Object} arg2 
         * @param {int} arg3 
         * @param {int} arg4 
         */
        public static  arraycopy(arg0: java.lang.Object,arg1: int,arg2: java.lang.Object,arg3: int,arg4: int): void;
        /**
         * 
         */
        public static  nanoTime(): long;
        /**
         * 
         */
        public static inheritedChannel(): java.nio.channels.Channel;
        /**
         * 
         */
        public static gc(): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static getenv(arg0: java.lang.String): java.lang.String;
        /**
         * 
         */
        public static getenv(): java.util.Map;
        /**
         * 
         */
        public static console(): java.io.Console;
        /**
         * 
         * @param {java.io.PrintStream} arg0 
         */
        public static setErr(arg0: java.io.PrintStream): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static loadLibrary(arg0: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static getProperty(arg0: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.String} arg1 
         */
        public static getProperty(arg0: java.lang.String,arg1: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.io.InputStream} arg0 
         */
        public static setIn(arg0: java.io.InputStream): void;
        /**
         * 
         * @param {java.io.PrintStream} arg0 
         */
        private static  setErr0(arg0: java.io.PrintStream): void;
        /**
         * 
         */
        public static getProperties(): java.util.Properties;
        /**
         * 
         * @param {java.io.PrintStream} arg0 
         */
        private static  setOut0(arg0: java.io.PrintStream): void;
        /**
         * 
         * @param {java.io.InputStream} arg0 
         */
        private static  setIn0(arg0: java.io.InputStream): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        private static checkKey(arg0: java.lang.String): void;
        /**
         * 
         */
        public static getSecurityManager(): java.lang.SecurityManager;
        /**
         * 
         * @param {int} arg0 
         */
        public static exit(arg0: int): void;
        /**
         * 
         * @param {java.lang.String} arg0 
         */
        public static  mapLibraryName(arg0: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} arg0 
         * @param {java.lang.String} arg1 
         */
        public static setProperty(arg0: java.lang.String,arg1: java.lang.String): java.lang.String;
        /**
         * 
         */
        public static  currentTimeMillis(): long;
        /**
         * 
         */
        public static runFinalization(): void;
    }
}
declare namespace com.nukkitx.fakeinventories.inventory{
     class FakeSlotChangeEvent extends java.lang.Object{
        /**  */
        action: cn.nukkit.inventory.transaction.action.SlotChangeAction;
        /**  */
        cancelled: boolean;
        /**  */
        inventory: com.nukkitx.fakeinventories.inventory.FakeInventory;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public isCancelled(): boolean;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         * @param {boolean} arg0 
         */
        public setCancelled(arg0: boolean): void;
        /**
         * 
         */
        public setCancelled(): void;
        /**
         * 
         */
        public getAction(): cn.nukkit.inventory.transaction.action.SlotChangeAction;
        /**
         * 
         */
        public getInventory(): com.nukkitx.fakeinventories.inventory.FakeInventory;
    }
}
declare namespace cn.nukkit.event.entity{
     class ItemSpawnEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.item.EntityItem;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl.tree{
     class DarkOakTreePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        type: int;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public setRandomAmount(randomAmount: int): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemAxeDiamond extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.nbt{
     class NBTIO extends java.lang.Object{
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static readTag(inputStream: java.io.InputStream,endianness: java.nio.ByteOrder,network: boolean): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,endianness: java.nio.ByteOrder): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {int} level 
         */
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,level: int): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         */
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {int} level 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static writeZLIBCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,level: int,endianness: java.nio.ByteOrder): void;
        /**
         * 
         * @param {byte[]} data 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static read(data: byte[],endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         */
        public static read(inputStream: java.io.InputStream): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.File} file 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static read(file: java.io.File,endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.File} file 
         */
        public static read(file: java.io.File): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {byte[]} data 
         */
        public static read(data: byte[]): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static read(inputStream: java.io.InputStream,endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static read(inputStream: java.io.InputStream,endianness: java.nio.ByteOrder,network: boolean): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {byte[]} data 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static read(data: byte[],endianness: java.nio.ByteOrder,network: boolean): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {java.lang.Integer} slot 
         */
        public static putItemHelper(item: cn.nukkit.item.Item,slot: java.lang.Integer): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public static putItemHelper(item: cn.nukkit.item.Item): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,endianness: java.nio.ByteOrder): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         */
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,endianness: java.nio.ByteOrder): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public static writeGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public static getItemHelper(tag: cn.nukkit.nbt.tag.CompoundTag): cn.nukkit.item.Item;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         */
        public static readCompressed(inputStream: java.io.InputStream): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {byte[]} data 
         */
        public static readCompressed(data: byte[]): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {byte[]} data 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static readCompressed(data: byte[],endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static readCompressed(inputStream: java.io.InputStream,endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {int} id 
         * @param {int} damage 
         * @param {int} count 
         */
        private static fixAlphaItem(id: int,damage: int,count: int): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         */
        public static writeNetwork(tag: cn.nukkit.nbt.tag.Tag): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.File} file 
         */
        public static safeWrite(tag: cn.nukkit.nbt.tag.CompoundTag,file: java.io.File): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         */
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,endianness: java.nio.ByteOrder): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static writeNetworkGZIPCompressed(tag: cn.nukkit.nbt.tag.CompoundTag,endianness: java.nio.ByteOrder): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.Tag} tag 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static write(tag: cn.nukkit.nbt.tag.Tag,endianness: java.nio.ByteOrder,network: boolean): byte[];
        /**
         * 
         * @param {java.util.Collection} tags 
         */
        public static write(tags: java.util.Collection): byte[];
        /**
         * 
         * @param {java.util.Collection} tags 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static write(tags: java.util.Collection,endianness: java.nio.ByteOrder): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,endianness: java.nio.ByteOrder,network: boolean): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,endianness: java.nio.ByteOrder): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag): byte[];
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,endianness: java.nio.ByteOrder,network: boolean): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream,endianness: java.nio.ByteOrder): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.OutputStream} outputStream 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,outputStream: java.io.OutputStream): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.File} file 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,file: java.io.File,endianness: java.nio.ByteOrder): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         * @param {java.io.File} file 
         */
        public static write(tag: cn.nukkit.nbt.tag.CompoundTag,file: java.io.File): void;
        /**
         * 
         * @param {java.util.Collection} tags 
         * @param {java.nio.ByteOrder} endianness 
         * @param {boolean} network 
         */
        public static write(tags: java.util.Collection,endianness: java.nio.ByteOrder,network: boolean): byte[];
        /**
         * 
         * @param {byte[]} data 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static readNetworkCompressed(data: byte[],endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {byte[]} data 
         */
        public static readNetworkCompressed(data: byte[]): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         */
        public static readNetworkCompressed(inputStream: java.io.InputStream): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {java.io.InputStream} inputStream 
         * @param {java.nio.ByteOrder} endianness 
         */
        public static readNetworkCompressed(inputStream: java.io.InputStream,endianness: java.nio.ByteOrder): cn.nukkit.nbt.tag.CompoundTag;
    }
}
declare namespace cn.nukkit.item{
    abstract class ItemID extends java.lang.Object{
        /**  */
        RECORD_CAT: int;
        /**  */
        GOLD_SHOVEL: int;
        /**  */
        GOLDEN_APPLE: int;
        /**  */
        REDSTONE_DUST: int;
        /**  */
        CARROT_ON_A_STICK: int;
        /**  */
        IRON_BOOTS: int;
        /**  */
        RAW_MUTTON: int;
        /**  */
        SHEARS: int;
        /**  */
        GOLDEN_PICKAXE: int;
        /**  */
        RECORD_PIGSTEP: int;
        /**  */
        SADDLE: int;
        /**  */
        MINECART_WITH_HOPPER: int;
        /**  */
        POPPED_CHORUS_FRUIT: int;
        /**  */
        IRON_HOE: int;
        /**  */
        BREWING_STAND: int;
        /**  */
        RABBIT_STEW: int;
        /**  */
        STONE_PICKAXE: int;
        /**  */
        MINECART_WITH_CHEST: int;
        /**  */
        CAKE: int;
        /**  */
        SPRUCE_DOOR: int;
        /**  */
        WHEAT: int;
        /**  */
        CHAIN_CHESTPLATE: int;
        /**  */
        FIRE_CHARGE: int;
        /**  */
        SPRUCE_SIGN: int;
        /**  */
        GUNPOWDER: int;
        /**  */
        MUSHROOM_STEW: int;
        /**  */
        GOLD_HORSE_ARMOR: int;
        /**  */
        FLINT_AND_STEEL: int;
        /**  */
        IRON_CHESTPLATE: int;
        /**  */
        PRISMARINE_SHARD: int;
        /**  */
        GOLDEN_NUGGET: int;
        /**  */
        HONEYCOMB: int;
        /**  */
        DRIED_KELP: int;
        /**  */
        CLOCK: int;
        /**  */
        NAUTILUS_SHELL: int;
        /**  */
        RECORD_WAIT: int;
        /**  */
        DIAMOND_HORSE_ARMOR: int;
        /**  */
        NETHERITE_PICKAXE: int;
        /**  */
        DIAMOND: int;
        /**  */
        WOODEN_SHOVEL: int;
        /**  */
        COMPARATOR: int;
        /**  */
        RAW_FISH: int;
        /**  */
        SPIDER_EYE: int;
        /**  */
        RECORD_BLOCKS: int;
        /**  */
        RECORD_CHIRP: int;
        /**  */
        DYE: int;
        /**  */
        ARROW: int;
        /**  */
        NETHERITE_SCRAP: int;
        /**  */
        NETHERITE_AXE: int;
        /**  */
        GOLDEN_HOE: int;
        /**  */
        CAULDRON: int;
        /**  */
        LEATHER_CAP: int;
        /**  */
        IRON_SHOVEL: int;
        /**  */
        HONEY_BOTTLE: int;
        /**  */
        BED: int;
        /**  */
        GOLD_BOOTS: int;
        /**  */
        GOLD_LEGGINGS: int;
        /**  */
        PRISMARINE_CRYSTALS: int;
        /**  */
        CAMPFIRE: int;
        /**  */
        NETHERITE_LEGGINGS: int;
        /**  */
        END_CRYSTAL: int;
        /**  */
        STRING: int;
        /**  */
        RECORD_STRAD: int;
        /**  */
        BLAZE_POWDER: int;
        /**  */
        KELP: int;
        /**  */
        CLAY: int;
        /**  */
        GLISTERING_MELON: int;
        /**  */
        RABBIT_FOOT: int;
        /**  */
        APPLE: int;
        /**  */
        REDSTONE: int;
        /**  */
        CLOWNFISH: int;
        /**  */
        BUCKET: int;
        /**  */
        NETHER_SPROUTS: int;
        /**  */
        NETHERITE_SWORD: int;
        /**  */
        LINGERING_POTION: int;
        /**  */
        MINECART: int;
        /**  */
        GOLD_AXE: int;
        /**  */
        POTION: int;
        /**  */
        MELON_SLICE: int;
        /**  */
        DIAMOND_LEGGINGS: int;
        /**  */
        DRAGON_BREATH: int;
        /**  */
        EMPTY_MAP: int;
        /**  */
        RAW_CHICKEN: int;
        /**  */
        TURTLE_SHELL: int;
        /**  */
        GOLDEN_SWORD: int;
        /**  */
        SLIMEBALL: int;
        /**  */
        WARPED_FUNGUS_ON_A_STICK: int;
        /**  */
        PUMPKIN_SEEDS: int;
        /**  */
        WOODEN_AXE: int;
        /**  */
        SUGAR_CANES: int;
        /**  */
        SEEDS: int;
        /**  */
        NETHERITE_INGOT: int;
        /**  */
        NETHER_WART: int;
        /**  */
        FIREWORKS: int;
        /**  */
        ACACIA_DOOR: int;
        /**  */
        BEETROOT: int;
        /**  */
        COOKIE: int;
        /**  */
        IRON_LEGGINGS: int;
        /**  */
        FLINT: int;
        /**  */
        BREWING: int;
        /**  */
        CROSSBOW: int;
        /**  */
        DIAMOND_AXE: int;
        /**  */
        PUMPKIN_PIE: int;
        /**  */
        RECORD_FAR: int;
        /**  */
        SOUL_CAMPFIRE: int;
        /**  */
        STICK: int;
        /**  */
        ACACIA_SIGN: int;
        /**  */
        IRON_AXE: int;
        /**  */
        MELON: int;
        /**  */
        IRON_HORSE_ARMOR: int;
        /**  */
        SHIELD: int;
        /**  */
        GOLDEN_APPLE_ENCHANTED: int;
        /**  */
        LODESTONECOMPASS: int;
        /**  */
        BONE: int;
        /**  */
        POISONOUS_POTATO: int;
        /**  */
        SUSPICIOUS_STEW: int;
        /**  */
        PUFFERFISH: int;
        /**  */
        BOTTLE: int;
        /**  */
        CARROTS: int;
        /**  */
        CRIMSON_DOOR: int;
        /**  */
        WOODEN_PICKAXE: int;
        /**  */
        SPLASH_POTION: int;
        /**  */
        FEATHER: int;
        /**  */
        SPAWN_EGG: int;
        /**  */
        BIRCH_DOOR: int;
        /**  */
        CRIMSON_SIGN: int;
        /**  */
        DIAMOND_CHESTPLATE: int;
        /**  */
        COOKED_RABBIT: int;
        /**  */
        BLAZE_ROD: int;
        /**  */
        BOOK: int;
        /**  */
        CHORUS_FRUIT: int;
        /**  */
        COOKED_SALMON: int;
        /**  */
        NETHERITE_SHOVEL: int;
        /**  */
        IRON_NUGGET: int;
        /**  */
        MELON_SEEDS: int;
        /**  */
        WOODEN_SWORD: int;
        /**  */
        GOLD_NUGGET: int;
        /**  */
        BOOK_AND_QUILL: int;
        /**  */
        GOLDEN_AXE: int;
        /**  */
        NETHER_BRICK: int;
        /**  */
        BREAD: int;
        /**  */
        PAINTING: int;
        /**  */
        STONE_HOE: int;
        /**  */
        REPEATER: int;
        /**  */
        CHAIN_HELMET: int;
        /**  */
        GOLD_CHESTPLATE: int;
        /**  */
        BIRCH_SIGN: int;
        /**  */
        POTATO: int;
        /**  */
        ENCHANT_BOOK: int;
        /**  */
        COOKED_CHICKEN: int;
        /**  */
        GHAST_TEAR: int;
        /**  */
        EXPERIENCE_BOTTLE: int;
        /**  */
        BEETROOT_SEED: int;
        /**  */
        COMMAND_BLOCK_MINECART: int;
        /**  */
        PHANTOM_MEMBRANE: int;
        /**  */
        RECORD_WARD: int;
        /**  */
        IRON_INGOT: int;
        /**  */
        MAP: int;
        /**  */
        RAW_PORKCHOP: int;
        /**  */
        BAKED_POTATO: int;
        /**  */
        DIAMOND_SWORD: int;
        /**  */
        LEATHER_PANTS: int;
        /**  */
        DARK_OAK_DOOR: int;
        /**  */
        GLOWSTONE_DUST: int;
        /**  */
        GOLD_INGOT: int;
        /**  */
        RAW_RABBIT: int;
        /**  */
        DARK_OAK_SIGN: int;
        /**  */
        DIAMOND_HOE: int;
        /**  */
        GOLDEN_SHOVEL: int;
        /**  */
        ITEM_FRAME: int;
        /**  */
        GOLD_HELMET: int;
        /**  */
        ENDER_EYE: int;
        /**  */
        WRITTEN_BOOK: int;
        /**  */
        NETHERITE_BOOTS: int;
        /**  */
        CHAIN_LEGGINGS: int;
        /**  */
        BOAT: int;
        /**  */
        DIAMOND_PICKAXE: int;
        /**  */
        EMERALD: int;
        /**  */
        DIAMOND_HELMET: int;
        /**  */
        GOLDEN_CARROT: int;
        /**  */
        TOTEM: int;
        /**  */
        ENCHANTED_BOOK: int;
        /**  */
        SHULKER_SHELL: int;
        /**  */
        POTATOES: int;
        /**  */
        GOLD_SWORD: int;
        /**  */
        LEATHER_BOOTS: int;
        /**  */
        HOPPER: int;
        /**  */
        IRON_HELMET: int;
        /**  */
        COOKED_BEEF: int;
        /**  */
        CHAIN: int;
        /**  */
        BANNER_PATTERN: int;
        /**  */
        BANNER: int;
        /**  */
        NETHER_STAR: int;
        /**  */
        HEART_OF_THE_SEA: int;
        /**  */
        LEAD: int;
        /**  */
        COOKED_MUTTON: int;
        /**  */
        COMPASS: int;
        /**  */
        RECORD_13: int;
        /**  */
        NETHERITE_HELMET: int;
        /**  */
        FISHING_ROD: int;
        /**  */
        STICKS: int;
        /**  */
        SCUTE: int;
        /**  */
        COAL: int;
        /**  */
        ENDER_PEARL: int;
        /**  */
        SKULL: int;
        /**  */
        NETHERITE_HOE: int;
        /**  */
        RECORD_MELLOHI: int;
        /**  */
        CARROT: int;
        /**  */
        TRIDENT: int;
        /**  */
        LEATHER_TUNIC: int;
        /**  */
        STEAK: int;
        /**  */
        GLASS_BOTTLE: int;
        /**  */
        LODESTONE_COMPASS: int;
        /**  */
        WOODEN_HOE: int;
        /**  */
        SIGN: int;
        /**  */
        QUARTZ: int;
        /**  */
        RECORD_11: int;
        /**  */
        RAW_BEEF: int;
        /**  */
        CHAIN_BOOTS: int;
        /**  */
        DIAMOND_SHOVEL: int;
        /**  */
        GOLD_HOE: int;
        /**  */
        SUGAR_CANE: int;
        /**  */
        MAGMA_CREAM: int;
        /**  */
        ELYTRA: int;
        /**  */
        NAME_TAG: int;
        /**  */
        ARMOR_STAND: int;
        /**  */
        COOKED_PORKCHOP: int;
        /**  */
        BOW: int;
        /**  */
        SUGAR: int;
        /**  */
        RAW_SALMON: int;
        /**  */
        RABBIT_HIDE: int;
        /**  */
        SWEET_BERRIES: int;
        /**  */
        DIAMOND_BOOTS: int;
        /**  */
        JUNGLE_SIGN: int;
        /**  */
        STONE_SWORD: int;
        /**  */
        COOKED_FISH: int;
        /**  */
        ROTTEN_FLESH: int;
        /**  */
        STONE_AXE: int;
        /**  */
        FIREWORKSCHARGE: int;
        /**  */
        JUNGLE_DOOR: int;
        /**  */
        BAKED_POTATOES: int;
        /**  */
        BEETROOT_SOUP: int;
        /**  */
        WHEAT_SEEDS: int;
        /**  */
        NETHERITE_CHESTPLATE: int;
        /**  */
        LEATHER: int;
        /**  */
        STONE_SHOVEL: int;
        /**  */
        DARKOAK_SIGN: int;
        /**  */
        RECORD_MALL: int;
        /**  */
        WARPED_DOOR: int;
        /**  */
        SNOWBALL: int;
        /**  */
        FLOWER_POT: int;
        /**  */
        IRON_DOOR: int;
        /**  */
        IRON_PICKAXE: int;
        /**  */
        FLINT_STEEL: int;
        /**  */
        WOODEN_DOOR: int;
        /**  */
        EGG: int;
        /**  */
        NETHER_QUARTZ: int;
        /**  */
        RECORD_STAL: int;
        /**  */
        BRICK: int;
        /**  */
        PAPER: int;
        /**  */
        FERMENTED_SPIDER_EYE: int;
        /**  */
        IRON_SWORD: int;
        /**  */
        BEETROOT_SEEDS: int;
        /**  */
        MINECART_WITH_TNT: int;
        /**  */
        LEATHER_HORSE_ARMOR: int;
        /**  */
        GOLD_PICKAXE: int;
        /**  */
        WARPED_SIGN: int;
        /**  */
        SUGARCANE: int;
        /**  */
        BOWL: int;
    }
}
declare namespace cn.nukkit.block{
     class BlockStone extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        POLISHED_GRANITE: int;
        /**  */
        GRANITE: int;
        /**  */
        STONE_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        POLISHED_ANDESITE: int;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        ANDESITE: int;
        /**  */
        DIORITE: int;
        /**  */
        NORMAL: int;
        /**  */
        POLISHED_DIORITE: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.StoneType} stoneType 
         */
        public setStoneType(stoneType: cn.nukkit.blockproperty.value.StoneType): void;
        /**
         * 
         */
        public getStoneType(): cn.nukkit.blockproperty.value.StoneType;
    }
}
declare namespace cn.nukkit.event.level{
    abstract class ChunkEvent extends cn.nukkit.event.level.LevelEvent{
        /**  */
        chunk: cn.nukkit.level.format.FullChunk;
        /**
         * 
         */
        public getChunk(): cn.nukkit.level.format.FullChunk;
    }
}
declare namespace com.blocklynukkit.loader.script.window.windowCallbacks{
     class ModalCallback extends com.blocklynukkit.loader.script.window.windowCallbacks.WindowCallback{
        /**  */
        defaultCallback: java.lang.String;
        /**  */
        noCallback: java.lang.String;
        /**  */
        yesCallback: java.lang.String;
        /**
         * 
         * @param {cn.nukkit.event.player.PlayerFormRespondedEvent} event 
         */
        public call(event: cn.nukkit.event.player.PlayerFormRespondedEvent): void;
        /**
         * 
         */
        public hasDefaultCallback(): boolean;
        /**
         * 
         * @param {java.lang.String} yesCallback 
         */
        public setYesCallback(yesCallback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} defaultCallback 
         */
        public setDefaultCallback(defaultCallback: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} noCallback 
         */
        public setNoCallback(noCallback: java.lang.String): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemDriedKelp extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.command.defaults{
     class XpCommand extends cn.nukkit.command.Command{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.network.protocol{
     class SpawnExperienceOrbPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        amount: int;
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemIngotNetherite extends cn.nukkit.item.Item{
        /**
         * 
         */
        public isLavaResistant(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockRailActivator extends cn.nukkit.block.BlockRail{
        /**
         * 
         * @param {boolean} active 
         */
        public setRailActive(active: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {boolean} relative 
         * @param {int} power 
         */
        protected checkSurrounding(pos: cn.nukkit.math.Vector3,relative: boolean,power: int): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.utils.Rail.Orientation} state 
         * @param {int} power 
         * @param {boolean} relative 
         */
        protected canPowered(pos: cn.nukkit.math.Vector3,state: cn.nukkit.utils.Rail.Orientation,power: int,relative: boolean): boolean;
        /**
         * 
         */
        public isActive(): boolean;
        /**
         * 
         */
        public isRailActive(): cn.nukkit.utils.OptionalBoolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ResourcePackChunkDataPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        packId: java.util.UUID;
        /**  */
        data: byte[];
        /**  */
        NETWORK_ID: byte;
        /**  */
        progress: long;
        /**  */
        chunkIndex: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.forest{
     class FlowerForestBiome extends cn.nukkit.level.biome.impl.forest.ForestBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorMelon extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorLava extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        random: cn.nukkit.math.NukkitRandom;
        /**  */
        level: cn.nukkit.level.ChunkManager;
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private lavaSpread(x: int,y: int,z: int): void;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {int} x 
         * @param {int} z 
         */
        private getHighestWorkableBlock(chunk: cn.nukkit.level.format.FullChunk,x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} x1 
         * @param {int} y1 
         * @param {int} z1 
         * @param {int} x2 
         * @param {int} y2 
         * @param {int} z2 
         */
        private getFlowDecay(x1: int,y1: int,z1: int,x2: int,y2: int,z2: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} newFlowDecay 
         */
        private flowIntoBlock(x: int,y: int,z: int,newFlowDecay: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private canFlowInto(x: int,y: int,z: int): boolean;
        /**
         * 
         * @param {int} amount 
         */
        public setBaseAmount(amount: int): void;
        /**
         * 
         * @param {int} xx 
         * @param {int} yy 
         * @param {int} zz 
         * @param {int} accumulatedCost 
         * @param {int} previousDirection 
         */
        private calculateFlowCost(xx: int,yy: int,zz: int,accumulatedCost: int,previousDirection: int): int;
        /**
         * 
         * @param {int} amount 
         */
        public setRandomAmount(amount: int): void;
        /**
         * 
         * @param {int} xx 
         * @param {int} yy 
         * @param {int} zz 
         */
        private getOptimalFlowDirections(xx: int,yy: int,zz: int): boolean[];
        /**
         * 
         * @param {int} x1 
         * @param {int} y1 
         * @param {int} z1 
         * @param {int} x2 
         * @param {int} y2 
         * @param {int} z2 
         * @param {int} decay 
         */
        private getSmallestFlowDecay(x1: int,y1: int,z1: int,x2: int,y2: int,z2: int,decay: int): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedBlue extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace java.util{
    abstract class Set extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract add(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public spliterator(): java.util.Spliterator;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract containsAll(arg0: java.util.Collection): boolean;
        /**
         * 
         */
        public abstract clear(): void;
        /**
         * 
         */
        public abstract isEmpty(): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract remove(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract contains(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public abstract iterator(): java.util.Iterator;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract removeAll(arg0: java.util.Collection): boolean;
        /**
         * 
         */
        public abstract size(): int;
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract addAll(arg0: java.util.Collection): boolean;
        /**
         * 
         */
        public abstract hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract equals(arg0: java.lang.Object): boolean;
        /**
         * 
         */
        public abstract toArray(): java.lang.Object[];
        /**
         * 
         * @param {java.lang.Object[]} arg0 
         */
        public abstract toArray(arg0: java.lang.Object[]): java.lang.Object[];
        /**
         * 
         * @param {java.util.Collection} arg0 
         */
        public abstract retainAll(arg0: java.util.Collection): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockDiamond extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityZombiePigman extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemSeedsBeetroot extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.item{
     class ItemBootsChain extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public isBoots(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemMinecartChest extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.level.particle{
     class WaterParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.item{
     class ItemSteak extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.block{
     class BlockGrass extends cn.nukkit.block.BlockDirt{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDirtType(): java.util.Optional;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public onActivate(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.DirtType} dirtType 
         */
        public setDirtType(dirtType: cn.nukkit.blockproperty.value.DirtType): void;
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemPainting extends cn.nukkit.item.Item{
        /**  */
        DIRECTION: int[];
        /**  */
        RIGHT: int[];
        /**  */
        OFFSET: double;
        /**
         * 
         * @param {int} value 
         */
        private static offset(value: int): double;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.blockentity{
     class BlockEntityEnderChest extends cn.nukkit.blockentity.BlockEntitySpawnable{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getSpawnCompound(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public isBlockEntityValid(): boolean;
    }
}
declare namespace org.java_websocket{
    abstract class AbstractWebSocket extends org.java_websocket.WebSocketAdapter{
        /**  */
        reuseAddr: boolean;
        /**  */
        websocketRunning: boolean;
        /**  */
        log: org.slf4j.Logger;
        /**  */
        connectionLostTimeout: long;
        /**  */
        connectionLostCheckerFuture: java.util.concurrent.ScheduledFuture;
        /**  */
        tcpNoDelay: boolean;
        /**  */
        connectionLostCheckerService: java.util.concurrent.ScheduledExecutorService;
        /**  */
        syncConnectionLost: java.lang.Object;
        /**
         * 
         */
        public isTcpNoDelay(): boolean;
        /**
         * 
         */
        private restartConnectionLostTimer(): void;
        /**
         * 
         * @param {org.java_websocket.AbstractWebSocket} arg0 
         * @param {org.java_websocket.WebSocket} arg1 
         * @param {long} arg2 
         */
        static access$200(arg0: org.java_websocket.AbstractWebSocket,arg1: org.java_websocket.WebSocket,arg2: long): void;
        /**
         * 
         * @param {org.java_websocket.AbstractWebSocket} arg0 
         */
        static access$100(arg0: org.java_websocket.AbstractWebSocket): long;
        /**
         * 
         * @param {org.java_websocket.AbstractWebSocket} arg0 
         */
        static access$000(arg0: org.java_websocket.AbstractWebSocket): java.lang.Object;
        /**
         * 
         * @param {boolean} arg0 
         */
        public setTcpNoDelay(arg0: boolean): void;
        /**
         * 
         */
        public isReuseAddr(): boolean;
        /**
         * 
         * @param {int} arg0 
         */
        public setConnectionLostTimeout(arg0: int): void;
        /**
         * 
         */
        public getConnectionLostTimeout(): int;
        /**
         * 
         */
        protected stopConnectionLostTimer(): void;
        /**
         * 
         */
        private cancelConnectionLostTimer(): void;
        /**
         * 
         * @param {boolean} arg0 
         */
        public setReuseAddr(arg0: boolean): void;
        /**
         * 
         * @param {org.java_websocket.WebSocket} arg0 
         * @param {long} arg1 
         */
        private executeConnectionLostDetection(arg0: org.java_websocket.WebSocket,arg1: long): void;
        /**
         * 
         */
        protected startConnectionLostTimer(): void;
        /**
         * 
         */
        protected abstract getConnections(): java.util.Collection;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityZombie extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class EntityEventPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        SHAKE_WET: int;
        /**  */
        CONSUME_TOTEM: int;
        /**  */
        data: int;
        /**  */
        NETWORK_ID: int;
        /**  */
        IRON_GOLEM_WITHDRAW_FLOWER: int;
        /**  */
        AIR_SUPPLY: int;
        /**  */
        JUMP: int;
        /**  */
        ARM_SWING: int;
        /**  */
        PLAYER_CHECK_TREASURE_HUNTER_ACHIEVEMENT: int;
        /**  */
        ENDER_DRAGON_DEATH: int;
        /**  */
        ZOMBIE_VILLAGER_CURE: int;
        /**  */
        ENTITY_SPAWN: int;
        /**  */
        SQUID_INK_CLOUD: int;
        /**  */
        CARAVAN: int;
        /**  */
        BALLOON_POP: int;
        /**  */
        NONE: int;
        /**  */
        TAME_SUCCESS: int;
        /**  */
        FINISHED_CHARGING_CROSSBOW: int;
        /**  */
        FISH_HOOK_POSITION: int;
        /**  */
        ARROW_SHAKE: int;
        /**  */
        REMOVE_LEASH: int;
        /**  */
        SILVERFISH_SPAWN_ANIMATION: int;
        /**  */
        TAME_FAIL: int;
        /**  */
        LOVE_PARTICLES: int;
        /**  */
        WITCH_DRINK_POTION: int;
        /**  */
        PRIME_CREEPER: int;
        /**  */
        VILLAGER_ANGRY: int;
        /**  */
        SUMMON_AGENT: int;
        /**  */
        BABY_ANIMAL_FEED: int;
        /**  */
        EAT_GRASS_ANIMATION: int;
        /**  */
        MINECART_TNT_PRIME_FUSE: int;
        /**  */
        ELDER_GUARDIAN_CURSE: int;
        /**  */
        EATING_ITEM: int;
        /**  */
        DEATH_SMOKE_CLOUD: int;
        /**  */
        RESPAWN: int;
        /**  */
        ENCHANT: int;
        /**  */
        eid: long;
        /**  */
        VILLAGER_HAPPY: int;
        /**  */
        START_SWIMMING: int;
        /**  */
        IN_LOVE_HEARTS: int;
        /**  */
        DEATH_ANIMATION: int;
        /**  */
        FISH_HOOK_TEASE: int;
        /**  */
        WITCH_THROW_POTION: int;
        /**  */
        AGENT_ARM_SWING: int;
        /**  */
        COMPLETE_TRADE: int;
        /**  */
        FISH_HOOK_BUBBLE: int;
        /**  */
        FISH_HOOK_HOOK: int;
        /**  */
        DUST_PARTICLES: int;
        /**  */
        event: int;
        /**  */
        FIREWORK_EXPLOSION: int;
        /**  */
        TREASURE_HUNT: int;
        /**  */
        HURT_ANIMATION: int;
        /**  */
        GUARDIAN_ATTACK_ANIMATION: int;
        /**  */
        DRAGON_PUKE: int;
        /**  */
        AMBIENT_SOUND: int;
        /**  */
        USE_ITEM: int;
        /**  */
        IRON_GOLEM_OFFER_FLOWER: int;
        /**  */
        WITCH_SPELL_PARTICLES: int;
        /**  */
        ATTACK_STOP: int;
        /**  */
        MERGE_ITEMS: int;
        /**  */
        LANDED_ON_GROUND: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemSign extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.level.generator.populator.type{
    abstract class PopulatorCount extends cn.nukkit.level.generator.populator.type.Populator{
        /**  */
        randomAmount: int;
        /**  */
        baseAmount: int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public  populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} baseAmount 
         */
        public  setBaseAmount(baseAmount: int): void;
        /**
         * 
         * @param {int} randomAmount 
         */
        public  setRandomAmount(randomAmount: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected abstract populateCount(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class CustomWindowEvent extends cn.nukkit.event.player.PlayerFormRespondedEvent{
        /**  */
        index: int;
        /**  */
        $assertionsDisabled: boolean;
        /**
         * 
         */
        public getResult(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class TextPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        isLocalized: boolean;
        /**  */
        TYPE_TRANSLATION: byte;
        /**  */
        xboxUserId: java.lang.String;
        /**  */
        NETWORK_ID: byte;
        /**  */
        TYPE_JUKEBOX_POPUP: byte;
        /**  */
        TYPE_RAW: byte;
        /**  */
        TYPE_OBJECT_WHISPER: byte;
        /**  */
        source: java.lang.String;
        /**  */
        type: byte;
        /**  */
        message: java.lang.String;
        /**  */
        TYPE_ANNOUNCEMENT: byte;
        /**  */
        TYPE_OBJECT: byte;
        /**  */
        TYPE_SYSTEM: byte;
        /**  */
        TYPE_CHAT: byte;
        /**  */
        TYPE_WHISPER: byte;
        /**  */
        parameters: java.lang.String[];
        /**  */
        platformChatId: java.lang.String;
        /**  */
        TYPE_POPUP: byte;
        /**  */
        TYPE_TIP: byte;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class TaigaBiome extends cn.nukkit.level.biome.type.GrassyBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemChestplateNetherite extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getToughness(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockMushroom extends cn.nukkit.block.BlockFlowable{
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public grow(): boolean;
        /**
         * 
         */
        protected abstract getType(): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public onActivate(item: cn.nukkit.item.Item,player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public canStay(): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockWallBanner extends cn.nukkit.block.BlockBanner{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getBlockFace(): cn.nukkit.math.BlockFace;
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public setBlockFace(face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getDirection(): cn.nukkit.math.CompassRoseDirection;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.math.CompassRoseDirection} direction 
         */
        public setDirection(direction: cn.nukkit.math.CompassRoseDirection): void;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class BNInitializedEvent extends cn.nukkit.event.Event{
    }
}
declare namespace cn.nukkit.event.level{
    abstract class WeatherEvent extends cn.nukkit.event.Event{
        /**  */
        level: cn.nukkit.level.Level;
        /**
         * 
         */
        public getLevel(): cn.nukkit.level.Level;
    }
}
declare namespace cn.nukkit.block{
     class BlockDoubleSlabWood extends cn.nukkit.block.BlockDoubleSlabBase{
        /**
         * 
         */
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        protected isCorrectTool(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getSlabName(): java.lang.String;
        /**
         * 
         */
        public getSingleSlabId(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} type 
         */
        public setWoodType(type: cn.nukkit.blockproperty.value.WoodType): void;
    }
}
declare namespace cn.nukkit.command.defaults{
     class BanIpCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {java.lang.String} ip 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} reason 
         */
        private processIPBan(ip: java.lang.String,sender: cn.nukkit.command.CommandSender,reason: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.event.entity{
     class ProjectileLaunchEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public  getEntity(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getEntity(): cn.nukkit.entity.projectile.EntityProjectile;
    }
}
declare namespace cn.nukkit.item{
     class ItemDoorDarkOak extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorCactus extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
    }
}
declare namespace cn.nukkit.command.defaults{
     class EffectCommand extends cn.nukkit.command.Command{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedPurple extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.console{
     class NukkitConsoleCompleter extends java.lang.Object{
        /**  */
        server: cn.nukkit.Server;
        /**
         * 
         * @param {java.util.function.Consumer} commandConsumer 
         */
        private addCandidates(commandConsumer: java.util.function.Consumer): void;
        /**
         * 
         * @param {java.util.SortedSet} names 
         * @param {cn.nukkit.Player} p 
         */
        private static lambda$complete$1(names: java.util.SortedSet,p: cn.nukkit.Player): void;
        /**
         * 
         * @param {java.util.List} candidates 
         * @param {java.lang.String} s 
         */
        private static lambda$complete$0(candidates: java.util.List,s: java.lang.String): void;
        /**
         * 
         * @param {org.jline.reader.LineReader} lineReader 
         * @param {org.jline.reader.ParsedLine} parsedLine 
         * @param {java.util.List} candidates 
         */
        public complete(lineReader: org.jline.reader.LineReader,parsedLine: org.jline.reader.ParsedLine,candidates: java.util.List): void;
    }
}
declare namespace cn.nukkit.utils{
     class DefaultPlayerDataSerializer extends java.lang.Object{
        /**  */
        dataPath: java.lang.String;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.UUID} uuid 
         */
        public read(name: java.lang.String,uuid: java.util.UUID): java.util.Optional;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.util.UUID} uuid 
         */
        public write(name: java.lang.String,uuid: java.util.UUID): java.io.OutputStream;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockBurnEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace com.blocklynukkit.loader.script.window{
     class Modal extends java.lang.Object{
        /**  */
        previous: short;
        /**  */
        context: java.lang.String;
        /**  */
        btn2: java.lang.String;
        /**  */
        btn1Callback: java.lang.String;
        /**  */
        id: int;
        /**  */
        btn1: java.lang.String;
        /**  */
        title: java.lang.String;
        /**  */
        btn2Callback: java.lang.String;
        /**
         * 设置左侧按钮文本
         * @param {java.lang.String} text 文本
         */
        public button2(text: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 为上一个操作的按钮绑定点击动作回调
         * @param {java.lang.String} callback 回调函数
         */
        public setAction(callback: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {boolean} accpetClose 玩家关闭窗口是否触发回调
         */
        public show(p: cn.nukkit.Player,accpetClose: boolean): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         */
        public show(p: cn.nukkit.Player): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         */
        public show(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public show(p: cn.nukkit.Player,callback: java.lang.String,acceptClose: boolean): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 设置窗口标题
         * @param {java.lang.String} title 窗口标题
         */
        public setTitle(title: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 设置窗口标题
         * @param {java.lang.String} title 窗口标题
         */
        public title(title: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         */
        public showToPlayer(p: cn.nukkit.Player): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public showToPlayer(p: cn.nukkit.Player,acceptClose: boolean): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         */
        public showToPlayer(p: cn.nukkit.Player,callback: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 向玩家发送此窗口
         * @param {cn.nukkit.Player} p 发送给的玩家
         * @param {java.lang.String} callback 回调函数
         * @param {boolean} acceptClose 玩家关闭窗口是否触发回调
         */
        public showToPlayer(p: cn.nukkit.Player,callback: java.lang.String,acceptClose: boolean): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 设置窗口提示文本
         * @param {java.lang.String} context 窗口提示文本
         */
        public context(context: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 设置窗口提示文本
         * @param {java.lang.String} context 窗口提示文本
         */
        public setContext(context: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 为上一个添加的按钮绑定点击动作回调
         * @param {java.lang.String} callback 回调函数
         */
        public action(callback: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 设置左侧按钮文本
         * @param {java.lang.String} text 文本
         */
        public setButton1(text: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 设置左侧按钮文本
         * @param {java.lang.String} text 文本
         */
        public button1(text: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
        /**
         * 设置左侧按钮文本
         * @param {java.lang.String} text 文本
         */
        public setButton2(text: java.lang.String): com.blocklynukkit.loader.script.window.Modal;
    }
}
declare namespace cn.nukkit.level.biome.impl.jungle{
     class JungleHillsBiome extends cn.nukkit.level.biome.impl.jungle.JungleBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockBricksStone extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        STONE_BRICK_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        MOSSY: int;
        /**  */
        CHISELED: int;
        /**  */
        CRACKED: int;
        /**  */
        NORMAL: int;
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.StoneBrickType} stoneBrickType 
         */
        public setBrickStoneType(stoneBrickType: cn.nukkit.blockproperty.value.StoneBrickType): void;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getStoneBrickType(): cn.nukkit.blockproperty.value.StoneBrickType;
    }
}
declare namespace cn.nukkit.item.enchantment{
     class EnchantmentWaterWorker extends cn.nukkit.item.enchantment.Enchantment{
        /**
         * 
         * @param {int} level 
         */
        public getMaxEnchantAbility(level: int): int;
        /**
         * 
         * @param {int} level 
         */
        public getMinEnchantAbility(level: int): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemSpiderEyeFermented extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerBlockPickEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        blockClicked: cn.nukkit.block.Block;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public setItem(item: cn.nukkit.item.Item): void;
        /**
         * 
         */
        public getBlockClicked(): cn.nukkit.block.Block;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecordFar extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class WaterIcePopulator extends cn.nukkit.level.generator.populator.type.Populator{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populate(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemBookEnchanted extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemChestplateIron extends cn.nukkit.item.ItemArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace cn.nukkit.event.block{
     class ItemFrameDropItemEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        item: cn.nukkit.item.Item;
        /**  */
        itemFrame: cn.nukkit.blockentity.BlockEntityItemFrame;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItemFrame(): cn.nukkit.blockentity.BlockEntityItemFrame;
        /**
         * 
         */
        public getItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.item{
     class ItemHoeIron extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isHoe(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace java.lang{
    abstract class Comparable extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public abstract compareTo(arg0: java.lang.Object): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockMagma extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onEntityCollide(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace cn.nukkit.level.biome.impl.river{
     class RiverBiome extends cn.nukkit.level.biome.type.WateryBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreDiamond extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.block{
    abstract class BlockThin extends cn.nukkit.block.BlockTransparent{
        /**
         * 
         * @param {cn.nukkit.math.BlockFace} side 
         */
        public isSolid(side: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         */
        public isSolid(): boolean;
        /**
         * 
         */
        protected recalculateBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        public canConnect(block: cn.nukkit.block.Block): boolean;
    }
}
declare namespace cn.nukkit.console{
     class NukkitConsole extends net.minecrell.terminalconsole.SimpleTerminalConsole{
        /**  */
        server: cn.nukkit.Server;
        /**  */
        consoleQueue: java.util.concurrent.BlockingQueue;
        /**  */
        executingCommands: java.util.concurrent.atomic.AtomicBoolean;
        /**
         * 
         * @param {boolean} executingCommands 
         */
        public setExecutingCommands(executingCommands: boolean): void;
        /**
         * 
         * @param {cn.nukkit.event.server.ServerCommandEvent} event 
         */
        private lambda$runCommand$0(event: cn.nukkit.event.server.ServerCommandEvent): void;
        /**
         * 
         */
        protected isRunning(): boolean;
        /**
         * 
         * @param {org.jline.reader.LineReaderBuilder} builder 
         */
        protected buildReader(builder: org.jline.reader.LineReaderBuilder): org.jline.reader.LineReader;
        /**
         * 
         * @param {java.lang.String} command 
         */
        protected runCommand(command: java.lang.String): void;
        /**
         * 
         */
        public readLine(): java.lang.String;
        /**
         * 
         */
        protected shutdown(): void;
        /**
         * 
         */
        public isExecutingCommands(): boolean;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class MushroomPopulator extends cn.nukkit.level.generator.populator.type.PopulatorCount{
        /**  */
        type: int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getHighestWorkableBlock(level: cn.nukkit.level.ChunkManager,x: int,z: int,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public populateCount(level: cn.nukkit.level.ChunkManager,chunkX: int,chunkZ: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class PlayerEnchantOptionsPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        options: java.util.List;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.level.generator.object.tree{
     class ObjectDarkOakTree extends cn.nukkit.level.generator.object.tree.TreeGenerator{
        /**  */
        DARK_OAK_LEAVES: cn.nukkit.block.Block;
        /**  */
        DARK_OAK_LOG: cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} height 
         */
        private placeTreeOfHeight(worldIn: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3,height: int): boolean;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private placeLeafAt(worldIn: cn.nukkit.level.ChunkManager,x: int,y: int,z: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        private placeLogAt(worldIn: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {cn.nukkit.math.Vector3} position 
         */
        public generate(level: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,position: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedSilver extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemMinecartTNT extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getMaxStackSize(): int;
        /**
         * 
         * @param {cn.nukkit.level.Level} level 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         */
        public onActivate(level: cn.nukkit.level.Level,player: cn.nukkit.Player,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double): boolean;
        /**
         * 
         */
        public canBeActivated(): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.mesa{
     class MesaBiome extends cn.nukkit.level.biome.type.CoveredBiome{
        /**  */
        STATE_TERRACOTTA: cn.nukkit.blockstate.BlockState;
        /**  */
        colorLayer: int[];
        /**  */
        STATE_RED_SAND: cn.nukkit.blockstate.BlockState;
        /**  */
        STATE_STAINED_TERRACOTTA: cn.nukkit.blockstate.BlockState[];
        /**  */
        colorNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        redSandNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        moundHeight: int;
        /**  */
        moundNoise: cn.nukkit.level.generator.noise.nukkit.f.SimplexF;
        /**  */
        STATE_RED_SANDSTONE: cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getGroundDepth(x: int,y: int,z: int): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} height 
         */
        public setMoundHeight(height: int): void;
        /**
         * 
         */
        public canRain(): boolean;
        /**
         * 
         */
        protected minHill(): float;
        /**
         * 
         */
        protected getMoundFrequency(): float;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getHeightOffset(x: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getGroundState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getSurfaceDepth(x: int,y: int,z: int): int;
        /**
         * 
         * @param {java.util.Random} random 
         * @param {int} sliceCount 
         * @param {int} color 
         */
        private static setRandomLayerColor(random: java.util.Random,sliceCount: int,color: int): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityRabbit extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneLampLit extends cn.nukkit.block.BlockRedstoneLamp{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.level.util{
    abstract class BitArray extends java.lang.Object{
        /**
         * 
         */
        public abstract getVersion(): cn.nukkit.level.util.BitArrayVersion;
        /**
         * 
         * @param {int} index 
         * @param {int} value 
         */
        public abstract set(index: int,value: int): void;
        /**
         * 
         */
        public abstract size(): int;
        /**
         * 
         * @param {int} index 
         */
        public abstract get(index: int): int;
        /**
         * 
         */
        public abstract copy(): cn.nukkit.level.util.BitArray;
        /**
         * 
         */
        public abstract getWords(): int[];
    }
}
declare namespace cn.nukkit.level.particle{
     class SmokeParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.lang{
     class BaseLang extends java.lang.Object{
        /**  */
        fallbackLang: java.util.Map;
        /**  */
        FALLBACK_LANGUAGE: java.lang.String;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        langName: java.lang.String;
        /**  */
        lang: java.util.Map;
        /**
         * 
         * @param {java.lang.String} id 
         */
        public internalGet(id: java.lang.String): java.lang.String;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} text 
         * @param {java.lang.String} onlyPrefix 
         */
        protected parseTranslation(text: java.lang.String,onlyPrefix: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} text 
         */
        protected parseTranslation(text: java.lang.String): java.lang.String;
        /**
         * 
         */
        public getFallbackLangMap(): java.util.Map;
        /**
         * 
         */
        public getLang(): java.lang.String;
        /**
         * 
         * @param {java.lang.String} id 
         */
        public get(id: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} str 
         * @param {java.lang.String[]} params 
         */
        public  translateString(str: java.lang.String,...params: java.lang.String[]): java.lang.String;
        /**
         * 
         * @param {java.lang.String} str 
         */
        public translateString(str: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} str 
         * @param {java.lang.String} param 
         * @param {java.lang.String} onlyPrefix 
         */
        public translateString(str: java.lang.String,param: java.lang.String,onlyPrefix: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} str 
         * @param {java.lang.String[]} params 
         * @param {java.lang.String} onlyPrefix 
         */
        public translateString(str: java.lang.String,params: java.lang.String[],onlyPrefix: java.lang.String): java.lang.String;
        /**
         * 
         * @param {java.lang.String} str 
         * @param {java.lang.Object[]} params 
         */
        public  translateString(str: java.lang.String,...params: java.lang.Object[]): java.lang.String;
        /**
         * 
         * @param {java.io.BufferedReader} reader 
         */
        private parseLang(reader: java.io.BufferedReader): java.util.Map;
        /**
         * 
         * @param {java.lang.String} path 
         */
        protected loadLang(path: java.lang.String): java.util.Map;
        /**
         * 
         * @param {java.io.InputStream} stream 
         */
        protected loadLang(stream: java.io.InputStream): java.util.Map;
        /**
         * 
         */
        public getLangMap(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.lang.TextContainer} c 
         */
        public translate(c: cn.nukkit.lang.TextContainer): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemRedstoneRepeater extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.network.protocol{
     class SetEntityLinkPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        TYPE_RIDE: byte;
        /**  */
        NETWORK_ID: byte;
        /**  */
        immediate: byte;
        /**  */
        TYPE_PASSENGER: byte;
        /**  */
        vehicleUniqueId: long;
        /**  */
        type: byte;
        /**  */
        TYPE_REMOVE: byte;
        /**  */
        riderUniqueId: long;
        /**  */
        riderInitiated: boolean;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemShears extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public isShears(): boolean;
    }
}
declare namespace cn.nukkit.level.biome.impl.roofedforest{
     class RoofedForestMBiome extends cn.nukkit.level.biome.impl.roofedforest.RoofedForestBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item.enchantment.damage{
    abstract class EnchantmentDamage extends cn.nukkit.item.enchantment.Enchantment{
        /**  */
        damageType: cn.nukkit.item.enchantment.damage.EnchantmentDamage.TYPE;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public isItemAcceptable(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public canEnchant(item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public isMajor(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.enchantment.Enchantment} enchantment 
         */
        public checkCompatibility(enchantment: cn.nukkit.item.enchantment.Enchantment): boolean;
        /**
         * 
         */
        public getMaxLevel(): int;
    }
}
declare namespace cn.nukkit.level.format.anvil.util{
     class BlockStorage extends java.lang.Object{
        /**  */
        FLAG_HAS_ID: byte;
        /**  */
        FLAG_HAS_ID_EXTRA: byte;
        /**  */
        FLAG_ENABLE_DATA_EXTRA: byte;
        /**  */
        FLAG_HAS_DATA_EXTRA: byte;
        /**  */
        FLAG_HAS_DATA_HUGE: byte;
        /**  */
        FLAG_ENABLE_DATA_HUGE: byte;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        EMPTY_ARRAY: cn.nukkit.level.format.anvil.util.BlockStorage[];
        /**  */
        BLOCK_ID_MASK: int;
        /**  */
        flags: byte;
        /**  */
        $assertionsDisabled: boolean;
        /**  */
        FLAG_ENABLE_DATA_BIG: byte;
        /**  */
        states: cn.nukkit.blockstate.BlockState[];
        /**  */
        FLAG_HAS_DATA_BIG: byte;
        /**  */
        FLAG_EVERYTHING_ENABLED: byte;
        /**  */
        BLOCK_ID_FULL: int;
        /**  */
        FLAG_PALETTE_UPDATED: byte;
        /**  */
        palette: cn.nukkit.level.util.PalettedBlockStorage;
        /**  */
        denyStates: java.util.BitSet;
        /**  */
        SECTION_SIZE: int;
        /**  */
        EMPTY: cn.nukkit.blockstate.BlockState[];
        /**  */
        FLAG_ENABLE_ID_EXTRA: byte;
        /**  */
        BLOCK_ID_EXTRA_MASK: int;
        /**
         * 
         * @param {int} index 
         */
        private allow(index: int): void;
        /**
         * 
         * @param {int} index 
         */
        private clearDeny(index: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private static getIndex(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} index 
         * @param {int} value 
         */
        private getAndSetFullBlock(index: int,value: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} value 
         */
        public getAndSetFullBlock(x: int,y: int,z: int,value: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockData(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public setBlock(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         */
        public hasBlockDataExtras(): boolean;
        /**
         * 
         */
        public hasBlockDataHuge(): boolean;
        /**
         * 
         */
        public isPaletteUpdateDelayed(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {int} value 
         */
        private setFullBlock(index: int,value: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} value 
         */
        public setFullBlock(x: int,y: int,z: int,value: int): void;
        /**
         * 
         */
        public hasBlockIdExtras(): boolean;
        /**
         * 
         */
        public recheckBlocks(): void;
        /**
         * 
         */
        public hasBlockIds(): boolean;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.blockstate.BlockState} previous 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        private updateFlags(index: int,previous: cn.nukkit.blockstate.BlockState,state: cn.nukkit.blockstate.BlockState): void;
        /**
         * 
         * @param {int} index 
         */
        private getFullBlock(index: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockId(x: int,y: int,z: int): int;
        /**
         * 
         */
        public immutableCopy(): cn.nukkit.level.format.anvil.util.ImmutableBlockStorage;
        /**
         * 
         */
        public hasBlockDataBig(): boolean;
        /**
         * 
         */
        public copy(): cn.nukkit.level.format.anvil.util.BlockStorage;
        /**
         * 
         * @param {int} index 
         */
        private clearAllow(index: int): void;
        /**
         * 
         * @param {byte} flag 
         */
        private getFlag(flag: byte): boolean;
        /**
         * 
         * @param {int} index 
         */
        private border(index: int): void;
        /**
         * 
         * @param {int} index 
         */
        private deny(index: int): void;
        /**
         * 
         * @param {byte} flag 
         * @param {boolean} value 
         */
        private setFlag(flag: byte,value: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockChangeStateAbove(x: int,y: int,z: int): int;
        /**
         * 
         * @param {byte} newFlags 
         * @param {cn.nukkit.blockstate.BlockState[]} states 
         */
        private  computeFlags(newFlags: byte,...states: cn.nukkit.blockstate.BlockState[]): byte;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} meta 
         */
        public getAndSetBlock(x: int,y: int,z: int,id: int,meta: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public setBlockState(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): void;
        /**
         * 
         * @param {int} index 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        protected setBlockState(index: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockData(x: int,y: int,z: int,data: int): void;
        /**
         * 
         */
        private isPaletteUpdated(): boolean;
        /**
         * 
         * @param {int} index 
         */
        private clearBorder(index: int): void;
        /**
         * 
         * @param {cn.nukkit.utils.BinaryStream} stream 
         */
        public writeTo(stream: cn.nukkit.utils.BinaryStream): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockId(x: int,y: int,z: int,id: int): void;
        /**
         * 
         */
        public delayPaletteUpdates(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public getAndSetBlockState(x: int,y: int,z: int,state: cn.nukkit.blockstate.BlockState): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} pos 
         * @param {java.lang.String} arg 
         */
        private static checkArg(pos: int,arg: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.functional.BlockPositionDataConsumer} consumer 
         */
        public iterateStates(consumer: cn.nukkit.utils.functional.BlockPositionDataConsumer): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockState(x: int,y: int,z: int): cn.nukkit.blockstate.BlockState;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityHanging extends cn.nukkit.entity.Entity{
        /**  */
        direction: int;
        /**
         * 
         */
        protected isSurfaceValid(): boolean;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getDirection(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace com.blocklynukkit.loader.other.control{
     class JMemory extends java.lang.Object{
        /**
         * 获取JVM最大可用内存大小
         */
        public getMax(): long;
        /**
         * 获取JVM总内存大小
         */
        public getTotal(): long;
        /**
         * 进行内存清理
         */
        public gc(): void;
        /**
         * 获取JVM剩余内存大小
         */
        public getFree(): long;
    }
}
declare namespace cn.nukkit.command.data{
     class CommandEnum extends java.lang.Object{
        /**  */
        ENUM_ITEM: cn.nukkit.command.data.CommandEnum;
        /**  */
        ENUM_BOOLEAN: cn.nukkit.command.data.CommandEnum;
        /**  */
        ENUM_BLOCK: cn.nukkit.command.data.CommandEnum;
        /**  */
        values: java.util.List;
        /**  */
        name: java.lang.String;
        /**  */
        ENUM_GAMEMODE: cn.nukkit.command.data.CommandEnum;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getValues(): java.util.List;
        /**
         * 
         */
        public hashCode(): int;
    }
}
declare namespace cn.nukkit.level.biome.impl.taiga{
     class TaigaMBiome extends cn.nukkit.level.biome.impl.taiga.TaigaBiome{
        /**
         * 
         */
        public getName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemLeather extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.event.inventory{
     class CraftItemEvent extends cn.nukkit.event.Event{
        /**  */
        input: cn.nukkit.item.Item[];
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        recipe: cn.nukkit.inventory.Recipe;
        /**  */
        transaction: cn.nukkit.inventory.transaction.CraftingTransaction;
        /**  */
        player: cn.nukkit.Player;
        /**
         * 
         */
        public getPlayer(): cn.nukkit.Player;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getRecipe(): cn.nukkit.inventory.Recipe;
        /**
         * 
         */
        public getInput(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getTransaction(): cn.nukkit.inventory.transaction.CraftingTransaction;
    }
}
declare namespace cn.nukkit.network.protocol{
     class ChangeDimensionPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        respawn: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        dimension: int;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity.data{
     class NBTEntityData extends cn.nukkit.entity.data.EntityData{
        /**  */
        tag: cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public getType(): int;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} tag 
         */
        public setData(tag: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         * @param {java.lang.Object} tag 
         */
        public  setData(tag: java.lang.Object): void;
        /**
         * 
         */
        public  getData(): java.lang.Object;
        /**
         * 
         */
        public getData(): cn.nukkit.nbt.tag.CompoundTag;
    }
}
declare namespace cn.nukkit.utils{
    abstract class Logger extends java.lang.Object{
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract debug(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract debug(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract critical(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract critical(message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         * @param {java.lang.String} message 
         */
        public abstract log(level: cn.nukkit.utils.LogLevel,message: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.utils.LogLevel} level 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract log(level: cn.nukkit.utils.LogLevel,message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract alert(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract alert(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract warning(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract warning(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract emergency(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract emergency(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract error(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract error(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract info(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract info(message: java.lang.String,t: java.lang.Throwable): void;
        /**
         * 
         * @param {java.lang.String} message 
         */
        public abstract notice(message: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} message 
         * @param {java.lang.Throwable} t 
         */
        public abstract notice(message: java.lang.String,t: java.lang.Throwable): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemFlowerPot extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.form.element{
    abstract class Element extends java.lang.Object{
    }
}
/**
 * @version 1.2.9.8
 */
declare namespace notemusic{
    /**
     * 获取红石音乐歌曲对象的标题
     * @param {com.xxmicloxx.NoteBlockAPI.Song} song 红石音乐歌曲对象
     */
    function getSongTitle(song: com.xxmicloxx.NoteBlockAPI.Song): java.lang.String;
    /**
     * 获取红石音乐喇叭播放的红石音乐歌曲
     * @param {com.xxmicloxx.NoteBlockAPI.HornSongPlayer} radioSongPlayer 红石音乐喇叭对象
     */
    function getSongInHorn(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.HornSongPlayer): com.xxmicloxx.NoteBlockAPI.Song;
    /**
     * 将玩家从红石音乐喇叭移除
     * @param {com.xxmicloxx.NoteBlockAPI.HornSongPlayer} SongPlayer 红石音乐喇叭对象
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function removePlayerToHorn(SongPlayer: com.xxmicloxx.NoteBlockAPI.HornSongPlayer,player: cn.nukkit.Player): void;
    /**
     * 构建红石音乐喇叭，在喇叭中的玩家都能听到，而且音量随距离衰减
     * @param {com.xxmicloxx.NoteBlockAPI.Song} song 红石音乐歌曲对象
     * @param {cn.nukkit.level.Position} pos 喇叭坐标
     * @param {boolean} isloop 是否循环播放
     * @param {boolean} isautodestroy 播放完毕后是否自动销毁喇叭
     */
    function buildHorn(song: com.xxmicloxx.NoteBlockAPI.Song,pos: cn.nukkit.level.Position,isloop: boolean,isautodestroy: boolean): com.xxmicloxx.NoteBlockAPI.HornSongPlayer;
    /**
     * 将玩家从电台中移除
     * @param {com.xxmicloxx.NoteBlockAPI.RadioSongPlayer} radioSongPlayer 红石音乐电台对象
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function removePlayerToRadio(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.RadioSongPlayer,player: cn.nukkit.Player): void;
    /**
     * 获取红石音乐歌曲对象的作者
     * @param {com.xxmicloxx.NoteBlockAPI.Song} song 红石音乐歌曲对象
     */
    function getSongAuthor(song: com.xxmicloxx.NoteBlockAPI.Song): java.lang.String;
    /**
     * 获取电台中的所有玩家的玩家名
     * @param {com.xxmicloxx.NoteBlockAPI.RadioSongPlayer} radioSongPlayer 红石音乐电台对象
     */
    function getPlayerInRadio(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.RadioSongPlayer): java.util.List;
    /**
     * 获取红石音乐喇叭中的所有玩家的玩家名
     * @param {com.xxmicloxx.NoteBlockAPI.HornSongPlayer} radioSongPlayer 红石音乐喇叭对象
     */
    function getPlayerInHorn(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.HornSongPlayer): java.util.List;
    /**
     * 设置电台播放状态
     * @param {com.xxmicloxx.NoteBlockAPI.RadioSongPlayer} radioSongPlayer 红石音乐电台对象
     * @param {boolean} isplaying true:播放，false:暂停
     */
    function setRadioStatus(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.RadioSongPlayer,isplaying: boolean): void;
    /**
     * 获取红石音乐歌曲的长度
     * @param {com.xxmicloxx.NoteBlockAPI.Song} song 红石音乐歌曲对象
     */
    function getSongLength(song: com.xxmicloxx.NoteBlockAPI.Song): int;
    /**
     * 将玩家添加到红石音乐喇叭中
     * @param {com.xxmicloxx.NoteBlockAPI.HornSongPlayer} SongPlayer 红石音乐喇叭对象
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function addPlayerToHorn(SongPlayer: com.xxmicloxx.NoteBlockAPI.HornSongPlayer,player: cn.nukkit.Player): void;
    /**
     * 获取红石音乐歌曲对象的描述
     * @param {com.xxmicloxx.NoteBlockAPI.Song} song 红石音乐歌曲对象
     */
    function getSongDescription(song: com.xxmicloxx.NoteBlockAPI.Song): java.lang.String;
    /**
     * 获取电台正在播放的红石音乐歌曲对象
     * @param {com.xxmicloxx.NoteBlockAPI.RadioSongPlayer} radioSongPlayer 红石音乐电台对象
     */
    function getSongInRadio(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.RadioSongPlayer): com.xxmicloxx.NoteBlockAPI.Song;
    /**
     * 将玩家添加到电台中
     * @param {com.xxmicloxx.NoteBlockAPI.RadioSongPlayer} radioSongPlayer 红石音乐电台对象
     * @param {cn.nukkit.Player} player 玩家对象
     */
    function addPlayerToRadio(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.RadioSongPlayer,player: cn.nukkit.Player): void;
    /**
     * 从文件获取红石音乐歌曲对象
     * @param {java.lang.String} name 文件名(在./plugins/BlocklyNukkit/notemusic文件夹下)
     */
    function getSongFromFile(name: java.lang.String): com.xxmicloxx.NoteBlockAPI.Song;
    /**
     * 
     */
    function toString(): java.lang.String;
    /**
     * 设置红石音乐喇叭的播放状态
     * @param {com.xxmicloxx.NoteBlockAPI.HornSongPlayer} radioSongPlayer 红石音乐喇叭对象
     * @param {boolean} isplaying true:播放，false:暂停
     */
    function setHornStatus(radioSongPlayer: com.xxmicloxx.NoteBlockAPI.HornSongPlayer,isplaying: boolean): void;
    /**
     * 构建红石音乐电台，电台中的所有玩家都将听到
     * @param {com.xxmicloxx.NoteBlockAPI.Song} song 红石音乐歌曲对象
     * @param {boolean} isloop 是否循环播放
     * @param {boolean} isautodestroy 是否播放完自动销毁电台
     */
    function buildRadio(song: com.xxmicloxx.NoteBlockAPI.Song,isloop: boolean,isautodestroy: boolean): com.xxmicloxx.NoteBlockAPI.RadioSongPlayer;
}
declare namespace cn.nukkit.entity.passive{
     class EntityCat extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerToggleGlideEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        isGliding: boolean;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public isGliding(): boolean;
    }
}
declare namespace cn.nukkit.level{
     class Level extends java.lang.Object{
        /**  */
        BLOCK_UPDATE_TOUCH: int;
        /**  */
        temporalPosition: cn.nukkit.level.Position;
        /**  */
        COMPRESSION_LEVEL: int;
        /**  */
        generatorClass: java.lang.Class;
        /**  */
        chunkPopulationQueue: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        useSections: boolean;
        /**  */
        autoSave: boolean;
        /**  */
        normalUpdateQueue: java.util.Queue;
        /**  */
        chunkLoaderCounter: int;
        /**  */
        chunkSendQueue: java.util.concurrent.ConcurrentMap;
        /**  */
        blockMetadata: cn.nukkit.metadata.BlockMetadataStore;
        /**  */
        lastUnloadIndex: int;
        /**  */
        tickRateCounter: int;
        /**  */
        BLOCK_UPDATE_TICK: int;
        /**  */
        ENTITY_BUFFER: cn.nukkit.entity.Entity[];
        /**  */
        TIME_NOON: int;
        /**  */
        updateBlockEntities: java.util.concurrent.ConcurrentLinkedQueue;
        /**  */
        updateLCG: int;
        /**  */
        levelId: int;
        /**  */
        cacheChunks: boolean;
        /**  */
        levelIdCounter: int;
        /**  */
        randomTickBlocks: boolean[];
        /**  */
        temporalVector: cn.nukkit.math.Vector3;
        /**  */
        players: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        chunkTickList: it.unimi.dsi.fastutil.longs.Long2IntMap;
        /**  */
        sleepTicks: int;
        /**  */
        thundering: boolean;
        /**  */
        levelCurrentTick: long;
        /**  */
        playerLoaders: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        chunkPopulationQueueSize: int;
        /**  */
        DIMENSION_NETHER: int;
        /**  */
        BLOCK_UPDATE_RANDOM: int;
        /**  */
        DIMENSION_OVERWORLD: int;
        /**  */
        BLOCK_UPDATE_REDSTONE: int;
        /**  */
        updateEntities: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        generators: cn.nukkit.utils.IterableThreadLocal;
        /**  */
        BLOCK_UPDATE_SCHEDULED: int;
        /**  */
        folderName: java.lang.String;
        /**  */
        blockEntities: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        TIME_SUNRISE: int;
        /**  */
        changeBlocksPresent: java.lang.Object;
        /**  */
        server: cn.nukkit.Server;
        /**  */
        chunkGenerationQueueSize: int;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        EMPTY_ARRAY: cn.nukkit.level.Level[];
        /**  */
        TIME_FULL: int;
        /**  */
        updateQueue: cn.nukkit.scheduler.BlockUpdateScheduler;
        /**  */
        chunkGenerationQueue: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        raining: boolean;
        /**  */
        skyLightSubtracted: float;
        /**  */
        BLOCK_UPDATE_NORMAL: int;
        /**  */
        BLOCK_UPDATE_WEAK: int;
        /**  */
        loaders: it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
        /**  */
        gameRules: cn.nukkit.level.GameRules;
        /**  */
        loaderCounter: it.unimi.dsi.fastutil.ints.Int2IntMap;
        /**  */
        changeBlocksFullMap: java.util.Map;
        /**  */
        clearChunksOnTick: boolean;
        /**  */
        provider: cn.nukkit.level.format.LevelProvider;
        /**  */
        lightQueue: java.util.Map;
        /**  */
        timings: cn.nukkit.timings.LevelTimings;
        /**  */
        tickRateTime: int;
        /**  */
        stopTime: boolean;
        /**  */
        dimension: int;
        /**  */
        nextTimeSendTick: int;
        /**  */
        MAX_BLOCK_CACHE: int;
        /**  */
        chunkPopulationLock: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        rainTime: int;
        /**  */
        thunderTime: int;
        /**  */
        mutableBlock: cn.nukkit.math.Vector3;
        /**  */
        chunkLoaders: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        TIME_NIGHT: int;
        /**  */
        TIME_DAY: int;
        /**  */
        tickRate: int;
        /**  */
        chunksPerTicks: int;
        /**  */
        TIME_SUNSET: int;
        /**  */
        unloadQueue: it.unimi.dsi.fastutil.longs.Long2LongMap;
        /**  */
        chunkPackets: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        chunkTickRadius: int;
        /**  */
        chunkSendTasks: it.unimi.dsi.fastutil.longs.LongSet;
        /**  */
        entities: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**  */
        BLOCK_UPDATE_MOVED: int;
        /**  */
        DIMENSION_THE_END: int;
        /**  */
        LCG_CONSTANT: int;
        /**  */
        TIME_MIDNIGHT: int;
        /**  */
        time: float;
        /**  */
        changedBlocks: it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
        /**
         * 
         * @param {long} i 
         */
        private static lambda$addChunkPacket$4(i: long): java.util.Deque;
        /**
         * 
         * @param {int} blockId 
         */
        public static canRandomTick(blockId: int): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.ParticleEffect} particleEffect 
         * @param {long} uniqueEntityId 
         * @param {int} dimensionId 
         * @param {cn.nukkit.Player[]} players 
         */
        public  addParticleEffect(pos: cn.nukkit.math.Vector3,particleEffect: cn.nukkit.level.ParticleEffect,uniqueEntityId: long,dimensionId: int,...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.ParticleEffect} particleEffect 
         */
        public addParticleEffect(pos: cn.nukkit.math.Vector3,particleEffect: cn.nukkit.level.ParticleEffect): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.ParticleEffect} particleEffect 
         * @param {long} uniqueEntityId 
         * @param {int} dimensionId 
         */
        public addParticleEffect(pos: cn.nukkit.math.Vector3,particleEffect: cn.nukkit.level.ParticleEffect,uniqueEntityId: long,dimensionId: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.ParticleEffect} particleEffect 
         * @param {long} uniqueEntityId 
         * @param {int} dimensionId 
         * @param {java.util.Collection} players 
         */
        public addParticleEffect(pos: cn.nukkit.math.Vector3,particleEffect: cn.nukkit.level.ParticleEffect,uniqueEntityId: long,dimensionId: int,players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.ParticleEffect} particleEffect 
         * @param {long} uniqueEntityId 
         */
        public addParticleEffect(pos: cn.nukkit.math.Vector3,particleEffect: cn.nukkit.level.ParticleEffect,uniqueEntityId: long): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} pos 
         * @param {java.lang.String} identifier 
         * @param {long} uniqueEntityId 
         * @param {int} dimensionId 
         * @param {cn.nukkit.Player[]} players 
         */
        public  addParticleEffect(pos: cn.nukkit.math.Vector3f,identifier: java.lang.String,uniqueEntityId: long,dimensionId: int,...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public getChunkBlockEntities(X: int,Z: int): java.util.Map;
        /**
         * 
         * @param {long} index 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} generate 
         */
        private  forceLoadChunk(index: long,x: int,z: int,generate: boolean): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public isDaytime(): boolean;
        /**
         * 
         * @param {boolean} autoSave 
         */
        public setAutoSave(autoSave: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public  setBlockExtraDataAt(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         * @param {int} time 
         * @param {float} tickDiff 
         */
        public calculateCelestialAngle(time: int,tickDiff: float): float;
        /**
         * 
         * @param {int} time 
         */
        public setTime(time: int): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public doTick(currentTick: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public updateAllLight(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public adjustPosToNearbyEntity(pos: cn.nukkit.math.Vector3): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public unloadChunks(): void;
        /**
         * 
         * @param {long} now 
         * @param {long} allocatedTime 
         * @param {boolean} force 
         */
        private unloadChunks(now: long,allocatedTime: long,force: boolean): boolean;
        /**
         * 
         * @param {boolean} force 
         */
        public unloadChunks(force: boolean): void;
        /**
         * 
         * @param {int} maxUnload 
         * @param {boolean} force 
         */
        public unloadChunks(maxUnload: int,force: boolean): void;
        /**
         * 
         */
        public getCurrentTick(): long;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public  sendTime(...players: cn.nukkit.Player[]): void;
        /**
         * 
         */
        public sendTime(): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public addEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {float} tickDiff 
         */
        public getCelestialAngle(tickDiff: float): float;
        /**
         * 
         */
        public checkTime(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public isBlockIndirectlyGettingPowered(pos: cn.nukkit.math.Vector3): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private queueUnloadChunk(x: int,z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getMapColorAt(x: int,z: int): cn.nukkit.utils.BlockColor;
        /**
         * 
         * @param {boolean} thundering 
         */
        public setThundering(thundering: boolean): boolean;
        /**
         * 
         */
        public isRaining(): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public regenerateChunk(x: int,z: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {int} exp 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {int} delay 
         */
        public dropExpOrb(source: cn.nukkit.math.Vector3,exp: int,motion: cn.nukkit.math.Vector3,delay: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {int} exp 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public dropExpOrb(source: cn.nukkit.math.Vector3,exp: int,motion: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {int} exp 
         */
        public dropExpOrb(source: cn.nukkit.math.Vector3,exp: int): void;
        /**
         * 
         */
        public getTickRateTime(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public addLightUpdate(x: int,y: int,z: int): void;
        /**
         * 
         * @param {long} allocatedTime 
         */
        public doGarbageCollection(allocatedTime: long): void;
        /**
         * 
         * @param {boolean} raining 
         */
        public setRaining(raining: boolean): boolean;
        /**
         * 
         */
        private tickChunks(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         */
        public isUpdateScheduled(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public saveChunks(): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} target 
         * @param {cn.nukkit.math.Vector3[]} blocks 
         * @param {int} flags 
         * @param {boolean} optimizeRebuilds 
         */
        public sendBlocks(target: cn.nukkit.Player[],blocks: cn.nukkit.math.Vector3[],flags: int,optimizeRebuilds: boolean): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} target 
         * @param {cn.nukkit.math.Vector3[]} blocks 
         */
        public sendBlocks(target: cn.nukkit.Player[],blocks: cn.nukkit.math.Vector3[]): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} target 
         * @param {cn.nukkit.math.Vector3[]} blocks 
         * @param {int} flags 
         */
        public sendBlocks(target: cn.nukkit.Player[],blocks: cn.nukkit.math.Vector3[],flags: int): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} target 
         * @param {cn.nukkit.math.Vector3[]} blocks 
         * @param {int} flags 
         * @param {int} dataLayer 
         */
        public sendBlocks(target: cn.nukkit.Player[],blocks: cn.nukkit.math.Vector3[],flags: int,dataLayer: int): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} target 
         * @param {cn.nukkit.math.Vector3[]} blocks 
         * @param {int} flags 
         * @param {int} dataLayer 
         * @param {boolean} optimizeRebuilds 
         */
        public sendBlocks(target: cn.nukkit.Player[],blocks: cn.nukkit.math.Vector3[],flags: int,dataLayer: int,optimizeRebuilds: boolean): void;
        /**
         * 
         */
        public getSafeSpawn(): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} spawn 
         */
        public getSafeSpawn(spawn: cn.nukkit.math.Vector3): cn.nukkit.level.Position;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public loadChunk(x: int,z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} generate 
         */
        public loadChunk(x: int,z: int,generate: boolean): boolean;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        public addChunkPacket(chunkX: int,chunkZ: int,packet: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public setMetadata(metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,player: cn.nukkit.Player): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.item.Item} item 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {int} layer 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} createParticles 
         * @param {boolean} setBlockDestroy 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3,layer: int,face: cn.nukkit.math.BlockFace,item: cn.nukkit.item.Item,player: cn.nukkit.Player,createParticles: boolean,setBlockDestroy: boolean): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} createParticles 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace,item: cn.nukkit.item.Item,player: cn.nukkit.Player,createParticles: boolean): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} createParticles 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,player: cn.nukkit.Player,createParticles: boolean): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} createParticles 
         * @param {boolean} setBlockDestroy 
         */
        public useBreakOn(vector: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace,item: cn.nukkit.item.Item,player: cn.nukkit.Player,createParticles: boolean,setBlockDestroy: boolean): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} rainTime 
         */
        public setRainTime(rainTime: int): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         * @param {java.util.Collection} players 
         */
        public sendWeather(players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public sendWeather(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public sendWeather(players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         */
        public updateComparatorOutputLevel(v: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public getCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.entity.Entity[];
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getCollidingEntities(bb: cn.nukkit.math.AxisAlignedBB,entity: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} entities 
         */
        public hasCollision(entity: cn.nukkit.entity.Entity,bb: cn.nukkit.math.AxisAlignedBB,entities: boolean): boolean;
        /**
         * 
         * @param {int} thunderTime 
         */
        public setThunderTime(thunderTime: int): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} entities 
         */
        public getCollisionCubes(entity: cn.nukkit.entity.Entity,bb: cn.nukkit.math.AxisAlignedBB,entities: boolean): cn.nukkit.math.AxisAlignedBB[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} entities 
         * @param {boolean} solidEntities 
         */
        public getCollisionCubes(entity: cn.nukkit.entity.Entity,bb: cn.nukkit.math.AxisAlignedBB,entities: boolean,solidEntities: boolean): cn.nukkit.math.AxisAlignedBB[];
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public getCollisionCubes(entity: cn.nukkit.entity.Entity,bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.math.AxisAlignedBB[];
        /**
         * 
         * @param {int} blockId 
         * @param {boolean} newValue 
         */
        public static setCanRandomTick(blockId: int,newValue: boolean): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {float} tickDiff 
         */
        public getThunderStrength(tickDiff: float): float;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunkIfLoaded(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public getBlockMetadata(): cn.nukkit.metadata.BlockMetadataStore;
        /**
         * 
         */
        public getBlockEntities(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.level.particle.Particle} particle 
         * @param {cn.nukkit.Player[]} players 
         */
        public addParticle(particle: cn.nukkit.level.particle.Particle,players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.level.particle.Particle} particle 
         * @param {cn.nukkit.Player} player 
         */
        public addParticle(particle: cn.nukkit.level.particle.Particle,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.level.particle.Particle} particle 
         */
        public addParticle(particle: cn.nukkit.level.particle.Particle): void;
        /**
         * 
         * @param {cn.nukkit.level.particle.Particle} particle 
         * @param {java.util.Collection} players 
         */
        public addParticle(particle: cn.nukkit.level.particle.Particle,players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {boolean} dropAround 
         * @param {int} delay 
         */
        public dropItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,motion: cn.nukkit.math.Vector3,dropAround: boolean,delay: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         */
        public dropItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public dropItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,motion: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {int} delay 
         */
        public dropItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,motion: cn.nukkit.math.Vector3,delay: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} safe 
         */
        public unloadChunkRequest(x: int,z: int,safe: boolean): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public unloadChunkRequest(x: int,z: int): boolean;
        /**
         * 
         */
        public getGenerator(): cn.nukkit.level.generator.Generator;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public getNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.entity.Entity[];
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB,entity: cn.nukkit.entity.Entity): cn.nukkit.entity.Entity[];
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {boolean} loadChunks 
         */
        public getNearbyEntities(bb: cn.nukkit.math.AxisAlignedBB,entity: cn.nukkit.entity.Entity,loadChunks: boolean): cn.nukkit.entity.Entity[];
        /**
         * 
         */
        public getThunderTime(): int;
        /**
         * 
         */
        public getDimension(): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public  setBlockLightAt(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {double} headYaw 
         */
        public addPlayerMovement(entity: cn.nukkit.entity.Entity,x: double,y: double,z: double,yaw: double,pitch: double,headYaw: double): void;
        /**
         * 
         * @param {int} tickRate 
         */
        public setTickRate(tickRate: int): void;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} entity 
         */
        public removeBlockEntity(entity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkLoader} loader 
         */
        public static generateChunkLoaderId(loader: cn.nukkit.level.ChunkLoader): int;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} delay 
         * @param {int} priority 
         */
        public scheduleUpdate(block: cn.nukkit.block.Block,pos: cn.nukkit.math.Vector3,delay: int,priority: int): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} delay 
         * @param {int} priority 
         * @param {boolean} checkArea 
         */
        public scheduleUpdate(block: cn.nukkit.block.Block,pos: cn.nukkit.math.Vector3,delay: int,priority: int,checkArea: boolean): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} delay 
         */
        public scheduleUpdate(block: cn.nukkit.block.Block,pos: cn.nukkit.math.Vector3,delay: int): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} pos 
         * @param {int} delay 
         */
        public scheduleUpdate(pos: cn.nukkit.block.Block,delay: int): void;
        /**
         * 
         * @param {int} index 
         * @param {java.util.ArrayList} overflow 
         */
        private getEntitiesFromBuffer(index: int,overflow: java.util.ArrayList): cn.nukkit.entity.Entity[];
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        private static lambda$getCollisionBlocks$9(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} target 
         */
        public createPortal(target: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} currentLight 
         * @param {java.util.Queue} queue 
         * @param {java.util.Queue} spreadQueue 
         * @param {java.util.Map} visited 
         * @param {java.util.Map} spreadVisited 
         */
        private computeRemoveBlockLight(x: int,y: int,z: int,currentLight: int,queue: java.util.Queue,spreadQueue: java.util.Queue,visited: java.util.Map,spreadVisited: java.util.Map): void;
        /**
         * 
         */
        public getUpdateLCG(): int;
        /**
         * 
         * @param {float} tickDiff 
         */
        public getRainStrength(tickDiff: float): float;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} v 
         * @param {boolean} observer 
         */
        public updateComparatorOutputLevelSelective(v: cn.nukkit.math.Vector3,observer: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public static blockHash(x: int,y: int,z: int): long;
        /**
         * 
         */
        public checkSleep(): void;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} min 
         * @param {cn.nukkit.math.BlockVector3} max 
         * @param {java.util.function.BiPredicate} condition 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        private static lambda$scanBlocks$8(min: cn.nukkit.math.BlockVector3,max: cn.nukkit.math.BlockVector3,condition: java.util.function.BiPredicate,chunk: cn.nukkit.level.format.generic.BaseFullChunk): java.util.stream.Stream;
        /**
         * 
         */
        public getFuzzySpawnLocation(): cn.nukkit.level.Position;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public  getBlockDataAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockDataAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.math.ChunkVector2} minChunk 
         * @param {cn.nukkit.math.ChunkVector2} maxChunk 
         * @param {int} x 
         */
        private static lambda$scanBlocks$7(minChunk: cn.nukkit.math.ChunkVector2,maxChunk: cn.nukkit.math.ChunkVector2,x: int): java.util.stream.Stream;
        /**
         * 
         */
        public getTime(): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public canBlockSeeSky(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {long} timestamp 
         * @param {int} x 
         * @param {int} z 
         * @param {int} subChunkCount 
         * @param {byte[]} payload 
         */
        public chunkRequestCallback(timestamp: long,x: int,z: int,subChunkCount: int,payload: byte[]): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getBiomeId(x: int,z: int): int;
        /**
         * 
         */
        public  getId(): int;
        /**
         * 
         */
        public  requireProvider(): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getHeightMap(x: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockStateAt(x: int,y: int,z: int,layer: int): cn.nukkit.blockstate.BlockState;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public isChunkPopulated(x: int,z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public getHighestBlockAt(x: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {int} exp 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {int} delay 
         */
        public dropExpOrbAndGetEntities(source: cn.nukkit.math.Vector3,exp: int,motion: cn.nukkit.math.Vector3,delay: int): java.util.List;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {int} exp 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public dropExpOrbAndGetEntities(source: cn.nukkit.math.Vector3,exp: int,motion: cn.nukkit.math.Vector3): java.util.List;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {int} exp 
         */
        public dropExpOrbAndGetEntities(source: cn.nukkit.math.Vector3,exp: int): java.util.List;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} blockEntity 
         */
        private static lambda$doTick$5(blockEntity: cn.nukkit.blockentity.BlockEntity): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public updateAround(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public updateAround(x: int,y: int,z: int): void;
        /**
         * 
         */
        public getAutoSave(): boolean;
        /**
         * 
         */
        public getTickRate(): int;
        /**
         * 
         * @param {java.lang.Class} provider 
         */
        private static lambda$new$0(provider: java.lang.Class): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public updateBlockSkyLight(x: int,y: int,z: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {boolean} load 
         */
        public  getBlock(pos: cn.nukkit.math.Vector3,load: boolean): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} layer 
         */
        public  getBlock(pos: cn.nukkit.math.Vector3,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public  getBlock(pos: cn.nukkit.math.Vector3): cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} layer 
         * @param {boolean} load 
         */
        public  getBlock(pos: cn.nukkit.math.Vector3,layer: int,load: boolean): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {boolean} load 
         */
        public  getBlock(x: int,y: int,z: int,layer: int,load: boolean): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public  getBlock(x: int,y: int,z: int,layer: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public  getBlock(x: int,y: int,z: int): cn.nukkit.block.Block;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {boolean} load 
         */
        public  getBlock(x: int,y: int,z: int,load: boolean): cn.nukkit.block.Block;
        /**
         * 
         * @param {long} hash 
         */
        private areNeighboringChunksLoaded(hash: long): boolean;
        /**
         * 
         * @param {long} blockEntityId 
         */
        public getBlockEntityById(blockEntityId: long): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} blockEntity 
         */
        public addBlockEntity(blockEntity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunkLoaders(chunkX: int,chunkZ: int): cn.nukkit.level.ChunkLoader[];
        /**
         * 
         * @param {int} type 
         * @param {int} data 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public addLevelEvent(type: int,data: int,x: float,y: float,z: float): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} event 
         */
        public addLevelEvent(pos: cn.nukkit.math.Vector3,event: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} event 
         * @param {int} data 
         */
        public addLevelEvent(pos: cn.nukkit.math.Vector3,event: int,data: int): void;
        /**
         * 
         * @param {int} type 
         * @param {int} data 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public addLevelEvent(type: int,data: int,pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {int} type 
         * @param {int} data 
         */
        public addLevelEvent(type: int,data: int): void;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         * @param {boolean} loadChunks 
         */
        public getChunkEntities(X: int,Z: int,loadChunks: boolean): java.util.Map;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public getChunkEntities(X: int,Z: int): java.util.Map;
        /**
         * 
         */
        public getFolderName(): java.lang.String;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} fullId 
         */
        public  setBlockFullIdAt(x: int,y: int,z: int,layer: int,fullId: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} fullId 
         */
        public  setBlockFullIdAt(x: int,y: int,z: int,fullId: int): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunk(chunkX: int,chunkZ: int): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {boolean} create 
         */
        public getChunk(chunkX: int,chunkZ: int,create: boolean): cn.nukkit.level.format.generic.BaseFullChunk;
        /**
         * 
         */
        public isThundering(): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public isSidePowered(pos: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public  getBlockSkyLightAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntity} entity 
         */
        public scheduleBlockEntityUpdate(entity: cn.nukkit.blockentity.BlockEntity): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private addBlockChange(x: int,y: int,z: int): void;
        /**
         * 
         * @param {long} index 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        private addBlockChange(index: long,x: int,y: int,z: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         * @param {int} data 
         */
        public  setBlockAtLayer(x: int,y: int,z: int,layer: int,id: int,data: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} data 
         */
        public  setBlockDataAt(x: int,y: int,z: int,layer: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} data 
         */
        public setBlockDataAt(x: int,y: int,z: int,data: int): void;
        /**
         * 
         * @param {cn.nukkit.level.format.LevelProvider} provider 
         * @param {cn.nukkit.level.Level} lvl 
         * @param {java.lang.String} p 
         */
        private static lambda$new$3(provider: cn.nukkit.level.format.LevelProvider,lvl: cn.nukkit.level.Level,p: java.lang.String): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         * @param {boolean} usesChunkSection 
         */
        private static lambda$new$2(usesChunkSection: boolean): boolean;
        /**
         * 
         * @param {java.lang.Class} provider 
         * @param {cn.nukkit.level.Level} level 
         * @param {java.lang.String} levelPath 
         */
        private static lambda$new$1(provider: java.lang.Class,level: cn.nukkit.level.Level,levelPath: java.lang.String): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.Player} player 
         */
        public requestChunk(x: int,z: int,player: cn.nukkit.Player): void;
        /**
         * 
         * @param {long} hash 
         */
        public cancelUnloadChunkRequest(hash: long): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public cancelUnloadChunkRequest(x: int,z: int): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {double} headYaw 
         */
        public addEntityMovement(entity: cn.nukkit.entity.Entity,x: double,y: double,z: double,yaw: double,pitch: double,headYaw: double): void;
        /**
         * 
         * @param {long} hash 
         */
        public static getChunkXZ(hash: long): cn.nukkit.level.format.Chunk.Entry;
        /**
         * 
         */
        public getGameRules(): cn.nukkit.level.GameRules;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        private static lambda$null$6(x: int,z: int): cn.nukkit.math.ChunkVector2;
        /**
         * 
         * @param {long} worldTime 
         */
        public getMoonPhase(worldTime: long): int;
        /**
         * 
         * @param {float} tickDiff 
         */
        public calculateSkylightSubtracted(tickDiff: float): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public populateChunk(x: int,z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} force 
         */
        public populateChunk(x: int,z: int,force: boolean): boolean;
        /**
         * 
         */
        public unload(): boolean;
        /**
         * 
         * @param {boolean} force 
         */
        public unload(force: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         */
        public isBlockTickPending(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {java.util.function.BiPredicate} condition 
         */
        public scanBlocks(bb: cn.nukkit.math.AxisAlignedBB,condition: java.util.function.BiPredicate): java.util.List;
        /**
         * 
         */
        public getPlayers(): java.util.Map;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         */
        public setBlockIdAt(x: int,y: int,z: int,id: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {int} id 
         */
        public  setBlockIdAt(x: int,y: int,z: int,layer: int,id: int): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} arg0 
         */
        static access$000(arg0: cn.nukkit.level.Level): java.lang.Class;
        /**
         * 
         * @param {java.util.Map} map 
         */
        public updateBlockLight(map: java.util.Map): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public  setBlockAt(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setSpawnLocation(pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public  getBlockLightAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} level 
         */
        public  setBlockSkyLightAt(x: int,y: int,z: int,level: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public isChunkLoaded(x: int,z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public isChunkGenerated(x: int,z: int): boolean;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        public static localBlockHash(x: double,y: double,z: double): char;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public getStrongPower(pos: cn.nukkit.math.Vector3): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} direction 
         */
        public getStrongPower(pos: cn.nukkit.math.Vector3,direction: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public isChunkInUse(x: int,z: int): boolean;
        /**
         * 
         * @param {long} hash 
         */
        public isChunkInUse(hash: long): boolean;
        /**
         * 
         * @param {int} X 
         * @param {int} Z 
         */
        public isSpawnChunk(X: int,Z: int): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getHighestAdjacentBlockSkyLight(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Sound} sound 
         * @param {float} volume 
         * @param {float} pitch 
         */
        public addSound(pos: cn.nukkit.math.Vector3,sound: cn.nukkit.level.Sound,volume: float,pitch: float): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Sound} sound 
         * @param {float} volume 
         * @param {float} pitch 
         * @param {java.util.Collection} players 
         */
        public addSound(pos: cn.nukkit.math.Vector3,sound: cn.nukkit.level.Sound,volume: float,pitch: float,players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Sound} sound 
         * @param {float} volume 
         * @param {float} pitch 
         * @param {cn.nukkit.Player[]} players 
         */
        public  addSound(pos: cn.nukkit.math.Vector3,sound: cn.nukkit.level.Sound,volume: float,pitch: float,...players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.level.Sound} sound 
         */
        public addSound(pos: cn.nukkit.math.Vector3,sound: cn.nukkit.level.Sound): void;
        /**
         * 
         * @param {boolean} force 
         */
        public save(force: boolean): boolean;
        /**
         * 
         */
        public save(): boolean;
        /**
         * 
         */
        public getRainTime(): int;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} boundingBox 
         */
        public getPendingBlockUpdates(boundingBox: cn.nukkit.math.AxisAlignedBB): java.util.Set;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        public getPendingBlockUpdates(chunk: cn.nukkit.level.format.FullChunk): java.util.Set;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockIdAt(x: int,y: int,z: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public  getBlockIdAt(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getFullBlock(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getFullBlock(x: int,y: int,z: int): int;
        /**
         * 
         */
        public getLoaders(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.level.ChunkLoader} loader 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {boolean} autoLoad 
         */
        public registerChunkLoader(loader: cn.nukkit.level.ChunkLoader,chunkX: int,chunkZ: int,autoLoad: boolean): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkLoader} loader 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public registerChunkLoader(loader: cn.nukkit.level.ChunkLoader,chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} currentLight 
         * @param {java.util.Queue} queue 
         * @param {java.util.Map} visited 
         */
        private computeSpreadBlockLight(x: int,y: int,z: int,currentLight: int,queue: java.util.Queue,visited: java.util.Map): void;
        /**
         * 
         */
        public startTime(): void;
        /**
         * 
         */
        public getSeed(): long;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         */
        public getBlockRuntimeId(x: int,y: int,z: int,layer: int): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public getBlockRuntimeId(x: int,y: int,z: int): int;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         */
        public cancelSheduledUpdate(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block): boolean;
        /**
         * 
         */
        public getChunks(): java.util.Map;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public hasMetadata(metadataKey: java.lang.String): boolean;
        /**
         * 
         * @param {long} entityId 
         */
        public getEntity(entityId: long): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public removeEntity(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public getFullLight(pos: cn.nukkit.math.Vector3): int;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public isAreaLoaded(bb: cn.nukkit.math.AxisAlignedBB): boolean;
        /**
         * 
         * @param {long} chunkHash 
         * @param {char} blockHash 
         */
        public static getBlockXYZ(chunkHash: long,blockHash: char): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} hash 
         */
        public static getBlockXYZ(hash: cn.nukkit.math.BlockVector3): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         */
        public  setBlock(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         */
        public  setBlock(pos: cn.nukkit.math.Vector3,layer: int,block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} direct 
         */
        public  setBlock(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block,direct: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} direct 
         * @param {boolean} update 
         */
        public  setBlock(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block,direct: boolean,update: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} direct 
         * @param {boolean} update 
         */
        public  setBlock(pos: cn.nukkit.math.Vector3,layer: int,block: cn.nukkit.block.Block,direct: boolean,update: boolean): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} direct 
         * @param {boolean} update 
         */
        public  setBlock(x: int,y: int,z: int,block: cn.nukkit.block.Block,direct: boolean,update: boolean): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} direct 
         * @param {boolean} update 
         */
        public  setBlock(x: int,y: int,z: int,layer: int,block: cn.nukkit.block.Block,direct: boolean,update: boolean): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} layer 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} direct 
         */
        public  setBlock(pos: cn.nukkit.math.Vector3,layer: int,block: cn.nukkit.block.Block,direct: boolean): boolean;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public getChunkPlayers(chunkX: int,chunkZ: int): java.util.Map;
        /**
         * 
         * @param {long} index 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        private performThunder(index: long,chunk: cn.nukkit.level.format.FullChunk): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} layer 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        public  setBlockStateAt(x: int,y: int,z: int,layer: int,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public getRedstonePower(pos: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace): int;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         */
        public sendBlockExtraData(x: int,y: int,z: int,id: int,data: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         * @param {cn.nukkit.Player[]} players 
         */
        public sendBlockExtraData(x: int,y: int,z: int,id: int,data: int,players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {int} data 
         * @param {java.util.Collection} players 
         */
        public sendBlockExtraData(x: int,y: int,z: int,id: int,data: int,players: java.util.Collection): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public isFullBlock(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public  getProvider(): cn.nukkit.level.format.LevelProvider;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public getBlockEntityIfLoaded(pos: cn.nukkit.math.Vector3): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         * @param {int} index 
         * @param {java.util.ArrayList} overflow 
         * @param {cn.nukkit.entity.Entity} ent 
         */
        private addEntityToBuffer(index: int,overflow: java.util.ArrayList,ent: cn.nukkit.entity.Entity): java.util.ArrayList;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} force 
         */
        public generateChunk(x: int,z: int,force: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public generateChunk(x: int,z: int): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public getMetadata(metadataKey: java.lang.String): java.util.List;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.BlockFace} face 
         */
        public updateAroundRedstone(pos: cn.nukkit.math.Vector3,face: cn.nukkit.math.BlockFace): void;
        /**
         * 
         */
        public getEntities(): cn.nukkit.entity.Entity[];
        /**
         * 
         * @param {int} seed 
         */
        public setSeed(seed: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} type 
         * @param {int} data 
         * @param {int} entityType 
         * @param {boolean} isBaby 
         * @param {boolean} isGlobal 
         */
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3,type: int,data: int,entityType: int,isBaby: boolean,isGlobal: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} type 
         */
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3,type: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} type 
         * @param {int} data 
         */
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3,type: int,data: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} type 
         * @param {int} data 
         * @param {java.lang.String} identifier 
         * @param {boolean} isBaby 
         * @param {boolean} isGlobal 
         */
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3,type: int,data: int,identifier: java.lang.String,isBaby: boolean,isGlobal: boolean): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} type 
         * @param {int} data 
         * @param {int} entityType 
         */
        public addLevelSoundEvent(pos: cn.nukkit.math.Vector3,type: int,data: int,entityType: int): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public isBlockPowered(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {long} index 
         * @param {cn.nukkit.network.protocol.DataPacket} packet 
         */
        private sendChunk(x: int,z: int,index: long,packet: cn.nukkit.network.protocol.DataPacket): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {byte} biomeId 
         */
        public setBiomeId(x: int,z: int,biomeId: byte): void;
        /**
         * 
         */
        public initLevel(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public getBlockEntity(pos: cn.nukkit.math.Vector3): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} pos 
         */
        public getBlockEntity(pos: cn.nukkit.math.BlockVector3): cn.nukkit.blockentity.BlockEntity;
        /**
         * 
         */
        public getSpawnLocation(): cn.nukkit.level.Position;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {int} delay 
         */
        public dropAndGetItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,motion: cn.nukkit.math.Vector3,delay: int): cn.nukkit.entity.item.EntityItem;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public dropAndGetItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,motion: cn.nukkit.math.Vector3): cn.nukkit.entity.item.EntityItem;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         */
        public dropAndGetItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item): cn.nukkit.entity.item.EntityItem;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} source 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {boolean} dropAround 
         * @param {int} delay 
         */
        public dropAndGetItem(source: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,motion: cn.nukkit.math.Vector3,dropAround: boolean,delay: int): cn.nukkit.entity.item.EntityItem;
        /**
         * 
         * @param {long} hash 
         */
        public static getHashX(hash: long): int;
        /**
         * 
         * @param {long} hash 
         */
        public static getHashZ(hash: long): int;
        /**
         * 
         * @param {cn.nukkit.level.ChunkLoader} loader 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public unregisterChunkLoader(loader: cn.nukkit.level.ChunkLoader,chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public  getBlockExtraDataAt(x: int,y: int,z: int): int;
        /**
         * 
         */
        private processChunkRequest(): void;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         */
        public static chunkBlockHash(x: int,y: int,z: int): int;
        /**
         * 
         */
        public stopTime(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {float} fx 
         * @param {float} fy 
         * @param {float} fz 
         * @param {cn.nukkit.Player} player 
         * @param {boolean} playSound 
         */
        public useItemOn(vector: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,face: cn.nukkit.math.BlockFace,fx: float,fy: float,fz: float,player: cn.nukkit.Player,playSound: boolean): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {float} fx 
         * @param {float} fy 
         * @param {float} fz 
         * @param {cn.nukkit.Player} player 
         */
        public useItemOn(vector: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,face: cn.nukkit.math.BlockFace,fx: float,fy: float,fz: float,player: cn.nukkit.Player): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {float} fx 
         * @param {float} fy 
         * @param {float} fz 
         */
        public useItemOn(vector: cn.nukkit.math.Vector3,item: cn.nukkit.item.Item,face: cn.nukkit.math.BlockFace,fx: float,fy: float,fz: float): cn.nukkit.item.Item;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        public setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         * @param {boolean} unload 
         */
        public setChunk(chunkX: int,chunkZ: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk,unload: boolean): void;
        /**
         * 
         * @param {int} chunkX 
         * @param {int} chunkZ 
         */
        public setChunk(chunkX: int,chunkZ: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         * @param {boolean} isPopulated 
         */
        public generateChunkCallback(x: int,z: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk,isPopulated: boolean): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.level.format.generic.BaseFullChunk} chunk 
         */
        public generateChunkCallback(x: int,z: int,chunk: cn.nukkit.level.format.generic.BaseFullChunk): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} vector3 
         */
        public isInSpawnRadius(vector3: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         */
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB): cn.nukkit.block.Block[];
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} targetFirst 
         * @param {boolean} ignoreCollidesCheck 
         */
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB,targetFirst: boolean,ignoreCollidesCheck: boolean): cn.nukkit.block.Block[];
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} targetFirst 
         * @param {boolean} ignoreCollidesCheck 
         * @param {java.util.function.Predicate} condition 
         */
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB,targetFirst: boolean,ignoreCollidesCheck: boolean,condition: java.util.function.Predicate): cn.nukkit.block.Block[];
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} bb 
         * @param {boolean} targetFirst 
         */
        public getCollisionBlocks(bb: cn.nukkit.math.AxisAlignedBB,targetFirst: boolean): cn.nukkit.block.Block[];
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {int} value 
         */
        public setHeightMap(x: int,z: int,value: int): void;
        /**
         * 
         */
        public doChunkGarbageCollection(): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public removeMetadata(metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} safe 
         */
        public unloadChunk(x: int,z: int,safe: boolean): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {boolean} safe 
         * @param {boolean} trySave 
         */
        public  unloadChunk(x: int,z: int,safe: boolean,trySave: boolean): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public unloadChunk(x: int,z: int): boolean;
        /**
         * 
         * @param {long} k 
         */
        private static addBlockChange(k: long): java.lang.ref.SoftReference;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         */
        public static chunkHash(x: int,z: int): long;
    }
}
declare namespace cn.nukkit.level.generator.noise.nukkit.f{
     class SimplexF extends cn.nukkit.level.generator.noise.nukkit.f.PerlinF{
        /**  */
        G42: float;
        /**  */
        grad3: int[][];
        /**  */
        G22: float;
        /**  */
        G44: float;
        /**  */
        G43: float;
        /**  */
        SQRT_5: float;
        /**  */
        SQRT_3: float;
        /**  */
        G2: float;
        /**  */
        F2: float;
        /**  */
        G3: float;
        /**  */
        F3: float;
        /**  */
        G4: float;
        /**  */
        F4: float;
        /**  */
        offsetW: float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         */
        public getNoise2D(x: float,y: float): float;
        /**
         * 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        public getNoise3D(x: float,y: float,z: float): float;
        /**
         * 
         * @param {int[]} g 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         * @param {float} w 
         */
        protected static dot4D(g: int[],x: float,y: float,z: float,w: float): float;
        /**
         * 
         * @param {int[]} g 
         * @param {float} x 
         * @param {float} y 
         */
        protected static dot2D(g: int[],x: float,y: float): float;
        /**
         * 
         * @param {int[]} g 
         * @param {float} x 
         * @param {float} y 
         * @param {float} z 
         */
        protected static dot3D(g: int[],x: float,y: float,z: float): float;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class StringTag extends cn.nukkit.nbt.tag.Tag{
        /**  */
        data: java.lang.String;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         */
        public parseValue(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
    }
}
declare namespace cn.nukkit.plugin.service{
     class NKServiceManager extends java.lang.Object{
        /**  */
        handle: java.util.Map;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public cancel(plugin: cn.nukkit.plugin.Plugin): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         * @param {java.lang.Object} provider 
         */
        public cancel(service: java.lang.Class,provider: java.lang.Object): cn.nukkit.plugin.service.RegisteredServiceProvider;
        /**
         * 
         * @param {java.lang.Class} k 
         */
        private static lambda$provide$0(k: java.lang.Class): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         */
        public isProvidedFor(service: java.lang.Class): boolean;
        /**
         * 
         * @param {java.lang.Class} service 
         * @param {java.lang.Object} instance 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {cn.nukkit.plugin.service.ServicePriority} priority 
         */
        protected provide(service: java.lang.Class,instance: java.lang.Object,plugin: cn.nukkit.plugin.Plugin,priority: cn.nukkit.plugin.service.ServicePriority): boolean;
        /**
         * 
         */
        public getKnownService(): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         */
        public getProvider(service: java.lang.Class): cn.nukkit.plugin.service.RegisteredServiceProvider;
        /**
         * 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         */
        public getRegistrations(plugin: cn.nukkit.plugin.Plugin): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         */
        public getRegistrations(service: java.lang.Class): java.util.List;
        /**
         * 
         * @param {java.lang.Class} service 
         * @param {java.lang.Object} provider 
         * @param {cn.nukkit.plugin.Plugin} plugin 
         * @param {cn.nukkit.plugin.service.ServicePriority} priority 
         */
        public register(service: java.lang.Class,provider: java.lang.Object,plugin: cn.nukkit.plugin.Plugin,priority: cn.nukkit.plugin.service.ServicePriority): boolean;
    }
}
declare namespace cn.nukkit.event.vehicle{
    abstract class VehicleEvent extends cn.nukkit.event.Event{
        /**  */
        vehicle: cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getVehicle(): cn.nukkit.entity.Entity;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityRideable extends java.lang.Object{
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public abstract mountEntity(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public abstract dismountEntity(entity: cn.nukkit.entity.Entity): boolean;
    }
}
declare namespace cn.nukkit.scheduler{
     class BlockUpdateScheduler extends java.lang.Object{
        /**  */
        lastTick: long;
        /**  */
        queuedUpdates: java.util.Map;
        /**  */
        level: cn.nukkit.level.Level;
        /**  */
        pendingUpdates: java.util.Set;
        /**
         * 
         * @param {cn.nukkit.utils.BlockUpdateEntry} entry 
         */
        public add(entry: cn.nukkit.utils.BlockUpdateEntry): void;
        /**
         * 
         * @param {cn.nukkit.utils.BlockUpdateEntry} entry 
         */
        public contains(entry: cn.nukkit.utils.BlockUpdateEntry): boolean;
        /**
         * 
         * @param {long} tick 
         */
        private perform(tick: long): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.block.Block} block 
         */
        public isBlockTickPending(pos: cn.nukkit.math.Vector3,block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.math.AxisAlignedBB} boundingBox 
         */
        public getPendingBlockUpdates(boundingBox: cn.nukkit.math.AxisAlignedBB): java.util.Set;
        /**
         * 
         * @param {long} currentTick 
         */
        public  tick(currentTick: long): void;
        /**
         * 
         * @param {cn.nukkit.utils.BlockUpdateEntry} entry 
         */
        public remove(entry: cn.nukkit.utils.BlockUpdateEntry): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public remove(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.utils.BlockUpdateEntry} entry 
         */
        private getMinTime(entry: cn.nukkit.utils.BlockUpdateEntry): long;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityLlama extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getEyeHeight(): float;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.item{
     class ItemNetherWart extends cn.nukkit.item.Item{
        /**
         * 
         * @param {java.lang.Integer} meta 
         */
        public setDamage(meta: java.lang.Integer): void;
    }
}
declare namespace cn.nukkit.potion{
     class Potion extends java.lang.Object{
        /**  */
        NIGHT_VISION_LONG: int;
        /**  */
        SLOW_FALLING: int;
        /**  */
        INVISIBLE_LONG: int;
        /**  */
        LEAPING: int;
        /**  */
        WEAKNESS: int;
        /**  */
        SLOWNESS_LONG_II: int;
        /**  */
        LEAPING_LONG: int;
        /**  */
        MUNDANE_II: int;
        /**  */
        REGENERATION_LONG: int;
        /**  */
        SPEED: int;
        /**  */
        POISON_II: int;
        /**  */
        FIRE_RESISTANCE: int;
        /**  */
        id: int;
        /**  */
        HARMING: int;
        /**  */
        WATER: int;
        /**  */
        REGENERATION_II: int;
        /**  */
        TURTLE_MASTER: int;
        /**  */
        level: int;
        /**  */
        REGENERATION: int;
        /**  */
        SPEED_II: int;
        /**  */
        STRENGTH: int;
        /**  */
        MUNDANE: int;
        /**  */
        INVISIBLE: int;
        /**  */
        STRENGTH_II: int;
        /**  */
        INSTANT_HEALTH_II: int;
        /**  */
        THICK: int;
        /**  */
        NIGHT_VISION: int;
        /**  */
        WITHER_II: int;
        /**  */
        SLOWNESS: int;
        /**  */
        SLOWNESS_IV: int;
        /**  */
        WEAKNESS_LONG: int;
        /**  */
        TURTLE_MASTER_II: int;
        /**  */
        SPEED_LONG: int;
        /**  */
        HARMING_II: int;
        /**  */
        WATER_BREATHING: int;
        /**  */
        TURTLE_MASTER_LONG: int;
        /**  */
        STRENGTH_LONG: int;
        /**  */
        WATER_BREATHING_LONG: int;
        /**  */
        AWKWARD: int;
        /**  */
        SLOW_FALLING_LONG: int;
        /**  */
        NO_EFFECTS: int;
        /**  */
        SLOWNESS_LONG: int;
        /**  */
        POISON: int;
        /**  */
        potions: cn.nukkit.potion.Potion[];
        /**  */
        LEAPING_II: int;
        /**  */
        POISON_LONG: int;
        /**  */
        INSTANT_HEALTH: int;
        /**  */
        splash: boolean;
        /**  */
        FIRE_RESISTANCE_LONG: int;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public static getPotionByName(name: java.lang.String): cn.nukkit.potion.Potion;
        /**
         * 
         */
        public static init(): void;
        /**
         * 
         */
        public getLevel(): int;
        /**
         * 
         * @param {int} potionType 
         */
        public static getLevel(potionType: int): int;
        /**
         * 
         * @param {int} id 
         */
        public static getPotion(id: int): cn.nukkit.potion.Potion;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {double} health 
         */
        public applyPotion(entity: cn.nukkit.entity.Entity,health: double): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public applyPotion(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} potionType 
         * @param {boolean} isSplash 
         */
        public static getApplySeconds(potionType: int,isSplash: boolean): int;
        /**
         * 
         */
        public isSplash(): boolean;
        /**
         * 
         */
        public  clone(): java.lang.Object;
        /**
         * 
         */
        public clone(): cn.nukkit.potion.Potion;
        /**
         * 
         * @param {int} potionType 
         */
        public static isInstant(potionType: int): boolean;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {int} potionType 
         * @param {boolean} isSplash 
         */
        public static getEffect(potionType: int,isSplash: boolean): cn.nukkit.potion.Effect;
        /**
         * 
         */
        public getEffect(): cn.nukkit.potion.Effect;
        /**
         * 
         * @param {boolean} splash 
         */
        public setSplash(splash: boolean): cn.nukkit.potion.Potion;
    }
}
declare namespace cn.nukkit.block{
     class BlockOreEmerald extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockGlassStained extends cn.nukkit.block.BlockGlass{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         * @param {cn.nukkit.utils.DyeColor} color 
         */
        public setDyeColor(color: cn.nukkit.utils.DyeColor): void;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public canSilkTouch(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemPotato extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.block{
     class BlockWood extends cn.nukkit.block.BlockLog{
        /**  */
        SPRUCE: int;
        /**  */
        OLD_LOG_TYPE: cn.nukkit.blockproperty.BlockProperty;
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        BIRCH: int;
        /**  */
        JUNGLE: int;
        /**  */
        OAK: int;
        /**
         * 
         */
        public getWoodType(): cn.nukkit.blockproperty.value.WoodType;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.blockstate.IBlockState} state 
         */
        public  forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.blockstate.IMutableBlockState;
        /**
         * 
         * @param {cn.nukkit.blockstate.IBlockState} state 
         */
        public forState(state: cn.nukkit.blockstate.IBlockState): cn.nukkit.block.Block;
        /**
         * 
         */
        protected getStrippedState(): cn.nukkit.blockstate.BlockState;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.blockproperty.value.WoodType} woodType 
         */
        public setWoodType(woodType: cn.nukkit.blockproperty.value.WoodType): void;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace java.util{
     class Base64 extends java.lang.Object{
        /**
         * 
         */
        public static getUrlEncoder(): java.util.Base64.Encoder;
        /**
         * 
         */
        public static getMimeDecoder(): java.util.Base64.Decoder;
        /**
         * 
         */
        public static getDecoder(): java.util.Base64.Decoder;
        /**
         * 
         */
        public static getEncoder(): java.util.Base64.Encoder;
        /**
         * 
         */
        public static getUrlDecoder(): java.util.Base64.Decoder;
        /**
         * 
         * @param {int} arg0 
         * @param {byte[]} arg1 
         */
        public static getMimeEncoder(arg0: int,arg1: byte[]): java.util.Base64.Encoder;
        /**
         * 
         */
        public static getMimeEncoder(): java.util.Base64.Encoder;
    }
}
declare namespace cn.nukkit.level.particle{
     class SplashParticle extends cn.nukkit.level.particle.GenericParticle{
    }
}
declare namespace cn.nukkit.form.window{
    abstract class FormWindow extends java.lang.Object{
        /**  */
        closed: boolean;
        /**  */
        GSON: com.google.gson.Gson;
        /**
         * 
         */
        public abstract getResponse(): cn.nukkit.form.response.FormResponse;
        /**
         * 
         * @param {java.lang.String} data 
         */
        public abstract setResponse(data: java.lang.String): void;
        /**
         * 
         */
        public wasClosed(): boolean;
        /**
         * 
         */
        public getJSONData(): java.lang.String;
    }
}
declare namespace cn.nukkit.event.entity{
     class EntityTeleportEvent extends cn.nukkit.event.entity.EntityEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        from: cn.nukkit.level.Location;
        /**  */
        to: cn.nukkit.level.Location;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         * @param {cn.nukkit.level.Location} from 
         */
        public setFrom(from: cn.nukkit.level.Location): void;
        /**
         * 
         * @param {cn.nukkit.level.Location} to 
         */
        public setTo(to: cn.nukkit.level.Location): void;
        /**
         * 
         */
        public getTo(): cn.nukkit.level.Location;
        /**
         * 
         */
        public getFrom(): cn.nukkit.level.Location;
    }
}
declare namespace cn.nukkit.level.generator.populator.impl{
     class PopulatorFlower extends cn.nukkit.level.generator.populator.type.PopulatorSurfaceBlock{
        /**  */
        flowerTypes: java.util.List;
        /**
         * 
         * @param {int} a 
         * @param {int} b 
         */
        public addType(a: int,b: int): void;
        /**
         * 
         * @param {int} x 
         * @param {int} z 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected getBlockId(x: int,z: int,random: cn.nukkit.math.NukkitRandom,chunk: cn.nukkit.level.format.FullChunk): int;
        /**
         * 
         */
        public getTypes(): java.util.List;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         */
        protected canStay(x: int,y: int,z: int,chunk: cn.nukkit.level.format.FullChunk): boolean;
        /**
         * 
         * @param {int} x 
         * @param {int} y 
         * @param {int} z 
         * @param {int} id 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        protected placeBlock(x: int,y: int,z: int,id: int,chunk: cn.nukkit.level.format.FullChunk,random: cn.nukkit.math.NukkitRandom): void;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntitySkeleton extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace it.unimi.dsi.fastutil.longs{
    abstract class Long2ByteMap extends java.lang.Object{
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Byte} arg1 
         */
        public getOrDefault(arg0: java.lang.Object,arg1: java.lang.Byte): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public  getOrDefault(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {long} arg0 
         * @param {byte} arg1 
         */
        public getOrDefault(arg0: long,arg1: byte): byte;
        /**
         * 
         */
        public  entrySet(): java.util.Set;
        /**
         * 
         */
        public entrySet(): it.unimi.dsi.fastutil.objects.ObjectSet;
        /**
         * 
         * @param {long} arg0 
         * @param {java.util.function.LongFunction} arg1 
         */
        public computeIfAbsentNullable(arg0: long,arg1: java.util.function.LongFunction): byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public containsKey(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {long} arg0 
         */
        public abstract containsKey(arg0: long): boolean;
        /**
         * 
         */
        public  values(): java.util.Collection;
        /**
         * 
         */
        public abstract values(): it.unimi.dsi.fastutil.bytes.ByteCollection;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.util.function.Function} arg1 
         */
        public computeIfAbsent(arg0: java.lang.Long,arg1: java.util.function.Function): java.lang.Byte;
        /**
         * 
         * @param {long} arg0 
         * @param {java.util.function.LongToIntFunction} arg1 
         */
        public computeIfAbsent(arg0: long,arg1: java.util.function.LongToIntFunction): byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.function.Function} arg1 
         */
        public  computeIfAbsent(arg0: java.lang.Object,arg1: java.util.function.Function): java.lang.Object;
        /**
         * 
         */
        public clear(): void;
        /**
         * 
         * @param {long} arg0 
         * @param {byte} arg1 
         */
        public replace(arg0: long,arg1: byte): byte;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.lang.Byte} arg1 
         */
        public replace(arg0: java.lang.Long,arg1: java.lang.Byte): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.lang.Byte} arg1 
         * @param {java.lang.Byte} arg2 
         */
        public replace(arg0: java.lang.Long,arg1: java.lang.Byte,arg2: java.lang.Byte): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         * @param {java.lang.Object} arg2 
         */
        public  replace(arg0: java.lang.Object,arg1: java.lang.Object,arg2: java.lang.Object): boolean;
        /**
         * 
         * @param {long} arg0 
         * @param {byte} arg1 
         * @param {byte} arg2 
         */
        public replace(arg0: long,arg1: byte,arg2: byte): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public  replace(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {long} arg0 
         * @param {it.unimi.dsi.fastutil.longs.Long2ByteFunction} arg1 
         */
        public computeIfAbsentPartial(arg0: long,arg1: it.unimi.dsi.fastutil.longs.Long2ByteFunction): byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  remove(arg0: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {long} arg0 
         * @param {byte} arg1 
         */
        public remove(arg0: long,arg1: byte): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public remove(arg0: java.lang.Object,arg1: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public remove(arg0: java.lang.Object): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.lang.Byte} arg1 
         */
        public put(arg0: java.lang.Long,arg1: java.lang.Byte): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public  put(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {byte} arg0 
         */
        public abstract containsValue(arg0: byte): boolean;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public containsValue(arg0: java.lang.Object): boolean;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public compute(arg0: java.lang.Long,arg1: java.util.function.BiFunction): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public  compute(arg0: java.lang.Object,arg1: java.util.function.BiFunction): java.lang.Object;
        /**
         * 
         * @param {long} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public compute(arg0: long,arg1: java.util.function.BiFunction): byte;
        /**
         * 
         * @param {byte} arg0 
         */
        public abstract defaultReturnValue(arg0: byte): void;
        /**
         * 
         */
        public abstract defaultReturnValue(): byte;
        /**
         * 
         */
        public abstract long2ByteEntrySet(): it.unimi.dsi.fastutil.objects.ObjectSet;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public  computeIfPresent(arg0: java.lang.Object,arg1: java.util.function.BiFunction): java.lang.Object;
        /**
         * 
         * @param {long} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public computeIfPresent(arg0: long,arg1: java.util.function.BiFunction): byte;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.util.function.BiFunction} arg1 
         */
        public computeIfPresent(arg0: java.lang.Long,arg1: java.util.function.BiFunction): java.lang.Byte;
        /**
         * 
         */
        public abstract size(): int;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public  get(arg0: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {java.lang.Object} arg0 
         */
        public get(arg0: java.lang.Object): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         * @param {java.util.function.BiFunction} arg2 
         */
        public  merge(arg0: java.lang.Object,arg1: java.lang.Object,arg2: java.util.function.BiFunction): java.lang.Object;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.lang.Byte} arg1 
         * @param {java.util.function.BiFunction} arg2 
         */
        public merge(arg0: java.lang.Long,arg1: java.lang.Byte,arg2: java.util.function.BiFunction): java.lang.Byte;
        /**
         * 
         * @param {long} arg0 
         * @param {byte} arg1 
         * @param {java.util.function.BiFunction} arg2 
         */
        public merge(arg0: long,arg1: byte,arg2: java.util.function.BiFunction): byte;
        /**
         * 
         * @param {java.lang.Long} arg0 
         * @param {java.lang.Byte} arg1 
         */
        public putIfAbsent(arg0: java.lang.Long,arg1: java.lang.Byte): java.lang.Byte;
        /**
         * 
         * @param {java.lang.Object} arg0 
         * @param {java.lang.Object} arg1 
         */
        public  putIfAbsent(arg0: java.lang.Object,arg1: java.lang.Object): java.lang.Object;
        /**
         * 
         * @param {long} arg0 
         * @param {byte} arg1 
         */
        public putIfAbsent(arg0: long,arg1: byte): byte;
        /**
         * 
         */
        public  keySet(): java.util.Set;
        /**
         * 
         */
        public abstract keySet(): it.unimi.dsi.fastutil.longs.LongSet;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityMagmaCube extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityHorse extends cn.nukkit.entity.passive.EntityAnimal{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getDrops(): cn.nukkit.item.Item[];
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockWool extends cn.nukkit.block.BlockSolidMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public getBurnChance(): int;
        /**
         * 
         */
        public getBurnAbility(): int;
    }
}
declare namespace cn.nukkit.entity.item{
     class EntityBoat extends cn.nukkit.entity.item.EntityVehicle{
        /**  */
        NETWORK_ID: int;
        /**  */
        PASSENGER_INDEX: int;
        /**  */
        DATA_WOOD_ID: int;
        /**  */
        woodID: int;
        /**  */
        RIDER_PLAYER_OFFSET: cn.nukkit.math.Vector3f;
        /**  */
        PASSENGER_OFFSET: cn.nukkit.math.Vector3f;
        /**  */
        RIDER_OFFSET: cn.nukkit.math.Vector3f;
        /**  */
        SINKING_SPEED: double;
        /**  */
        ticksInWater: int;
        /**  */
        ignoreCollision: java.util.Set;
        /**  */
        sinking: boolean;
        /**  */
        RIDER_PASSENGER_OFFSET: cn.nukkit.math.Vector3f;
        /**  */
        RIDER_INDEX: int;
        /**  */
        SINKING_DEPTH: double;
        /**  */
        SINKING_MAX_SPEED: double;
        /**
         * 
         */
        private collectCollidingEntities(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public applyEntityCollision(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {byte} mode 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity,mode: byte): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public isControlling(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public getInteractButtonText(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public dismountEntity(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {double} waterDiff 
         */
        private moveBoat(waterDiff: double): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         */
        public canDoInteraction(): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        protected createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         * @param {int} variant 
         */
        public setVariant(variant: int): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        protected getGravity(): float;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getMountedOffset(entity: cn.nukkit.entity.Entity): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getBaseOffset(): float;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} passenger 
         */
        protected updatePassengerPosition(passenger: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getVariant(): int;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public kill(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {double} waterDiff 
         */
        private computeBuoyancy(waterDiff: double): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {cn.nukkit.network.protocol.AnimatePacket.Action} animation 
         * @param {float} value 
         */
        public onPaddle(animation: cn.nukkit.network.protocol.AnimatePacket.Action,value: float): void;
        /**
         * 
         */
        public getWaterLevel(): double;
        /**
         * 
         */
        public updatePassengers(): void;
        /**
         * 
         * @param {boolean} sendLinks 
         */
        public updatePassengers(sendLinks: boolean): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {int} tickDiff 
         */
        private updateBoat(tickDiff: int): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemGhastTear extends cn.nukkit.item.Item{
    }
}
declare namespace cn.nukkit.block{
     class BlockOreQuartz extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public canSilkTouch(): boolean;
        /**
         * 
         */
        public getDropExp(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockDragonEgg extends cn.nukkit.block.BlockFallable{
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public teleport(): void;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public isTransparent(): boolean;
        /**
         * 
         */
        public getLightLevel(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.event.player.PlayerInteractEvent.Action} action 
         */
        public onTouch(player: cn.nukkit.Player,action: cn.nukkit.event.player.PlayerInteractEvent.Action): int;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
    }
}
declare namespace com.blocklynukkit.loader.other.Entities{
     class BNModel extends cn.nukkit.entity.EntityHuman{
        /**  */
        tickCallback: java.lang.String;
        /**  */
        interactCallback: java.lang.String;
        /**  */
        dataStorage: com.blocklynukkit.loader.other.data.MemoryStorage;
        /**  */
        length: float;
        /**  */
        width: float;
        /**  */
        attackCallback: java.lang.String;
        /**  */
        callTick: int;
        /**  */
        height: float;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         * @param {java.lang.String} modelSkinName 
         */
        public resetModelSkin(modelSkinName: java.lang.String): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
    }
}
declare namespace cn.nukkit.level{
     class GameRules extends java.lang.Object{
        /**  */
        gameRules: java.util.EnumMap;
        /**  */
        stale: boolean;
        /**
         * 
         */
        public refresh(): void;
        /**
         * 
         */
        public static getDefault(): cn.nukkit.level.GameRules;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         */
        public getInteger(gameRule: cn.nukkit.level.GameRule): int;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         */
        public getGameRuleType(gameRule: cn.nukkit.level.GameRule): cn.nukkit.level.GameRules.Type;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         */
        public getFloat(gameRule: cn.nukkit.level.GameRule): float;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         */
        public getString(gameRule: cn.nukkit.level.GameRule): java.lang.String;
        /**
         * 
         */
        public getGameRules(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         * @param {float} value 
         */
        public setGameRule(gameRule: cn.nukkit.level.GameRule,value: float): void;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         * @param {int} value 
         */
        public setGameRule(gameRule: cn.nukkit.level.GameRule,value: int): void;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         * @param {boolean} value 
         */
        public setGameRule(gameRule: cn.nukkit.level.GameRule,value: boolean): void;
        /**
         * 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         */
        public readNBT(nbt: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         */
        public writeNBT(): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         * @param {java.lang.String} value 
         */
        public setGameRules(gameRule: cn.nukkit.level.GameRule,value: java.lang.String): void;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         */
        public getBoolean(gameRule: cn.nukkit.level.GameRule): boolean;
        /**
         * 
         */
        public getRules(): cn.nukkit.level.GameRule[];
        /**
         * 
         */
        public isStale(): boolean;
        /**
         * 
         * @param {cn.nukkit.level.GameRule} gameRule 
         */
        public hasRule(gameRule: cn.nukkit.level.GameRule): boolean;
    }
}
declare namespace cn.nukkit.entity{
    abstract class Entity extends cn.nukkit.level.Location{
        /**  */
        DATA_FLAG_NO_AI: int;
        /**  */
        DATA_FLAG_ENCHANTED: int;
        /**  */
        DATA_FLAG_WANTS_TO_WAKE: int;
        /**  */
        DATA_RIDER_ROTATION_OFFSET: int;
        /**  */
        DATA_FLAG_RIDER_CAN_PICK: int;
        /**  */
        DATA_TYPE_BYTE: int;
        /**  */
        DATA_FLAG_STACKABLE: int;
        /**  */
        DATA_FLAG_DANCING: int;
        /**  */
        DATA_COLOR_2: int;
        /**  */
        DATA_ENTITY_AGE: int;
        /**  */
        DATA_SITTING_AMOUNT_PREVIOUS: int;
        /**  */
        lastDamageCause: cn.nukkit.event.entity.EntityDamageEvent;
        /**  */
        DATA_FLAG_CRITICAL: int;
        /**  */
        DATA_WITHER_INVULNERABLE_TICKS: int;
        /**  */
        DATA_FLAG_BLOCKED_USING_DAMAGED_SHIELD: int;
        /**  */
        positionChanged: boolean;
        /**  */
        DATA_JUMP_DURATION: int;
        /**  */
        namedTag: cn.nukkit.nbt.tag.CompoundTag;
        /**  */
        DATA_FLAG_IMMOBILE: int;
        /**  */
        DATA_AREA_EFFECT_CLOUD_PARTICLE_ID: int;
        /**  */
        DATA_FLAG_FACING_TARGET_TO_RANGE_ATTACK: int;
        /**  */
        temporalVector: cn.nukkit.math.Vector3;
        /**  */
        DATA_FLAG_CHARGED: int;
        /**  */
        absorption: float;
        /**  */
        DATA_FUSE_LENGTH: int;
        /**  */
        DATA_FLAG_SNEAKING: int;
        /**  */
        DATA_ALWAYS_SHOW_NAMETAG: int;
        /**  */
        DATA_RIDER_MAX_ROTATION: int;
        /**  */
        DATA_HURT_DIRECTION: int;
        /**  */
        DATA_FLAG_SPIN_ATTACK: int;
        /**  */
        entityCount: long;
        /**  */
        DATA_FLAG_IS_ILLAGER_CAPTAIN: int;
        /**  */
        DATA_FLAG_IS_AVOIDING_BLOCKS: int;
        /**  */
        lastUpdate: int;
        /**  */
        DATA_WITHER_TARGET_1: int;
        /**  */
        DATA_WITHER_TARGET_2: int;
        /**  */
        DATA_LOW_TIER_CURED_DISCOUNT: int;
        /**  */
        DATA_FLAG_ORPHANED: int;
        /**  */
        DATA_FLAG_IN_SCAFFOLDING: int;
        /**  */
        DATA_WITHER_TARGET_3: int;
        /**  */
        isCollided: boolean;
        /**  */
        DATA_DISPLAY_ITEM: int;
        /**  */
        DATA_FLAG_INVISIBLE: int;
        /**  */
        DATA_FLAG_ADMIRING: int;
        /**  */
        EMPTY_ARRAY: cn.nukkit.entity.Entity[];
        /**  */
        DATA_COLOUR: int;
        /**  */
        DATA_BASE_RUNTIME_ID: int;
        /**  */
        blocksAround: java.util.List;
        /**  */
        DATA_AIR: int;
        /**  */
        DATA_TYPE_STRING: int;
        /**  */
        DATA_FLAG_SHOWBASE: int;
        /**  */
        DATA_CONTAINER_EXTRA_SLOTS_PER_STRENGTH: int;
        /**  */
        DATA_SCALE: int;
        /**  */
        DATA_FLAG_BREAKING_OBSTRUCTION: int;
        /**  */
        DATA_NAME_RAW_TEXT: int;
        /**  */
        DATA_TYPE_INT: int;
        /**  */
        DATA_FLAG_ROLLING: int;
        /**  */
        DATA_PLAYER_BED_POSITION: int;
        /**  */
        DATA_HAS_DISPLAY: int;
        /**  */
        DATA_FLAG_INTERESTED: int;
        /**  */
        hasSpawned: java.util.Map;
        /**  */
        DATA_STRENGTH: int;
        /**  */
        DATA_RIDER_MIN_ROTATION: int;
        /**  */
        DATA_TYPE_SHORT: int;
        /**  */
        DATA_MAX_AIR: int;
        /**  */
        DATA_LAYING_AMOUNT: int;
        /**  */
        DATA_FLAG_VIBRATING: int;
        /**  */
        DATA_NEARBY_CURED_DISCOUNT: int;
        /**  */
        DATA_FLAG_IGNITED: int;
        /**  */
        DATA_FLAG_WALKER: int;
        /**  */
        ticksLived: int;
        /**  */
        DATA_AREA_EFFECT_CLOUD_RADIUS: int;
        /**  */
        DATA_FLAG_IS_TRANSFORMING: int;
        /**  */
        DATA_FLAG_PREGNANT: int;
        /**  */
        DATA_TYPE_VECTOR3F: int;
        /**  */
        DATA_POTION_AMBIENT: int;
        /**  */
        DATA_FLAG_ROARING: int;
        /**  */
        shortNames: java.util.Map;
        /**  */
        DATA_FLAG_DOOR_OPENER: int;
        /**  */
        knownEntities: java.util.Map;
        /**  */
        DATA_BOUNDING_BOX_HEIGHT: int;
        /**  */
        closed: boolean;
        /**  */
        DATA_FLAG_CONTAINER_PRIVATE: int;
        /**  */
        DATA_FISH_ANGLE: int;
        /**  */
        DATA_FLAG_IS_IN_UI: int;
        /**  */
        NETWORK_ID: int;
        /**  */
        DATA_FLAG_CAN_FLY: int;
        /**  */
        DATA_ENDERMAN_HELD_RUNTIME_ID: int;
        /**  */
        DATA_EATING_COUNTER: int;
        /**  */
        isCollidedHorizontally: boolean;
        /**  */
        DATA_AMBIENT_SOUND_EVENT_NAME: int;
        /**  */
        DATA_SITTING_AMOUNT: int;
        /**  */
        DATA_TYPE_LONG: int;
        /**  */
        lastZ: double;
        /**  */
        DATA_NAME_AUTHOR: int;
        /**  */
        DATA_CAN_RIDE_TARGET: int;
        /**  */
        DATA_FLAG_ACTION: int;
        /**  */
        lastY: double;
        /**  */
        lastX: double;
        /**  */
        DATA_FLAG_LINGER: int;
        /**  */
        DATA_FLAG_OVER_SCAFFOLDING: int;
        /**  */
        DATA_FLAG_DELAYED_ATTACK: int;
        /**  */
        DATA_FLAG_LAYING_DOWN: int;
        /**  */
        DATA_HEALTH: int;
        /**  */
        DATA_FLAG_BRIBED: int;
        /**  */
        DATA_FLAG_HAS_COLLISION: int;
        /**  */
        fireProof: boolean;
        /**  */
        DATA_SHULKER_ATTACH_FACE: int;
        /**  */
        DATA_PUFFERFISH_SIZE: int;
        /**  */
        DATA_FLAG_REARING: int;
        /**  */
        DATA_FLAG_FALL_THROUGH_SCAFFOLDING: int;
        /**  */
        DATA_BOUNDING_BOX_WIDTH: int;
        /**  */
        DATA_FLAG_CELEBRATING: int;
        /**  */
        DATA_SHULKER_PEEK_ID: int;
        /**  */
        isStatic: boolean;
        /**  */
        DATA_FLAG_TRANSITION_SETTING: int;
        /**  */
        DATA_FLAG_EVOKER_SPELL: int;
        /**  */
        DATA_FLAGS: int;
        /**  */
        DATA_COMMAND_BLOCK_TICK_DELAY: int;
        /**  */
        fallDistance: float;
        /**  */
        lastYaw: double;
        /**  */
        DATA_HAS_NPC_COMPONENT: int;
        /**  */
        DATA_CONTAINER_TYPE: int;
        /**  */
        DATA_FLAG_GLIDING: int;
        /**  */
        ySize: float;
        /**  */
        DATA_TYPE_POS: int;
        /**  */
        DATA_BLOCK_TARGET: int;
        /**  */
        DATA_CHANGE_ON_PICKUP: int;
        /**  */
        DATA_AREA_EFFECT_CLOUD_WAITING: int;
        /**  */
        DATA_FIREBALL_POWER_Z: int;
        /**  */
        DATA_FIREBALL_POWER_Y: int;
        /**  */
        inEndPortal: boolean;
        /**  */
        DATA_FIREBALL_POWER_X: int;
        /**  */
        DATA_OLD_SWELL: int;
        /**  */
        DATA_FLAG_EATING: int;
        /**  */
        DATA_NPC_SKIN_ID: int;
        /**  */
        DATA_SWELL: int;
        /**  */
        DATA_FLAG_CAN_SHOW_NAMETAG: int;
        /**  */
        entityCollisionReduction: double;
        /**  */
        DATA_HAS_COMMAND_BLOCK: int;
        /**  */
        DATA_IS_BUOYANT: int;
        /**  */
        DATA_CONTAINER_BASE_SIZE: int;
        /**  */
        DATA_VARIANT: int;
        /**  */
        DATA_FLAG_BLOCKING: int;
        /**  */
        DATA_INTERACT_TEXT: int;
        /**  */
        DATA_LIMITED_LIFE: int;
        /**  */
        DATA_FLAG_LAYING_EGG: int;
        /**  */
        DATA_PLAYER_INDEX: int;
        /**  */
        DATA_MAX_TRADE_TIER: int;
        /**  */
        DATA_FLAG_SHEARED: int;
        /**  */
        DATA_URL_TAG: int;
        /**  */
        DATA_UPDATE_PROPERTIES: int;
        /**  */
        pitchDelta: double;
        /**  */
        DATA_BALLOON_ATTACHED_ENTITY: int;
        /**  */
        DATA_FLAG_SITTING: int;
        /**  */
        DATA_RIDER_SEAT_POSITION: int;
        /**  */
        DATA_MAX_STRENGTH: int;
        /**  */
        DATA_EXPERIENCE_VALUE: int;
        /**  */
        DATA_FLAG_SHOW_TRIDENT_ROPE: int;
        /**  */
        DATA_FLAG_WASD_CONTROLLED: int;
        /**  */
        age: int;
        /**  */
        DATA_SCORE_TAG: int;
        /**  */
        DATA_FLAG_ELDER: int;
        /**  */
        DATA_FLAG_BLOCKED_USING_SHIELD: int;
        /**  */
        DATA_FLAG_EMOTING: int;
        /**  */
        DATA_TRADING_PLAYER_EID: int;
        /**  */
        DATA_FLAG_ALWAYS_SHOW_NAMETAG: int;
        /**  */
        maxHealth: int;
        /**  */
        DATA_AGENT: int;
        /**  */
        id: long;
        /**  */
        DATA_OWNER_EID: int;
        /**  */
        DATA_POTION_AUX_VALUE: int;
        /**  */
        DATA_CHANGE_RATE: int;
        /**  */
        DATA_SPAWNING_FRAMES: int;
        /**  */
        yawDelta: double;
        /**  */
        DATA_FLAG_SWIMMING: int;
        /**  */
        passengers: java.util.List;
        /**  */
        DATA_CONTROLLING_RIDER_SEAT_NUMBER: int;
        /**  */
        DATA_FLAG_BABY: int;
        /**  */
        DATA_COMMAND_BLOCK_COMMAND: int;
        /**  */
        DATA_FLAG_TEMPTED: int;
        /**  */
        DATA_RIDER_ROTATION_LOCKED: int;
        /**  */
        DATA_COMMAND_BLOCK_LAST_OUTPUT: int;
        /**  */
        DATA_FLAG_HIDDEN_WHEN_INVISIBLE: int;
        /**  */
        DATA_FLAG_CHESTED: int;
        /**  */
        DATA_FLAG_INLOVE: int;
        /**  */
        DATA_ENDER_CRYSTAL_TIME_OFFSET: int;
        /**  */
        deadTicks: int;
        /**  */
        collisionBlocks: java.util.List;
        /**  */
        inPortalTicks: int;
        /**  */
        DATA_FLAG_CONVERTING: int;
        /**  */
        DATA_FLAG_CELEBRATING_SPECIAL: int;
        /**  */
        DATA_SHULKER_ATTACH_POS: int;
        /**  */
        noClip: boolean;
        /**  */
        boundingBox: cn.nukkit.math.AxisAlignedBB;
        /**  */
        server: cn.nukkit.Server;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        DATA_COLOR: int;
        /**  */
        keepMovement: boolean;
        /**  */
        DATA_COMMAND_BLOCK_TRACK_OUTPUT: int;
        /**  */
        highestPosition: double;
        /**  */
        DATA_FLAG_DOOR_BREAKER: int;
        /**  */
        firstMove: boolean;
        /**  */
        DATA_BUOYANCY_DATA: int;
        /**  */
        DATA_SPAWN_TIME: int;
        /**  */
        DATA_FLAG_WALLCLIMBING: int;
        /**  */
        DATA_POTION_COLOR: int;
        /**  */
        DATA_ARMOR_STAND_POSE_INDEX: int;
        /**  */
        DATA_FLAG_SADDLED: int;
        /**  */
        DATA_PADDLE_TIME_RIGHT: int;
        /**  */
        DATA_GOAT_HORN_COUNT: int;
        /**  */
        DATA_TYPE_FLOAT: int;
        /**  */
        initialized: boolean;
        /**  */
        motionChanged: boolean;
        /**  */
        DATA_PICKUP_COUNT: int;
        /**  */
        DATA_DURATION: int;
        /**  */
        motionZ: double;
        /**  */
        lastPitch: double;
        /**  */
        DATA_TRADING_CAREER: int;
        /**  */
        DATA_FALL_DAMAGE_MULTIPLIER: int;
        /**  */
        motionY: double;
        /**  */
        motionX: double;
        /**  */
        DATA_AMBIENT_SOUND_INTERVAL_RANGE: int;
        /**  */
        health: float;
        /**  */
        DATA_CHARGE_AMOUNT: int;
        /**  */
        DATA_CLIENT_EVENT: int;
        /**  */
        DATA_FISH_X: int;
        /**  */
        DATA_FLAG_ANGRY: int;
        /**  */
        DATA_FLAG_STALKING: int;
        /**  */
        dataProperties: cn.nukkit.entity.data.EntityMetadata;
        /**  */
        onGround: boolean;
        /**  */
        DATA_AERIAL_ATTACK: int;
        /**  */
        DATA_FREEZING_EFFECT_STRENGTH: int;
        /**  */
        DATA_FLAG_SLEEPING: int;
        /**  */
        DATA_BUBBLE_TIME: int;
        /**  */
        DATA_FISH_Z: int;
        /**  */
        DATA_AMBIENT_SOUND_INTERVAL: int;
        /**  */
        DATA_FLAG_MOVING: int;
        /**  */
        DATA_DISPLAY_OFFSET: int;
        /**  */
        DATA_COMMAND_BLOCK_EXECUTE_ON_FIRST_TICK: int;
        /**  */
        DATA_PLAYER_FLAGS: int;
        /**  */
        DATA_FLAG_SNEEZING: int;
        /**  */
        DATA_FLAG_IS_AVOIDING_MOBS: int;
        /**  */
        DATA_AUX_POWER: int;
        /**  */
        DATA_FLAG_FIRE_IMMUNE: int;
        /**  */
        DATA_FLAG_SCARED: int;
        /**  */
        DATA_HIGH_TIER_CURED_DISCOUNT: int;
        /**  */
        DATA_FLAG_POWERED: int;
        /**  */
        DATA_INTERACTIVE_TAG: int;
        /**  */
        inBlock: boolean;
        /**  */
        DATA_FLAG_GRAVITY: int;
        /**  */
        DATA_FLAG_TAMED: int;
        /**  */
        DATA_FLAG_CAN_CLIMB: int;
        /**  */
        DATA_FLAG_CHARGE_ATTACK: int;
        /**  */
        DATA_FLAG_STUNNED: int;
        /**  */
        DATA_FLAG_TRANSITION_SITTING: int;
        /**  */
        DATA_SKIN_ID: int;
        /**  */
        DATA_LAYING_AMOUNT_PREVIOUS: int;
        /**  */
        DATA_FLAGS_EXTENDED: int;
        /**  */
        DATA_FLAG_SILENT: int;
        /**  */
        DATA_FLAG_CAN_POWER_JUMP: int;
        /**  */
        DATA_FLAG_RAM_ATTACK: int;
        /**  */
        DATA_FLAG_TRUSTING: int;
        /**  */
        maxFireTicks: int;
        /**  */
        timing: co.aikar.timings.Timing;
        /**  */
        DATA_TARGET_EID: int;
        /**  */
        isCollidedVertically: boolean;
        /**  */
        DATA_FLAG_SPRINTING: int;
        /**  */
        DATA_SPELL_CASTING_COLOR: int;
        /**  */
        DATA_FLAG_LEASHED: int;
        /**  */
        fireTicks: int;
        /**  */
        effects: java.util.Map;
        /**  */
        DATA_FLAG_TRANSITION_BLOCKING: int;
        /**  */
        DATA_TRADE_TIER: int;
        /**  */
        DATA_TRADE_EXPERIENCE: int;
        /**  */
        lastMotionZ: double;
        /**  */
        lastMotionY: double;
        /**  */
        DATA_FLAG_PLAYING_DEAD: int;
        /**  */
        lastMotionX: double;
        /**  */
        DATA_USING_ITEM: int;
        /**  */
        isPlayer: boolean;
        /**  */
        DATA_NAMETAG: int;
        /**  */
        DATA_MARK_VARIANT: int;
        /**  */
        chunk: cn.nukkit.level.format.FullChunk;
        /**  */
        scale: float;
        /**  */
        riding: cn.nukkit.entity.Entity;
        /**  */
        DATA_FLAG_RIDING: int;
        /**  */
        justCreated: boolean;
        /**  */
        invulnerable: boolean;
        /**  */
        DATA_FLAG_SWIMMER: int;
        /**  */
        DATA_FLAG_IDLING: int;
        /**  */
        DATA_FLAG_BREATHING: int;
        /**  */
        DATA_SWELL_DIR: int;
        /**  */
        DATA_FLAG_RESTING: int;
        /**  */
        DATA_LEAD_HOLDER_EID: int;
        /**  */
        DATA_HURT_TIME: int;
        /**  */
        noDamageTicks: int;
        /**  */
        DATA_SHULKER_ATTACHED: int;
        /**  */
        DATA_NEARBY_CURED_DISCOUNT_TIMESTAMP: int;
        /**  */
        DATA_FLAG_ONFIRE: int;
        /**  */
        DATA_HITBOX: int;
        /**  */
        DATA_TYPE_NBT: int;
        /**  */
        DATA_PADDLE_TIME_LEFT: int;
        /**  */
        DATA_FLAG_TRADE_INTEREST: int;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         */
        public sendData(players: cn.nukkit.Player[]): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public sendData(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.Player[]} players 
         * @param {cn.nukkit.entity.data.EntityMetadata} data 
         */
        public sendData(players: cn.nukkit.Player[],data: cn.nukkit.entity.data.EntityMetadata): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.entity.data.EntityMetadata} data 
         */
        public sendData(player: cn.nukkit.Player,data: cn.nukkit.entity.data.EntityMetadata): void;
        /**
         * 
         */
        public static getKnownEntityIds(): it.unimi.dsi.fastutil.ints.IntCollection;
        /**
         * 
         */
        public getLocation(): cn.nukkit.level.Location;
        /**
         * 
         * @param {cn.nukkit.entity.data.EntityData} data 
         */
        public setDataProperty(data: cn.nukkit.entity.data.EntityData): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.data.EntityData} data 
         * @param {boolean} send 
         */
        public setDataProperty(data: cn.nukkit.entity.data.EntityData,send: boolean): boolean;
        /**
         * 
         * @param {java.lang.Class} classType 
         */
        public collideWithBlock(classType: java.lang.Class): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public applyEntityCollision(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isInsideOfWater(): boolean;
        /**
         * 
         */
        public isSprinting(): boolean;
        /**
         * 
         */
        public isNameTagVisible(): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} type 
         */
        public setLastDamageCause(type: cn.nukkit.event.entity.EntityDamageEvent): void;
        /**
         * 
         */
        protected checkChunks(): void;
        /**
         * 
         */
        public hasCustomName(): boolean;
        /**
         * 
         */
        public getHorizontalFacing(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public getHealth(): float;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyShort(id: int): int;
        /**
         * 
         */
        public getServer(): cn.nukkit.Server;
        /**
         * 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         */
        protected  init(chunk: cn.nukkit.level.format.FullChunk,nbt: cn.nukkit.nbt.tag.CompoundTag): void;
        /**
         * 
         * @param {int} maxHealth 
         */
        public setMaxHealth(maxHealth: int): void;
        /**
         * 
         */
        public saveNBT(): void;
        /**
         * 
         */
        public getDirectionPlane(): cn.nukkit.math.Vector2;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public setMotion(motion: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         * @param {double} movX 
         * @param {double} movY 
         * @param {double} movZ 
         * @param {double} dx 
         * @param {double} dy 
         * @param {double} dz 
         */
        protected checkGroundState(movX: double,movY: double,movZ: double,dx: double,dy: double,dz: double): void;
        /**
         * 
         * @param {double} yaw 
         * @param {double} pitch 
         */
        public setRotation(yaw: double,pitch: double): void;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyVector3f(id: int): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.math.Vector3} clickedPos 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item,clickedPos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         * @param {cn.nukkit.item.Item} item 
         */
        public onInteract(player: cn.nukkit.Player,item: cn.nukkit.item.Item): boolean;
        /**
         * 
         */
        public canClimb(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public canCollideWith(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public getCurrentHeight(): float;
        /**
         * 
         */
        public isSneaking(): boolean;
        /**
         * 
         */
        public updateMovement(): void;
        /**
         * 
         */
        public doesTriggerPressurePlate(): boolean;
        /**
         * 
         */
        public getDirectionVector(): cn.nukkit.math.Vector3;
        /**
         * 
         */
        public setSpinAttacking(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setSpinAttacking(value: boolean): void;
        /**
         * 
         */
        public isInsideOfFire(): boolean;
        /**
         * 
         */
        public setCanClimb(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setCanClimb(value: boolean): void;
        /**
         * 
         */
        public getRiding(): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {double} motionX 
         * @param {double} motionY 
         * @param {double} motionZ 
         */
        public addMotion(motionX: double,motionY: double,motionZ: double): void;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         */
        protected checkObstruction(x: double,y: double,z: double): boolean;
        /**
         * 
         */
        public setSwimming(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setSwimming(value: boolean): void;
        /**
         * 
         */
        public setGliding(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setGliding(value: boolean): void;
        /**
         * 
         */
        public getMaxHealth(): int;
        /**
         * 
         * @param {int} effectId 
         */
        public removeEffect(effectId: int): void;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public getEyeHeight(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public spawnTo(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} rider 
         * @param {byte} type 
         */
        protected broadcastLinkPacket(rider: cn.nukkit.entity.Entity,type: byte): void;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public abstract getNetworkId(): int;
        /**
         * 
         * @param {int} seconds 
         */
        public setOnFire(seconds: int): void;
        /**
         * 
         * @param {float} fallDistance 
         */
        public fall(fallDistance: float): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3f} pos 
         */
        public setSeatPosition(pos: cn.nukkit.math.Vector3f): void;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         * @param {float} damage 
         */
        public attack(damage: float): boolean;
        /**
         * 
         */
        public isUndead(): boolean;
        /**
         * 
         */
        public isOnLadder(): boolean;
        /**
         * 
         */
        public setSneaking(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setSneaking(value: boolean): void;
        /**
         * 
         * @param {java.lang.Boolean} despawn 
         */
        private close(despawn: java.lang.Boolean): void;
        /**
         * 
         */
        public close(): void;
        /**
         * 
         */
        protected recalculateEffectColor(): void;
        /**
         * 
         */
        protected getBaseOffset(): float;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} passenger 
         */
        protected updatePassengerPosition(passenger: cn.nukkit.entity.Entity): void;
        /**
         * 
         */
        public isSwimming(): boolean;
        /**
         * 
         */
        public isNoClip(): boolean;
        /**
         * 
         */
        public canBeMovedByCurrents(): boolean;
        /**
         * 
         */
        protected getStepHeight(): double;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         */
        private static lambda$getNearestValidPortal$4(block: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public despawnFrom(player: cn.nukkit.Player): void;
        /**
         * 
         * @param {cn.nukkit.level.Level} targetLevel 
         */
        protected switchLevel(targetLevel: cn.nukkit.level.Level): boolean;
        /**
         * 
         */
        public canTriggerWalking(): boolean;
        /**
         * 
         * @param {double} by 
         * @param {cn.nukkit.block.Block} block 
         */
        private static lambda$getNearestValidPortal$3(by: double,block: cn.nukkit.block.Block): double;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public onStruckByLightning(entity: cn.nukkit.entity.Entity): void;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyLong(id: int): long;
        /**
         * 
         * @param {cn.nukkit.math.Vector2} currentPosV2 
         * @param {cn.nukkit.block.Block} block 
         */
        private static lambda$getNearestValidPortal$2(currentPosV2: cn.nukkit.math.Vector2,block: cn.nukkit.block.Block): double;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public hasMetadata(metadataKey: java.lang.String): boolean;
        /**
         * 
         * @param {cn.nukkit.math.BlockVector3} pos 
         * @param {cn.nukkit.blockstate.BlockState} state 
         */
        private static lambda$getNearestValidPortal$1(pos: cn.nukkit.math.BlockVector3,state: cn.nukkit.blockstate.BlockState): boolean;
        /**
         * 
         */
        public kill(): void;
        /**
         * 
         */
        public setNameTagVisible(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setNameTagVisible(value: boolean): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setNameTagAlwaysVisible(value: boolean): void;
        /**
         * 
         */
        public setNameTagAlwaysVisible(): void;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {double} yaw 
         * @param {double} pitch 
         */
        public setPositionAndRotation(pos: cn.nukkit.math.Vector3,yaw: double,pitch: double): boolean;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.metadata.MetadataValue} newMetadataValue 
         */
        public setMetadata(metadataKey: java.lang.String,newMetadataValue: cn.nukkit.metadata.MetadataValue): void;
        /**
         * 
         */
        public isNameTagAlwaysVisible(): boolean;
        /**
         * 
         */
        public isClosed(): boolean;
        /**
         * 
         */
        public isImmobile(): boolean;
        /**
         * 
         */
        public getPassengers(): java.util.List;
        /**
         * 
         */
        public updatePassengers(): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public setImmobile(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setImmobile(value: boolean): void;
        /**
         * 
         */
        public isSpinAttacking(): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.Class} clazz 
         * @param {boolean} force 
         */
        public static registerEntity(name: java.lang.String,clazz: java.lang.Class,force: boolean): boolean;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {java.lang.Class} clazz 
         */
        public static registerEntity(name: java.lang.String,clazz: java.lang.Class): boolean;
        /**
         * 
         */
        public isOnGround(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public isPassenger(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public  getVisibleName(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         * @param {cn.nukkit.block.Block} block 
         * @param {boolean} cancelled 
         */
        private onPhysicalInteraction(block: cn.nukkit.block.Block,cancelled: boolean): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyFloat(id: int): float;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.Vector3} motion 
         * @param {float} yaw 
         * @param {float} pitch 
         */
        public static getDefaultNBT(pos: cn.nukkit.math.Vector3,motion: cn.nukkit.math.Vector3,yaw: float,pitch: float): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.math.Vector3} motion 
         */
        public static getDefaultNBT(pos: cn.nukkit.math.Vector3,motion: cn.nukkit.math.Vector3): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public static getDefaultNBT(pos: cn.nukkit.math.Vector3): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         */
        public removeAllEffects(): void;
        /**
         * 
         * @param {java.lang.String} score 
         */
        public setScoreTag(score: java.lang.String): void;
        /**
         * 
         */
        public getViewers(): java.util.Map;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public isControlling(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public  getSaveId(): java.lang.String;
        /**
         * 
         * @param {int} id 
         */
        public static getSaveId(id: int): java.lang.String;
        /**
         * 
         * @param {java.lang.String} id 
         */
        public static getSaveId(id: java.lang.String): java.util.OptionalInt;
        /**
         * 
         * @param {java.lang.Class} entityClass 
         * @param {java.util.Map.Entry} entry 
         */
        private static lambda$getSaveId$0(entityClass: java.lang.Class,entry: java.util.Map.Entry): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public setPosition(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         * @param {boolean} noClip 
         */
        public setNoClip(noClip: boolean): void;
        /**
         * 
         */
        public extinguish(): void;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public sendPotionEffects(player: cn.nukkit.Player): void;
        /**
         * 
         */
        protected checkBlockCollision(): void;
        /**
         * 
         */
        public isInsideOfLava(): boolean;
        /**
         * 
         * @param {int} propertyId 
         * @param {int} id 
         * @param {boolean} value 
         */
        public setDataFlag(propertyId: int,id: int,value: boolean): void;
        /**
         * 
         * @param {int} propertyId 
         * @param {int} id 
         */
        public setDataFlag(propertyId: int,id: int): void;
        /**
         * 
         */
        protected getGravity(): float;
        /**
         * 
         * @param {float} absorption 
         */
        public setAbsorption(absorption: float): void;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         */
        public getMetadata(metadataKey: java.lang.String): java.util.List;
        /**
         * 
         */
        public  scheduleUpdate(): void;
        /**
         * 
         */
        public spawnToAll(): void;
        /**
         * 
         * @param {cn.nukkit.block.Block} b 
         */
        private static lambda$checkBlockCollision$5(b: cn.nukkit.block.Block): boolean;
        /**
         * 
         * @param {float} scale 
         */
        public setScale(scale: float): void;
        /**
         * 
         */
        public canCollide(): boolean;
        /**
         * 
         */
        public static getSaveIds(): java.util.List;
        /**
         * 
         * @param {boolean} onGround 
         */
        protected updateFallState(onGround: boolean): void;
        /**
         * 
         * @param {java.lang.String} name 
         */
        public setNameTag(name: java.lang.String): void;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {java.lang.Object[]} args 
         */
        public static  createEntity(name: java.lang.String,chunk: cn.nukkit.level.format.FullChunk,nbt: cn.nukkit.nbt.tag.CompoundTag,...args: java.lang.Object[]): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {int} type 
         * @param {cn.nukkit.level.Position} pos 
         * @param {java.lang.Object[]} args 
         */
        public static  createEntity(type: int,pos: cn.nukkit.level.Position,...args: java.lang.Object[]): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {java.lang.String} name 
         * @param {cn.nukkit.level.Position} pos 
         * @param {java.lang.Object[]} args 
         */
        public static  createEntity(name: java.lang.String,pos: cn.nukkit.level.Position,...args: java.lang.Object[]): cn.nukkit.entity.Entity;
        /**
         * 
         * @param {int} type 
         * @param {cn.nukkit.level.format.FullChunk} chunk 
         * @param {cn.nukkit.nbt.tag.CompoundTag} nbt 
         * @param {java.lang.Object[]} args 
         */
        public static  createEntity(type: int,chunk: cn.nukkit.level.format.FullChunk,nbt: cn.nukkit.nbt.tag.CompoundTag,...args: java.lang.Object[]): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public isInEndPortal(): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyString(id: int): java.lang.String;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyType(id: int): int;
        /**
         * 
         */
        public isAlive(): boolean;
        /**
         * 
         */
        public getEffects(): java.util.Map;
        /**
         * 
         */
        public getScale(): float;
        /**
         * 
         */
        public getNameTag(): java.lang.String;
        /**
         * 
         */
        public getLastDamageCause(): cn.nukkit.event.entity.EntityDamageEvent;
        /**
         * 
         */
        public isOnFire(): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyInt(id: int): int;
        /**
         * 
         * @param {int} effectId 
         */
        public getEffect(effectId: int): cn.nukkit.potion.Effect;
        /**
         * 
         */
        public setSprinting(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setSprinting(value: boolean): void;
        /**
         * 
         */
        public resetFallDistance(): void;
        /**
         * 
         * @param {boolean} value 
         */
        public setCanClimbWalls(value: boolean): void;
        /**
         * 
         */
        public setCanClimbWalls(): void;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyBoolean(id: int): boolean;
        /**
         * 
         */
        public despawnFromAll(): void;
        /**
         * 
         */
        public getDirection(): cn.nukkit.math.BlockFace;
        /**
         * 
         */
        public recalculateBoundingBox(): void;
        /**
         * 
         * @param {boolean} send 
         */
        public recalculateBoundingBox(send: boolean): void;
        /**
         * 
         * @param {cn.nukkit.blockentity.BlockEntityPistonArm} piston 
         */
        public onPushByPiston(piston: cn.nukkit.blockentity.BlockEntityPistonArm): void;
        /**
         * 
         */
        public getMotion(): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {cn.nukkit.level.Location} location 
         */
        public teleport(location: cn.nukkit.level.Location): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         */
        public teleport(pos: cn.nukkit.level.Position): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause} cause 
         */
        public teleport(pos: cn.nukkit.math.Vector3,cause: cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Position} pos 
         * @param {cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause} cause 
         */
        public teleport(pos: cn.nukkit.level.Position,cause: cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause): boolean;
        /**
         * 
         * @param {cn.nukkit.level.Location} location 
         * @param {cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause} cause 
         */
        public teleport(location: cn.nukkit.level.Location,cause: cn.nukkit.event.player.PlayerTeleportEvent.TeleportCause): boolean;
        /**
         * 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        public teleport(pos: cn.nukkit.math.Vector3): boolean;
        /**
         * 
         */
        public getBlocksAround(): java.util.List;
        /**
         * 
         */
        public canClimbWalls(): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyNBT(id: int): cn.nukkit.nbt.tag.CompoundTag;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         * @param {byte} mode 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity,mode: byte): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public mountEntity(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getDataProperty(id: int): cn.nukkit.entity.data.EntityData;
        /**
         * 
         */
        public getId(): long;
        /**
         * 
         * @param {cn.nukkit.potion.Effect} effect 
         */
        public addEffect(effect: cn.nukkit.potion.Effect): void;
        /**
         * 
         * @param {cn.nukkit.level.Position} currentPos 
         */
        private getNearestValidPortal(currentPos: cn.nukkit.level.Position): cn.nukkit.level.Position;
        /**
         * 
         */
        public getBoundingBox(): cn.nukkit.math.AxisAlignedBB;
        /**
         * 
         */
        public isGliding(): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public dismountEntity(entity: cn.nukkit.entity.Entity): boolean;
        /**
         * 
         */
        public isInsideOfSolid(): boolean;
        /**
         * 
         * @param {double} x 
         * @param {double} y 
         * @param {double} z 
         * @param {double} yaw 
         * @param {double} pitch 
         * @param {double} headYaw 
         */
        public addMovement(x: double,y: double,z: double,yaw: double,pitch: double,headYaw: double): void;
        /**
         * 
         */
        protected getDrag(): float;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getDataProperties(): cn.nukkit.entity.data.EntityMetadata;
        /**
         * 
         */
        public hashCode(): int;
        /**
         * 
         */
        protected createAddEntityPacket(): cn.nukkit.network.protocol.DataPacket;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityRegainHealthEvent} source 
         */
        public heal(source: cn.nukkit.event.entity.EntityRegainHealthEvent): void;
        /**
         * 
         * @param {float} amount 
         */
        public heal(amount: float): void;
        /**
         * 
         * @param {int} propertyId 
         * @param {int} id 
         */
        public getDataFlag(propertyId: int,id: int): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyPos(id: int): cn.nukkit.math.Vector3;
        /**
         * 
         * @param {int} effectId 
         */
        public hasEffect(effectId: int): boolean;
        /**
         * 
         * @param {cn.nukkit.entity.Entity} entity 
         */
        public getMountedOffset(entity: cn.nukkit.entity.Entity): cn.nukkit.math.Vector3f;
        /**
         * 
         * @param {float} health 
         */
        public setHealth(health: float): void;
        /**
         * 
         * @param {double} dx 
         * @param {double} dy 
         * @param {double} dz 
         */
        public move(dx: double,dy: double,dz: double): boolean;
        /**
         * 
         */
        public entityBaseTick(): boolean;
        /**
         * 
         * @param {int} tickDiff 
         */
        public entityBaseTick(tickDiff: int): boolean;
        /**
         * 
         */
        public isTouchingWater(): boolean;
        /**
         * 
         */
        public handleLavaMovement(): void;
        /**
         * 
         */
        public canPassThrough(): boolean;
        /**
         * 
         * @param {int} id 
         */
        public getDataPropertyByte(id: int): int;
        /**
         * 
         */
        public hasControllingPassenger(): boolean;
        /**
         * 
         */
        public getAbsorption(): float;
        /**
         * 
         * @param {float} strafe 
         * @param {float} forward 
         * @param {float} friction 
         */
        public moveFlying(strafe: float,forward: float,friction: float): void;
        /**
         * 
         */
        public getSwimmingHeight(): float;
        /**
         * 
         * @param {float} height 
         */
        protected hasWaterAt(height: float): boolean;
        /**
         * 
         */
        public getPosition(): cn.nukkit.level.Position;
        /**
         * 
         */
        public getCollisionBlocks(): java.util.List;
        /**
         * 
         */
        public canBePushed(): boolean;
        /**
         * 
         * @param {double} dx 
         * @param {double} dy 
         * @param {double} dz 
         */
        public fastMove(dx: double,dy: double,dz: double): boolean;
        /**
         * 
         * @param {java.lang.String} metadataKey 
         * @param {cn.nukkit.plugin.Plugin} owningPlugin 
         */
        public removeMetadata(metadataKey: java.lang.String,owningPlugin: cn.nukkit.plugin.Plugin): void;
        /**
         * 
         */
        public getScoreTag(): java.lang.String;
        /**
         * 
         */
        public getPassenger(): cn.nukkit.entity.Entity;
        /**
         * 
         */
        public getLength(): float;
        /**
         * 
         */
        public getSeatPosition(): cn.nukkit.math.Vector3f;
        /**
         * 
         */
        public respawnToAll(): void;
        /**
         * 
         * @param {cn.nukkit.entity.EntityHuman} entityPlayer 
         */
        public onCollideWithPlayer(entityPlayer: cn.nukkit.entity.EntityHuman): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecord13 extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.nbt.tag{
     class ShortTag extends cn.nukkit.nbt.tag.NumberTag{
        /**  */
        data: int;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTInputStream} dis 
         */
         load(dis: cn.nukkit.nbt.stream.NBTInputStream): void;
        /**
         * 
         * @param {java.lang.Integer} data 
         */
        public setData(data: java.lang.Integer): void;
        /**
         * 
         * @param {java.lang.Number} data 
         */
        public  setData(data: java.lang.Number): void;
        /**
         * 
         * @param {java.lang.Object} obj 
         */
        public equals(obj: java.lang.Object): boolean;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public getId(): byte;
        /**
         * 
         */
        public copy(): cn.nukkit.nbt.tag.Tag;
        /**
         * 
         */
        public parseValue(): java.lang.Integer;
        /**
         * 
         */
        public  parseValue(): java.lang.Object;
        /**
         * 
         * @param {cn.nukkit.nbt.stream.NBTOutputStream} dos 
         */
         write(dos: cn.nukkit.nbt.stream.NBTOutputStream): void;
        /**
         * 
         */
        public  getData(): java.lang.Number;
        /**
         * 
         */
        public getData(): java.lang.Integer;
    }
}
declare namespace cn.nukkit.inventory{
    abstract class Recipe extends java.lang.Object{
        /**
         * 
         * @param {java.util.List} haveItems 
         * @param {java.util.List} needItems 
         */
        public static matchItemList(haveItems: java.util.List,needItems: java.util.List): boolean;
        /**
         * 
         */
        public abstract getType(): cn.nukkit.inventory.RecipeType;
        /**
         * 
         */
        public abstract getResult(): cn.nukkit.item.Item;
        /**
         * 
         * @param {cn.nukkit.inventory.CraftingManager} manager 
         */
        public abstract registerToCraftingManager(manager: cn.nukkit.inventory.CraftingManager): void;
    }
}
declare namespace cn.nukkit.entity.passive{
     class EntityWanderingTrader extends cn.nukkit.entity.EntityCreature{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        public initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.math{
     class NukkitMath extends java.lang.Object{
        /**  */
        ZERO_SHORT: java.lang.Short;
        /**  */
        ZERO_BYTE: java.lang.Byte;
        /**  */
        ZERO_INTEGER: java.lang.Integer;
        /**  */
        ZERO_LONG: java.lang.Long;
        /**
         * 
         * @param {byte} data 
         */
        public static bitLength(data: byte): int;
        /**
         * 
         * @param {java.math.BigInteger} data 
         */
        public static bitLength(data: java.math.BigInteger): int;
        /**
         * 
         * @param {long} data 
         */
        public static bitLength(data: long): int;
        /**
         * 
         * @param {int} data 
         */
        public static bitLength(data: int): int;
        /**
         * 
         * @param {double} n 
         */
        public static floorDouble(n: double): int;
        /**
         * 
         * @param {float} n 
         */
        public static ceilFloat(n: float): int;
        /**
         * 
         * @param {double} d 
         */
        public static round(d: double): double;
        /**
         * 
         * @param {double} d 
         * @param {int} precision 
         */
        public static round(d: double,precision: int): double;
        /**
         * 
         * @param {double} diffX 
         * @param {double} diffZ 
         */
        public static getDirection(diffX: double,diffZ: double): double;
        /**
         * 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {int} start 
         * @param {int} end 
         */
        public static randomRange(random: cn.nukkit.math.NukkitRandom,start: int,end: int): int;
        /**
         * 
         * @param {cn.nukkit.math.NukkitRandom} random 
         */
        public static randomRange(random: cn.nukkit.math.NukkitRandom): int;
        /**
         * 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {int} start 
         */
        public static randomRange(random: cn.nukkit.math.NukkitRandom,start: int): int;
        /**
         * 
         * @param {java.lang.Number} storage 
         */
        public static isZero(storage: java.lang.Number): boolean;
        /**
         * 
         * @param {double} n 
         */
        public static ceilDouble(n: double): int;
        /**
         * 
         * @param {float} n 
         */
        public static floorFloat(n: float): int;
        /**
         * 
         * @param {double} value 
         * @param {double} min 
         * @param {double} max 
         */
        public static clamp(value: double,min: double,max: double): double;
        /**
         * 
         * @param {int} value 
         * @param {int} min 
         * @param {int} max 
         */
        public static clamp(value: int,min: int,max: int): int;
        /**
         * 
         * @param {float} value 
         * @param {float} min 
         * @param {float} max 
         */
        public static clamp(value: float,min: float,max: float): float;
    }
}
declare namespace cn.nukkit.item{
     class ItemCoal extends cn.nukkit.item.Item{
        /**
         * 
         */
        public getDamage(): int;
        /**
         * 
         */
        public isCharcoal(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemRecord11 extends cn.nukkit.item.ItemRecord{
        /**
         * 
         */
        public getSoundId(): java.lang.String;
    }
}
declare namespace cn.nukkit.command.defaults{
     class GarbageCollectorCommand extends cn.nukkit.command.defaults.VanillaCommand{
        /**
         * 
         * @param {cn.nukkit.command.CommandSender} sender 
         * @param {java.lang.String} commandLabel 
         * @param {java.lang.String[]} args 
         */
        public execute(sender: cn.nukkit.command.CommandSender,commandLabel: java.lang.String,args: java.lang.String[]): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockEndStone extends cn.nukkit.block.BlockSolid{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getToolTier(): int;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.plugin{
     class PluginEnableEvent extends cn.nukkit.event.plugin.PluginEvent{
    }
}
declare namespace cn.nukkit.scheduler{
    abstract class AsyncTask extends java.lang.Object{
        /**  */
        result: java.lang.Object;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        finished: boolean;
        /**  */
        FINISHED_LIST: java.util.Queue;
        /**  */
        taskId: int;
        /**
         * 
         * @param {cn.nukkit.Server} server 
         */
        public onCompletion(server: cn.nukkit.Server): void;
        /**
         * 
         */
        public getTaskId(): int;
        /**
         * 
         */
        public abstract onRun(): void;
        /**
         * 
         * @param {java.lang.Object} result 
         */
        public setResult(result: java.lang.Object): void;
        /**
         * 
         * @param {java.lang.String} identifier 
         */
        public getFromThreadStore(identifier: java.lang.String): java.lang.Object;
        /**
         * 
         * @param {java.lang.String} identifier 
         * @param {java.lang.Object} value 
         */
        public saveToThreadStore(identifier: java.lang.String,value: java.lang.Object): void;
        /**
         * 
         * @param {int} taskId 
         */
        public setTaskId(taskId: int): void;
        /**
         * 
         */
        public hasResult(): boolean;
        /**
         * 
         */
        public run(): void;
        /**
         * 
         */
        public isFinished(): boolean;
        /**
         * 
         */
        public getResult(): java.lang.Object;
        /**
         * 
         */
        public cleanObject(): void;
        /**
         * 
         */
        public static collectTask(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class EmoteListPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        pieceIds: java.util.List;
        /**  */
        runtimeId: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.entity{
    abstract class EntityInteractable extends java.lang.Object{
        /**
         * 
         */
        public abstract canDoInteraction(): boolean;
        /**
         * 
         */
        public abstract getInteractButtonText(): java.lang.String;
    }
}
declare namespace cn.nukkit.network.protocol{
     class StartGamePacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        vanillaVersion: java.lang.String;
        /**  */
        isTexturePacksRequired: boolean;
        /**  */
        NETWORK_ID: byte;
        /**  */
        GAME_PUBLISH_SETTING_FRIENDS_OF_FRIENDS: int;
        /**  */
        GAME_PUBLISH_SETTING_PUBLIC: int;
        /**  */
        dayCycleStopTime: int;
        /**  */
        hasLockedResourcePack: boolean;
        /**  */
        playerGamemode: int;
        /**  */
        isTrial: boolean;
        /**  */
        isFromWorldTemplate: boolean;
        /**  */
        lightningLevel: float;
        /**  */
        isFromLockedWorldTemplate: boolean;
        /**  */
        levelId: java.lang.String;
        /**  */
        pitch: float;
        /**  */
        rainLevel: float;
        /**  */
        hasConfirmedPlatformLockedContent: boolean;
        /**  */
        trustingPlayers: boolean;
        /**  */
        spawnX: int;
        /**  */
        serverChunkTickRange: int;
        /**  */
        enchantmentSeed: int;
        /**  */
        spawnZ: int;
        /**  */
        spawnY: int;
        /**  */
        multiplayerGame: boolean;
        /**  */
        difficulty: int;
        /**  */
        isInventoryServerAuthoritative: boolean;
        /**  */
        permissionLevel: int;
        /**  */
        multiplayerCorrelationId: java.lang.String;
        /**  */
        hasAchievementsDisabled: boolean;
        /**  */
        isMovementServerAuthoritative: boolean;
        /**  */
        worldGamemode: int;
        /**  */
        isWorldTemplateOptionLocked: boolean;
        /**  */
        GAME_PUBLISH_SETTING_FRIENDS_ONLY: int;
        /**  */
        bonusChest: boolean;
        /**  */
        isUsingMsaGamertagsOnly: boolean;
        /**  */
        seed: int;
        /**  */
        broadcastToLAN: boolean;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**  */
        eduEditionOffer: int;
        /**  */
        entityUniqueId: long;
        /**  */
        generator: int;
        /**  */
        commandsEnabled: boolean;
        /**  */
        hasEduFeaturesEnabled: boolean;
        /**  */
        entityRuntimeId: long;
        /**  */
        gameRules: cn.nukkit.level.GameRules;
        /**  */
        hasStartWithMapEnabled: boolean;
        /**  */
        worldName: java.lang.String;
        /**  */
        dimension: byte;
        /**  */
        currentTick: long;
        /**  */
        isOnlySpawningV1Villagers: boolean;
        /**  */
        yaw: float;
        /**  */
        premiumWorldTemplateId: java.lang.String;
        /**  */
        GAME_PUBLISH_SETTING_INVITE_ONLY: int;
        /**  */
        platformBroadcastIntent: int;
        /**  */
        hasLockedBehaviorPack: boolean;
        /**  */
        GAME_PUBLISH_SETTING_NO_MULTI_PLAY: int;
        /**  */
        x: float;
        /**  */
        y: float;
        /**  */
        xblBroadcastIntent: int;
        /**  */
        z: float;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedstoneComparatorUnpowered extends cn.nukkit.block.BlockRedstoneComparator{
        /**
         * 
         */
        protected getUnpowered(): cn.nukkit.block.BlockRedstoneComparator;
        /**
         * 
         */
        protected  getUnpowered(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockRedstoneEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        newPower: int;
        /**  */
        oldPower: int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getNewPower(): int;
        /**
         * 
         */
        public getOldPower(): int;
    }
}
declare namespace cn.nukkit.event.block{
     class LiquidFlowEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        newFlowDecay: int;
        /**  */
        to: cn.nukkit.block.Block;
        /**  */
        source: cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getSource(): cn.nukkit.block.BlockLiquid;
        /**
         * 
         */
        public getTo(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getNewFlowDecay(): int;
    }
}
declare namespace cn.nukkit.event.player{
     class PlayerChunkRequestEvent extends cn.nukkit.event.player.PlayerEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**  */
        chunkX: int;
        /**  */
        chunkZ: int;
        /**
         * 
         */
        public getChunkZ(): int;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getChunkX(): int;
    }
}
declare namespace cn.nukkit.network.protocol{
     class MovePlayerPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        MODE_RESET: int;
        /**  */
        eid: long;
        /**  */
        NETWORK_ID: byte;
        /**  */
        ridingEid: long;
        /**  */
        headYaw: float;
        /**  */
        yaw: float;
        /**  */
        mode: int;
        /**  */
        int2: int;
        /**  */
        int1: int;
        /**  */
        onGround: boolean;
        /**  */
        MODE_NORMAL: int;
        /**  */
        x: float;
        /**  */
        MODE_TELEPORT: int;
        /**  */
        y: float;
        /**  */
        z: float;
        /**  */
        pitch: float;
        /**  */
        MODE_PITCH: int;
        /**  */
        frame: long;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.network.protocol{
     class DisconnectPacket extends cn.nukkit.network.protocol.DataPacket{
        /**  */
        NETWORK_ID: byte;
        /**  */
        hideDisconnectionScreen: boolean;
        /**  */
        message: java.lang.String;
        /**
         * 
         */
        public encode(): void;
        /**
         * 
         */
        public toString(): java.lang.String;
        /**
         * 
         */
        public pid(): byte;
        /**
         * 
         */
        public decode(): void;
    }
}
declare namespace cn.nukkit.item{
     class ItemShovelNetherite extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isShovel(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemSwordIron extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public isSword(): boolean;
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.item{
     class ItemMuttonCooked extends cn.nukkit.item.ItemEdible{
    }
}
declare namespace cn.nukkit.scheduler{
    abstract class Task extends java.lang.Object{
        /**  */
        taskHandler: cn.nukkit.scheduler.TaskHandler;
        /**  */
        log: org.apache.logging.log4j.Logger;
        /**
         * 
         */
        public cancel(): void;
        /**
         * 
         */
        public  getTaskId(): int;
        /**
         * 
         * @param {cn.nukkit.scheduler.TaskHandler} taskHandler 
         */
        public  setHandler(taskHandler: cn.nukkit.scheduler.TaskHandler): void;
        /**
         * 
         * @param {int} currentTick 
         */
        public abstract onRun(currentTick: int): void;
        /**
         * 
         */
        public onCancel(): void;
        /**
         * 
         */
        public  run(): void;
        /**
         * 
         */
        public  getHandler(): cn.nukkit.scheduler.TaskHandler;
    }
}
declare namespace cn.nukkit.entity.mob{
     class EntityWitch extends cn.nukkit.entity.mob.EntityMob{
        /**  */
        NETWORK_ID: int;
        /**
         * 
         */
        public getHeight(): float;
        /**
         * 
         */
        public getNetworkId(): int;
        /**
         * 
         * @param {cn.nukkit.Player} player 
         */
        public isPreventingSleep(player: cn.nukkit.Player): boolean;
        /**
         * 
         */
        public getWidth(): float;
        /**
         * 
         */
        protected initEntity(): void;
        /**
         * 
         */
        public getOriginalName(): java.lang.String;
    }
}
declare namespace cn.nukkit.block{
     class BlockRedSandstone extends cn.nukkit.block.BlockSandstone{
        /**
         * 
         */
        public canHarvestWithHand(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         */
        public toItem(): cn.nukkit.item.Item;
    }
}
declare namespace cn.nukkit.event{
    abstract class Listener extends java.lang.Object{
    }
}
declare namespace cn.nukkit.event.level{
     class ChunkPopulateEvent extends cn.nukkit.event.level.ChunkEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace com.blocklynukkit.loader.script.event{
     class StoneSpawnEvent extends cn.nukkit.event.Event{
        /**  */
        pos: cn.nukkit.level.Position;
        /**  */
        block: cn.nukkit.block.Block;
        /**
         * 
         */
        public getBlock(): cn.nukkit.block.Block;
        /**
         * 
         */
        public getPosition(): cn.nukkit.level.Position;
        /**
         * 
         * @param {boolean} cancelled 
         */
        public setCancelled(cancelled: boolean): void;
    }
}
declare namespace cn.nukkit.block{
     class BlockDeadBush extends cn.nukkit.block.BlockFlowable{
        /**
         * 
         */
        public canBeReplaced(): boolean;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getWaterloggingLevel(): int;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getColor(): cn.nukkit.utils.BlockColor;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        private isSupportValid(): boolean;
    }
}
declare namespace cn.nukkit.block{
     class BlockChorusFlower extends cn.nukkit.block.BlockTransparent{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        AGE: cn.nukkit.blockproperty.IntBlockProperty;
        /**
         * 
         */
        public sticksToPiston(): boolean;
        /**
         * 
         */
        public getToolType(): int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getHardness(): double;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getResistance(): double;
        /**
         * 
         */
        public getId(): int;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         */
        public getDrops(item: cn.nukkit.item.Item): cn.nukkit.item.Item[];
        /**
         * 
         */
        public breaksWhenMoved(): boolean;
        /**
         * 
         * @param {cn.nukkit.item.Item} item 
         * @param {cn.nukkit.block.Block} block 
         * @param {cn.nukkit.block.Block} target 
         * @param {cn.nukkit.math.BlockFace} face 
         * @param {double} fx 
         * @param {double} fy 
         * @param {double} fz 
         * @param {cn.nukkit.Player} player 
         */
        public place(item: cn.nukkit.item.Item,block: cn.nukkit.block.Block,target: cn.nukkit.block.Block,face: cn.nukkit.math.BlockFace,fx: double,fy: double,fz: double,player: cn.nukkit.Player): boolean;
        /**
         * 
         * @param {int} type 
         */
        public onUpdate(type: int): int;
        /**
         * 
         */
        private isPositionValid(): boolean;
    }
}
declare namespace cn.nukkit.event.inventory{
     class InventoryPickupItemEvent extends cn.nukkit.event.inventory.InventoryEvent{
        /**  */
        item: cn.nukkit.entity.item.EntityItem;
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public getItem(): cn.nukkit.entity.item.EntityItem;
    }
}
declare namespace cn.nukkit.event.block{
     class BlockFallEvent extends cn.nukkit.event.block.BlockEvent{
        /**  */
        handlers: cn.nukkit.event.HandlerList;
        /**
         * 
         */
        public static getHandlers(): cn.nukkit.event.HandlerList;
    }
}
declare namespace cn.nukkit.item{
     class ItemChestplateLeather extends cn.nukkit.item.ItemColorArmor{
        /**
         * 
         */
        public getArmorPoints(): int;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
        /**
         * 
         */
        public isChestplate(): boolean;
    }
}
declare namespace cn.nukkit.item{
     class ItemAxeNetherite extends cn.nukkit.item.ItemTool{
        /**
         * 
         */
        public getAttackDamage(): int;
        /**
         * 
         */
        public isAxe(): boolean;
        /**
         * 
         */
        public isLavaResistant(): boolean;
        /**
         * 
         */
        public getMaxDurability(): int;
        /**
         * 
         */
        public getTier(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockTerracottaGlazedRed extends cn.nukkit.block.BlockTerracottaGlazed{
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getDyeColor(): cn.nukkit.utils.DyeColor;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.event.plugin{
     class PluginDisableEvent extends cn.nukkit.event.plugin.PluginEvent{
    }
}
declare namespace cn.nukkit.entity.item{
    abstract class EntityVehicle extends cn.nukkit.entity.Entity{
        /**  */
        rollingDirection: boolean;
        /**
         * 
         */
        public getDamage(): int;
        /**
         * 
         */
        protected performHurtAnimation(): boolean;
        /**
         * 
         * @param {int} time 
         */
        public setRollingAmplitude(time: int): void;
        /**
         * 
         */
        public canDoInteraction(): boolean;
        /**
         * 
         * @param {cn.nukkit.event.entity.EntityDamageEvent} source 
         */
        public attack(source: cn.nukkit.event.entity.EntityDamageEvent): boolean;
        /**
         * 
         * @param {int} direction 
         */
        public setRollingDirection(direction: int): void;
        /**
         * 
         */
        public getRollingDirection(): int;
        /**
         * 
         * @param {int} damage 
         */
        public setDamage(damage: int): void;
        /**
         * 
         */
        public getInteractButtonText(): java.lang.String;
        /**
         * 
         * @param {int} currentTick 
         */
        public onUpdate(currentTick: int): boolean;
        /**
         * 
         */
        public getRollingAmplitude(): int;
    }
}
declare namespace cn.nukkit.block{
     class BlockUnknown extends cn.nukkit.block.BlockMeta{
        /**  */
        PROPERTIES: cn.nukkit.blockproperty.BlockProperties;
        /**  */
        UNKNOWN: cn.nukkit.blockproperty.UnsignedIntBlockProperty;
        /**  */
        id: int;
        /**
         * 
         */
        public getName(): java.lang.String;
        /**
         * 
         */
        public getProperties(): cn.nukkit.blockproperty.BlockProperties;
        /**
         * 
         */
        public getId(): int;
    }
}
declare namespace cn.nukkit.level.generator.object.tree{
     class ObjectJungleBigTree extends cn.nukkit.level.generator.object.tree.HugeTreesGenerator{
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} i1 
         */
        private createCrown(level: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3,i1: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} random 
         * @param {cn.nukkit.math.Vector3} pos 
         * @param {int} meta 
         */
        private placeVine(level: cn.nukkit.level.ChunkManager,random: cn.nukkit.math.NukkitRandom,pos: cn.nukkit.math.Vector3,meta: int): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {cn.nukkit.math.Vector3} position 
         */
        public generate(level: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,position: cn.nukkit.math.Vector3): boolean;
    }
}
declare namespace cn.nukkit.level.generator.object.tree{
     class ObjectSavannaTree extends cn.nukkit.level.generator.object.tree.TreeGenerator{
        /**  */
        TRUNK: cn.nukkit.block.Block;
        /**  */
        LEAF: cn.nukkit.block.Block;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        private placeLeafAt(worldIn: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} worldIn 
         * @param {cn.nukkit.math.Vector3} pos 
         */
        private placeLogAt(worldIn: cn.nukkit.level.ChunkManager,pos: cn.nukkit.math.Vector3): void;
        /**
         * 
         * @param {cn.nukkit.level.ChunkManager} level 
         * @param {cn.nukkit.math.NukkitRandom} rand 
         * @param {cn.nukkit.math.Vector3} position 
         */
        public generate(level: cn.nukkit.level.ChunkManager,rand: cn.nukkit.math.NukkitRandom,position: cn.nukkit.math.Vector3): boolean;
    }
}
